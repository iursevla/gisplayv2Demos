<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/Gisplay/Maps/Map.js | Gisplay API Documentation API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Gisplay</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Gisplay.js~Gisplay.html">Gisplay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/GisplayOptions.js~GisplayOptions.html">GisplayOptions</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Gisplay/Maps</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Aesthetic.js~Aesthetic.html">Aesthetic</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/BGMapWrapper.js~BGMapWrapper.html">BGMapWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Feature.js~Feature.html">Feature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Legend.js~Legend.html">Legend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Map.js~Map.html">Map</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Gisplay/Maps/Types</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Types/ChangeMap.js~ChangeMap.html">ChangeMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Types/ChorochromaticMap.js~ChorochromaticMap.html">ChorochromaticMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Types/Choropleth.js~Choropleth.html">Choropleth</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Types/DotMap.js~DotMap.html">DotMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Types/ProportionalSymbolsMap.js~ProportionalSymbolsMap.html">ProportionalSymbolsMap</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Gisplay/Maps/Map.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { BGMapWrapper } from &apos;./BGMapWrapper&apos;;
import { Aesthetic } from &apos;./Aesthetic&apos;;
import { GisplayOptions } from &apos;../GisplayOptions&apos;;

/**
 * This class contains the Map class which represents the current map.
 * Each map has a group of functions available. There is only one map yet(maybe there will be two if we want to compare two).
 * @see Diogo&apos;s thesis 57-60 + 64/65
 */
export class Map {

    /**
     * Map constructor. All Map subclasses should call this first with super(...).
     * @param {BGMapWrapper|Object} bgmap - Background map.
     * @param {JSON} geometry - Geometry read from the file.
     * @param {Object} userOptions - The user defined options. 
     * @todo With the type of the map we can do an if statement inside constructor to use or not some of the variables.
     */
    constructor(bgmap, geometry, userOptions) {
        //console.log(&quot;Map constructor called -&gt; super()&quot;);
        /**
          * This object holds for each point it&apos;s long, lat and associated properties. 
          * This points will be used by k-d Tree. And k-d Tree is used to find the closest point to where the user clicked.
          * @type {Array&lt;{lon: number, lat: number, properties: JSON}&gt;}
          */
        this.treepoints = [];

        // ####################### DOT MAP ONLY
        /**
          * Holds the points for each Aesthethic object.
          * @type {Array&lt;Array&lt;number&gt;&gt;}
          */
        this.tempAestheticPoints = new Array();

        // ####################### ALL MAPS
        /**
         * Aesthetic objects that were saved.
         * @type {Array&lt;Aesthetic&gt;}
         */
        this.aesthetics = new Array();
        /**
         * JSON object with the geometry that was read from the file.
         * @type {JSON}
         */
        this.geometry = geometry;
        /**
         * This map unique identifier.
         * @type {number}
         */
        this.id = window.mapcount++;

        /**
         * KdTree object to hold that will be used to calculate the closest point to the coordinates where the user made a click.
         * @type {kdTree}
         * @see Diogo&apos;s thesis Page 61.
         */
        this.kdtree = undefined;
        /**
         * RBush(Rtree implementation) that is used to calculate the polygon closest to the coordinates where the user made a click.
         * @type {PolygonLookup}
         * @see Diogo&apos;s thesis page 61.
         */
        this.rtree = undefined;
        /**
         * Polygons do/do not exist. This is used to know if it to create a rtree or not on buildTrees method.
         * @type {boolean}
         */
        this.hasPolygons = false;
    }

    /**
     * M1) Loads user and default options. For each case if it isn&apos;t provided by the user, then it uses
     * the default option. 1st method to be called.
     * @param {Object} userOptions - Options given by the user. 
     * @param {Object} bgmap  - The background map provider.
     */
    loadOptions(userOptions, bgmap) {
        /**
         * All the options available in the Gisplay API.
         * @type {GisplayOptions}
         */
        this.gisplayOptions = new GisplayOptions(userOptions);

        /**
         * The background map to be used. This map will  be drawn over the background map(bGMap).
         * @type {BGMapWrapper}
         */
        this.bGMap = this.gisplayOptions.useCustomMapService ? bgmap : new BGMapWrapper(bgmap);
        if (this.gisplayOptions.showLoader)
            this.showLoader();
    }

    /**
     * M2) Calls the Background Map Wrapper to create the loader to be used later when the user feeds data to the API.
     * @deprecated Not used anymore
     */
    showLoader() {
        this.bGMap.showLoader();
    }

    /**
     * M3) Initializes the API by: creating canvas, the WebGL program and setting up all needed events.
     * @return {void}
     */
    initialize() {
        /**
         * This is the maixmum value found on the dataset. The final value for the break. E.g. [2, 37[ 37 is the max. 
         * Used for PSymbol Map and Change Map because on those maps it&apos;s important to take in consideration this values to define the Feature color.
         * @see Diogo&apos;s thesis page 63 5.1.3 
         * @type {number}
         */
        this.max = null;
        /**
         * This is the minimum value found on the dataset. The initial value for the break. E.g. [2, 37[ 2 is the min.
         * Used for PSymbol Map and Change Map because on those maps it&apos;s important to take in consideration this values to define the Feature color.
         * @see Diogo&apos;s thesis page 63 5.1.3
         * @type {number}
         */
        this.min = null;
        this.createCanvas();
        this.program();
        this.bGMap.onEvent(&apos;move&apos;, () =&gt; { this.draw(); });
        this.setupFunctionOnclick(this.id);
    }

    /**
     * M4) Creates a canvas element and WebGL associated information.
     */
    createCanvas() {
        const canvas = this.bGMap.createCanvas(this.id);

        /**
         * @type {Object} _webgl - WebGL object.  Init webgl properties
         * @property  {WebGLRenderingContext} _webgl.gl - The WebGLRenderingContext to be used.
         * @property  {WebGLProgram} _webgl.program -  The WebGLProgram to be used.
         * @property  {Float32Array} _webgl.projection - The projection 
         * @see Diogo&apos;s thesis page 64+
         */
        this._webgl = {
            gl: null,
            program: null,
            projection: null
        };

        this._webgl.gl = canvas.getContext(&quot;webgl&quot;);
        this._webgl.projection = new Float32Array(16);
        this._webgl.projection.set(
            [2 / canvas.width, 0, 0, 0,
                0, -2 / canvas.height, 0, 0,
                0, 0, 0, 0,
            -1, 1, 0, 1]
        );

        this._webgl.gl.viewport(0, 0, this.bGMap.getContainer().offsetWidth, this.bGMap.getContainer().offsetHeight);
        this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);
    }

    /**
     * M5) Initializes: 
     * 1)WebGLProgram, 2) Generates shadders, 3) Attaches shaders to the program, 4) links program, 5) uses program.
     */
    program() {
        this._webgl.program = this._webgl.gl.createProgram();

        const source_code = this.generateShadersSourceCode();
        const vertex_shader = this.createAndCompileShader(this._webgl.gl.VERTEX_SHADER, source_code.vertexCode, this._webgl);
        const fragment_shader = this.createAndCompileShader(this._webgl.gl.FRAGMENT_SHADER, source_code.fragmentCode, this._webgl);

        this._webgl.gl.attachShader(this._webgl.program, vertex_shader);
        this._webgl.gl.attachShader(this._webgl.program, fragment_shader);

        this._webgl.gl.linkProgram(this._webgl.program);
        this._webgl.gl.useProgram(this._webgl.program);
    }

    /**
     * M6) Creates shaders(Vertex + Fragment) source code.
     * @return {{vertexCode: string, fragmentCode: string}} - The code for the vertex and fragment shaders.
     */
    generateShadersSourceCode() { //Added HERE by Rui Refactor to use ES6 `` instead of +=
        //general
        let vertexSourceCode =
            `
         	uniform mat4 projection;
            attribute vec4 vertexCoord; 
         	attribute float aPointSize; 
         	attribute float a_opacity; 
         	varying float v_opacity; 
         	void main() {
         		gl_Position = (projection * vertexCoord); 
         		gl_PointSize = aPointSize; 
                v_opacity = a_opacity; 
            }
        `;

        let fragmentSourceCode = //TODO: Remove unnecessary brackets {}
            ` 
            precision mediump float;
         	uniform vec4 u_color;
         	varying float v_opacity; 
           	uniform float isPoint;
            void main() {
         		float border = 0.5;
         		float radius = 0.5;
         		float centerDist = length(gl_PointCoord - 0.5);
         		float alpha;
         		if (u_color[3] == -1.0) {   
         			alpha =  v_opacity * step(centerDist, radius);
         		}
         		else {
         			alpha =  u_color[3] * step(centerDist, radius);
         		}
         		if(isPoint == 1.0 ) {
         		    if (alpha &lt; 0.1) discard;
         			    gl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);
                }
           		else
         			gl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);
         	}
        `;
        return { vertexCode: vertexSourceCode, fragmentCode: fragmentSourceCode };
    }

    /**
     * M7?) Creates and compiles a shader.
     * @param {string} type - Type of shader. Options are: VERTEX_SHADER or FRAGMENT_SHADER;
     * @param {string} source_code - The shader source code.
     * @param {Map#_webgl} _webgl - Webgl object that this class contains.
     * @returns {WebGLShader} - The shader(vertex of fragment).
     * @memberOf Map
     */
    createAndCompileShader(type, source_code, _webgl) { //Added HERE by Rui
        let shader = _webgl.gl.createShader(type);
        _webgl.gl.shaderSource(shader, source_code);
        _webgl.gl.compileShader(shader);
        return shader;
    }

    /**
     * M7) Sets up a function to be fired when we click on this Map.
     * Assigns the click event on the map to the function specified by the user options. 
     * If the attribute interative from the user options is != from false then fires the default function(alert).  
     * Will use rtree to find the closest polygon to the where the clicked event happened.
     * Will use kdtree to find the closest point to where the click event happened.
     * @todo This method is doing uneccessary job if the user set interative to false and mapOnClickFunction is undefined.
     * @param {number} mappos - This map id. 
     * @see http://stackoverflow.com/a/34349737
     * @return {void}
     */
    setupFunctionOnclick(mappos) {
        /*if(!this.gisplayOptions.interactive &amp;&amp; this.gisplayOptions.mapOnClickFunction === undefined)
            return;*/
        this.bGMap.onEvent(&apos;click&apos;, e =&gt; {
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;

            /**
             * When dealing with polygons rtree will be used.
             * @see Diogo&apos;s thesis Page 62
             */
            if (this.rtree !== undefined) {
                let rtreeSearchResult = this.rtree.search(lon, lat);
                if (rtreeSearchResult === undefined)
                    return;
                else {
                    let res = &quot;&quot;;
                    let showPrtOnClick = this.gisplayOptions.showPropertiesOnClick;
                    if (showPrtOnClick !== null) {
                        for (let i = 0; i &lt; showPrtOnClick.length; i += 2) {
                            if (i === 0)
                                res += `${showPrtOnClick[i + 1]}: ${rtreeSearchResult.properties[showPrtOnClick[i]]}`;
                            else
                                res += `\n${showPrtOnClick[i + 1]}: ${rtreeSearchResult.properties[showPrtOnClick[i]]}`;
                        }
                    }
                    else {
                        let keys = Object.keys(rtreeSearchResult.properties);
                        for (let [i, key] of keys.entries())
                            if (key !== &quot;_gisplayid&quot;)
                                i == 0 ? res += `${key}: ${rtreeSearchResult.properties[key]}` : res += `\n${key}: ${rtreeSearchResult.properties[key]}`;
                    }

                    if (this.gisplayOptions.interactive)
                        alert(res);//todo
                    if (this.gisplayOptions.mapOnClickFunction !== undefined)
                        this.gisplayOptions.mapOnClickFunction(rtreeSearchResult);
                }
            }

            /**
             * When dealing with points kdtree will be used.
             * @see Diogo&apos;s thesis page 62
             */
            if (this.kdtree !== undefined) {

                const nearest = this.kdtree.nearest({ lat, lon }, 1, 128 / ((2 ** (this.bGMap.getZoom() * 2))));
                if (nearest.length &lt;= 0)
                    return;
                else {
                    let kdTreeSearchResult = nearest[0][0];
                    let res = &quot;&quot;;
                    let showPrtOnClick = this.gisplayOptions.showPropertiesOnClick;
                    if (showPrtOnClick !== null) { //TODO: Remove if dentro do for e passar a come&#xE7;ar no i=1 e passar o if para antes do for
                        for (let i = 0; i &lt; showPrtOnClick.length; i += 2) {
                            if (i === 0)
                                res += `${showPrtOnClick[i + 1]}: ${kdTreeSearchResult.properties[showPrtOnClick[i]]}`;
                            else
                                res += `\n${showPrtOnClick[i + 1]}: ${kdTreeSearchResult.properties[showPrtOnClick[i]]}`;
                        }
                    }
                    else {
                        let keys = Object.keys(kdTreeSearchResult.properties);
                        for (let [i, key] of keys.entries())
                            if (key !== &quot;_gisplayid&quot;)
                                i == 0 ? res += `${key}: ${kdTreeSearchResult.properties[key]}` : res += `\n${key}: ${kdTreeSearchResult.properties[key]}`;
                    }

                    if (this.gisplayOptions.interactive)
                        alert(res);
                    if (this.gisplayOptions.mapOnClickFunction !== undefined)
                        this.gisplayOptions.mapOnClickFunction(kdTreeSearchResult);
                }
            }
        });
    }

    /** ########################   METHOD from Gisplay.js    ######################## */
    /**
     * M8) Method that executes all the process associated with the creation of the thematic map.
     * @memberOf Map
     */
    makeMap() {
        let opts = this.gisplayOptions;
        setTimeout(console =&gt; {
            if (opts.colorScheme === undefined)
                opts.colorScheme = this.defaults(opts.colorSchemeId).colorScheme;
            if (opts.classBreaks === undefined) {
                if (opts.numberOfClasses === undefined)
                    opts.numberOfClasses = this.defaults(opts.colorSchemeId).numberOfClasses;
                this.preProcessData(this.geometry, opts.numberOfClasses, opts.classBreaksMethod, opts.colorScheme);
            }

            this.loadGeoJSON(this.geometry);
            this.draw();

            if (opts.showLegend)
                this.buildLegend();
            if (opts.showLoader) //@TODO: Change this if to be the 1st thing done inside the setTimeout
                this.showLoader();
        }, 1);
    }

    /**
     * M9) Creates Aesthetic objects. If there&apos;s the need to calculate the class intervals,
     * the method calcClassBreaks is called 
     * @param {JSON} geojson - GeoJSON object.
     * @param {number} numberOfClasses - Number of classes that the Legend will contain.
     * @param {string} classBreaksMethod - Algorithm to be used to calculate class breaks. Only used it class breaks are not given by the user.
     * @param {string[]} colorscheme - Color scheme to be used by this map.
     * 
     * @memberOf Map
     */
    preProcessData(geojson, numberOfClasses, classBreaksMethod, colorscheme) {
        /**
         * @type {Array&lt;Aesthetic&gt;}
         */
        const aesarray = []; //Array of aesthetic objects loaded from the file
        const numberValues = []; //The attr is a number
        const stringValues = []; //The attr is a string
        let classBreaks; //Class Breaks given by the user or calculated by the API
        let fcolor; //Colors to be used
        let opts = this.gisplayOptions; //Options given by the user and defaults

        let geoJsonFeaturesLength = geojson.features.length;
        for (let i = 0; i &lt; geoJsonFeaturesLength &amp;&amp; (i &lt; opts.maxFeatures); i++) { //@TODO?: Two fors one if attr is a string another if it a number
            let attrValue = geojson.features[i].properties[opts.attr];
            if (attrValue !== null &amp;&amp; typeof attrValue === &apos;number&apos;) { //If &quot;f3&quot; exists and its a number
                numberValues.push(attrValue);
                this.max = Math.max(this.max, attrValue);
                this.min = Math.min(this.min, attrValue);
            }
            else if (!stringValues.includes(attrValue)) //If its a string
                stringValues.push(geojson.features[i].properties[opts.attr]);
        }

        if (numberValues.length &gt; 0) { //Quantitative
            if (opts.classBreaks === undefined) { //Not given by the user then calculate them
                if (numberOfClasses &gt; 1)
                    classBreaks = this.calcClassBreaks(numberValues, classBreaksMethod, numberOfClasses);
                else
                    classBreaks = [this.min, this.max]; //Change Map
            }
            else //Given by the user
                classBreaks = opts.classBreaks;

            if (classBreaks.length &gt; 2) {
                fcolor = chroma.scale(colorscheme).colors(classBreaks.length - 1);
                for (let i = 0; i &lt; classBreaks.length - 1; i++) {
                    let [r, g, b] = chroma(fcolor[i]).rgb(); // let color = chroma(fcolor[i]).rgb();
                    let aes;
                    if (i !== classBreaks.length - 2)
                        aes = new Aesthetic(i, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[i], classBreaks[i + 1]]);
                    else {
                        aes = new Aesthetic(i, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[i], classBreaks[i + 1]]);
                        aes.outer = true;
                    }
                    aesarray.push(aes);
                }
            }
            else {
                let [r, g, b] = chroma(colorscheme[0]).rgb();// let color = chroma(colorscheme[0]).rgb();
                let aes = new Aesthetic(0, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[0], classBreaks[1]]);
                aes.outer = true;
                aesarray.push(aes);
            }
        }
        else { //Qualitative
            if (stringValues.length &gt; 0) {
                classBreaks = stringValues;
                if (typeof colorscheme === &apos;string&apos;) //string
                    fcolor = chroma.scale(colorscheme).colors(classBreaks.length);
                else  //array
                    fcolor = chroma.scale(colorscheme).colors(classBreaks.length);

                for (let i = 0; i &lt; classBreaks.length; i++) {
                    let [r, g, b] = chroma(fcolor[i]).rgb();// let color = chroma(fcolor[i]).rgb();
                    let aes = new Aesthetic(i, opts.attr, [Math.round(r), Math.round(g), Math.round(b), 1], [0, 0, 0, 1], null, [stringValues[i]]);
                    aesarray.push(aes);
                }
            }
        }

        /**
         * All the Aesthetics that were read from the GeoJSON file.
         * @type {Array&lt;Aesthetic&gt;}
         */
        this.aesthetics = aesarray;
    }

    /**
     * M10) Calculates the class breaks using the algorithm given(k-means, quantile or equidistant). 
     * There will be as many class breaks as number of classes(numberOfClasses) given as input. 
     * @param {number[]} numberValues - The data values that will be used to be compute the breaks. 
     * @param {string} classBreakMethod - The algorithm to use to calculate the class breaks.
     * @param {number} numberOfClasses - Number of classes the result expects.
     * @returns {number[]} - The class breaks resulting from the use of the given algorithm and the number of classes.
     * @see http://gka.github.io/chroma.js/#chroma-limits
     * @memberOf Map
     */
    calcClassBreaks(numberValues, classBreakMethod, numberOfClasses) {
        let classBreaks;
        switch (classBreakMethod) {
            case &apos;equidistant&apos;:
                classBreaks = chroma.limits(numberValues, &apos;e&apos;, numberOfClasses);
                break;

            case &apos;quantile&apos;:
                classBreaks = chroma.limits(numberValues, &apos;q&apos;, numberOfClasses);
                break;

            case &apos;k-means&apos;:
                classBreaks = chroma.limits(numberValues, &apos;k&apos;, numberOfClasses);
                break;

            default:
                classBreaks = chroma.limits(numberValues, &apos;q&apos;, numberOfClasses);
                break;
        }
        return classBreaks;
    }

    /**
     * M11) Loads GeoJSON object that came from the file uploaded by the user. 
     * Extracts the Features present in the geometry object and inserts them in Aesthetic object(s)
     * This method will create and insert features to Aesthetic objects and build trees of relationships between points or polygons.
     * @param {JSON} geojson - GeoJSON read from the file.
     * @see https://www.dashingd3js.com/lessons/geojson
     * @memberOf Map
     */
    loadGeoJSON(geojson) {
        for (let i = 0; i &lt; geojson.features.length &amp;&amp; (this.gisplayOptions.maxFeatures === undefined || i &lt; this.gisplayOptions.maxFeatures); i++) {
            geojson.features[i].properties[&apos;_gisplayid&apos;] = i;
            const geometry = geojson.features[i].geometry;
            const properties = geojson.features[i].properties;
            this.createAndInsertFeature(i, geometry, properties);
        }
        this.buildTrees(geojson); //@TODO: Only call this method if it&apos;s a low end device aka options.memorySaver is on
    }

    /**
     * M12) Creates a Feature and then calls a method to insert said Feature in one or more Aesthetic objects.
     * @param {number} featureId - Id of the Feature.
     * @param {JSON} geometry - GeoJSON Geometry Object. 
     * @param {JSON} properties - GeoJSON properties Object.
     * @see http://geojson.org/geojson-spec.html#geometry-objects
     * @memberOf Map
     */
    createAndInsertFeature(featureId, geometry, properties) {
        const gl = this._webgl.gl;
        /**
         * @type {GisplayOptions}
         */
        let opts = this.gisplayOptions;
        if (opts.minuend !== undefined &amp;&amp; opts.subtrahend !== undefined
            &amp;&amp; typeof properties[opts.minuend] === &apos;number&apos; &amp;&amp; typeof properties[opts.subtrahend] === &apos;number&apos;
            &amp;&amp; properties[opts.minuend] !== undefined &amp;&amp; properties[opts.subtrahend] !== undefined) {
            properties[opts.attr] = properties[opts.minuend] - properties[opts.subtrahend]; //Used for Change map
        }

        //let isPoint = geometry.type == &quot;Point&quot;;
        if (geometry.type === &quot;Polygon&quot; || geometry.type === &quot;MultiPolygon&quot;) {
            this.hasPolygons = true;
            const polygons = this.processPolygon({ geometry, properties });

            const currentTriangles = []; //Polygon Triangles vertices
            const bufferT = []; //WebGL Buffers with  triangles
            const currentBorders = []; //Polygon Borders vertices
            const bufferB = []; //Buffer borders

            for (let i = 0; i &lt; polygons.length; i++) { //For each Polygon
                const trianglesPolygon = polygons[i].triangles;
                const border = polygons[i].vertices;
                currentTriangles[i] = new Array(); //Add This Polygon triangles
                currentBorders[i] = new Array(); //Add this Polygon borders

                for (let j = 0; j &lt; trianglesPolygon.length; j++) { //Triangles
                    let pixel = this.latLongToPixelXY(border[trianglesPolygon[j] * 2], border[trianglesPolygon[j] * 2 + 1]);
                    currentTriangles[i].push(pixel.x, pixel.y);

                    if (j === trianglesPolygon.length - 1) {
                        bufferT.push(gl.createBuffer());

                        let vertArray = new Float32Array(currentTriangles[i]);
                        gl.fsize = vertArray.BYTES_PER_ELEMENT;
                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[i]);
                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);

                        bufferT[i].itemSize = 2;
                        bufferT[i].numItems = vertArray.length / 2;
                    }
                }

                for (let k = 0; k &lt; border.length; k += 2) { //Borders
                    let pixel = this.latLongToPixelXY(border[k], border[k + 1]);
                    currentBorders[i].push(pixel.x, pixel.y);

                    if (k === border.length - 2) {
                        bufferB.push(gl.createBuffer());

                        let vertArray = new Float32Array(currentBorders[i]);
                        gl.fsize = vertArray.BYTES_PER_ELEMENT;
                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[i]);
                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);

                        bufferB[i].itemSize = 2;
                        bufferB[i].numItems = vertArray.length / 2;
                    }
                }
            }
            this.insertFeature(featureId, properties, bufferT, bufferB, []);
        }

        else if (geometry.type === &quot;Point&quot; &amp;&amp; opts.isDynamic) {//dum
            const currentPoints = new Array(); //currentPoints[0] = new Array();
            let pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);
            currentPoints.push(pixel.x, pixel.y);

            const bufferPoints = [];//Buffer points
            let vertArray = new Float32Array(currentPoints);

            bufferPoints.push(gl.createBuffer());
            gl.fsize = vertArray.BYTES_PER_ELEMENT;
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferPoints[0]);
            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);

            bufferPoints[0].itemSize = 2;
            bufferPoints[0].numItems = vertArray.length / 2;

            this.insertFeature(featureId, properties, [], [], bufferPoints);
            this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties });
        }

        else if (geometry.type === &quot;Point&quot; &amp;&amp; !opts.isDynamic) {
            let pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);
            if (this.tempAestheticPoints.length === 0)
                for (let i = 0; i &lt; this.aesthetics.length; i++)
                    this.tempAestheticPoints[i] = [];

            const aesPositions = this.fitFeature(properties);
            for (const aesPos of aesPositions)
                this.tempAestheticPoints[aesPos].push(pixel.x, pixel.y);

            this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties });
        }
    }

    /**
     * M13) Deals with polygon triangulation.
     * @param {{geometry: JSON, properties: JSON}} polygon - The geometry and properties of the polygon.
     * @returns {{triangles: Array&lt;number&gt;, vertices: Array&lt;number&gt;}} - The triangles and vertices calculated by earcut triangulation. The vertices are the outside of the polygon, the triangles are the inside.
     * @see http://www.macwright.org/2015/03/23/geojson-second-bite.html#polygons
     * @memberOf Map
     */
    processPolygon(polygon) {
        let polyarray = [];
        if (polygon.geometry.type === &quot;Polygon&quot;) { //@TODO: [Demos never use this if statement.]
            let outsidepolygon = polygon.geometry.coordinates[0];
            let tempVerts = new Array();
            for (let out = 0; out &lt; outsidepolygon.length - 1; out++)
                tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);//_vertexcount += (outsidepolygon.length + 1) / 2;
            let triangles_vert = earcut(tempVerts); // _tricount += (triangles_vert.length / 3);
            polyarray.push({ triangles: triangles_vert, vertices: tempVerts });
        }
        else if (polygon.geometry.type === &quot;MultiPolygon&quot;) {
            let tempVerts = new Array(); //polygon.geometry.coordinates[0][0] -&gt;  [lat,long] , [lat,long], [lat,long] .... [lat,long]
            for (const coord of polygon.geometry.coordinates[0][0])
                tempVerts.push(coord[0], coord[1]);
            let triangles_vert = earcut(tempVerts);
            /* console.log(triangles_vert);
             console.log(tempVerts)*/
            polyarray.push({ triangles: triangles_vert, vertices: tempVerts });
        }
        return polyarray;
    }

    /**
     * M14) Converts geographic coordinates(latitude, longitude) to canvas coordinate pixels.
     * @param {number} longitude - The longitude.
     * @param {number} latitude - The latitude.
     * @returns {x: number, y: number} - canvas coordinate system pixels.
     * @see http://gisgeography.com/latitude-longitude-coordinates/
     * @see https://www.w3schools.com/graphics/canvas_coordinates.asp
     * @memberOf Map
     */
    latLongToPixelXY(longitude, latitude) {
        const pi_180 = Math.PI / 180.0;
        const pi_4 = Math.PI * 4;
        const sinLatitude = Math.sin(latitude * pi_180);
        const pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (pi_4)) * 256;
        const pixelX = ((longitude + 180) / 360) * 256;

        const pixel = { x: pixelX, y: pixelY };
        return pixel;
    }

    /**
     * M15) Inserts the Feature into one or more Aesthetic objects. If the Feature does not fit in any Aesthetic then does nothing.
     * @param {number} id - The Feature id. 
     * @param {JSON} properties - The Feature properties. 
     * @param {{itemSize: number, numItems: number}} triangles - Triangles, each in one WebGLBuffer.
     * @param {{itemSize: number, numItems: number}} borders - Borders, each in one WebGLBuffer.
     * @param {{itemSize: number, numItems: number}} points - Points, each in one WebGLBuffer.
     * @return {void}
     * @memberOf Map
     */
    insertFeature(id, properties, triangles, borders, points) {
        for (let i = 0; i &lt; this.aesthetics.length; i++)
            if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]))
                this.aesthetics[i].addFeature(id, properties, triangles, borders, points);
    }

    /**
     * M16) Returns an array of Aesthetic ids that tells us the objects where the Feature belongs.
     * @param {JSON} properties - The Feature properties
     * @returns {Array&lt;number&gt;} - The Aesthetic ids where the Feature belongs.
     * @memberOf Map
     */
    fitFeature(properties) {
        const res = [];
        for (let i = 0; i &lt; this.aesthetics.length; i++)
            if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]))
                res.push(i);
        return res;
    }

    /**
     * M?) Receives the dataset as parameter. This dataset in each row contains geometry and associated properties, then it creates one tree
     * either for points or polygons. This tree can be k-d Treee or RBush(RTree)
     * @param {JSON} geojson 
     * @return {void}
     * @see Diogo&apos;s thesis page 62
     * @memberOf Map
     */
    buildTrees(geojson) {
        const gl = this._webgl.gl;
        if (this.tempAestheticPoints.length &gt; 0) {
            for (let i = 0; i &lt; this.tempAestheticPoints.length; i++) {
                if (this.tempAestheticPoints[i].length &gt; 0) {
                    const vertArray = new Float32Array(this.tempAestheticPoints[i]);
                    const bufferP = [];
                    bufferP.push(gl.createBuffer());

                    gl.fsize = vertArray.BYTES_PER_ELEMENT;
                    gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);
                    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);
                    bufferP[0].itemSize = 2;
                    bufferP[0].numItems = vertArray.length / 2;
                    this.insertGroupedFeature(i, [], [], bufferP);
                }
            }
        }
        if (this.treepoints !== null)
            this.kdtree = new kdTree(this.treepoints, (a, b) =&gt; (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2, [&quot;lon&quot;, &quot;lat&quot;, &quot;properties&quot;]);
        if (this.hasPolygons)
            this.rtree = new PolygonLookup(geojson);
    }

    /**
     * Similar to insertFeature, in this case inserts a group of Features like it was only one.
     * It creates one WebGLBuffer with all the points instead of one WebGLBuffer per point.
     * This method should only be used when we already grouped the Features by Aesthetic class (fitFeature() method).
     * This method exists to provide one alternative less expensive in terms of memory for low end devices.
     * Used only on Dot Map because on those we can easily end up with millions of different Features.
     * @param {number} id - Aesthethics id. 
     * @param {{itemSize: number, numItems: number}} triangles - Not used ?
     * @param {{itemSize: number, numItems: number}} borders - Not used ?
     * @param {{itemSize: number, numItems: number}} points - All the points for the Aesthethic object in one WebGLBuffer.
     * @memberOf Map
     */
    insertGroupedFeature(id, triangles, borders, points) {
        this.aesthetics[id].addGroupedFeature(null, triangles, borders, points);
    }

    /** ########################    LEGEND METHODS    ######################## */
    /**
     * M17) Creates a Legend element suitable for polygons based on the Aesthethic objects.
     * Should be overriden by subclasses.
     * @return {void}
     * @abstract
     * @memberOf Map
     */
    buildLegend() {
        const mapCanvas = document.getElementById(`mapCanvas${this.id}`);
        const legendDiv = document.createElement(&apos;div&apos;);
        legendDiv.id = `legendDiv${this.id}`;
        legendDiv.style.position = &apos;absolute&apos;;
        legendDiv.style.backgroundColor = &apos;white&apos;;
        legendDiv.style.width = 250;
        legendDiv.style.bottom = 20;
        legendDiv.style.right = 0;
        legendDiv.style.borderColor = &apos;black&apos;;
        legendDiv.style.border = &apos;solid&apos;;

        const table = document.createElement(&apos;table&apos;);
        const thvalue = document.createElement(&apos;th&apos;);
        const thcolor = document.createElement(&apos;th&apos;);
        table.style.zIndex = &quot;2000&quot;;
        thcolor.style.width = 100;
        table.appendChild(thcolor);
        table.appendChild(thvalue);

        for (const currentaes of this.aesthetics) {
            const row = document.createElement(&apos;tr&apos;);
            const value = document.createElement(&apos;td&apos;);
            const color = document.createElement(&apos;td&apos;);
            const ptext = document.createElement(&apos;p&apos;);
            let text;
            if (typeof currentaes.range[0] === &apos;number&apos;)
                text = document.createTextNode(`[${currentaes.range[0]}, ${currentaes.range[1]}[`);
            else
                text = document.createTextNode(currentaes.range[0]);
            ptext.appendChild(text);
            value.appendChild(ptext);

            const colorDiv = document.createElement(&apos;div&apos;);
            colorDiv.style.position = &apos;relative&apos;;
            const rgbc = `rgba(${currentaes.fillColor[0]},${currentaes.fillColor[1]},${currentaes.fillColor[2]},${currentaes.fillColor[3]})`;
            colorDiv.style[&apos;backgroundColor&apos;] = rgbc;
            colorDiv.style.height = 25;
            colorDiv.style.width = 80;
            color.appendChild(colorDiv);

            row.appendChild(color);
            row.appendChild(value);
            table.appendChild(row);
        }

        legendDiv.appendChild(table);
        this.bGMap.getContainer().appendChild(legendDiv);
    }

    /** ########################    WEBGL METHODS    ######################## */
    /**
     * M20) Clear current buffers to preset values.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/clear
     * @memberOf Map
     */
    clear() {
        const gl = this._webgl.gl;
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.disable(gl.DEPTH_TEST);
    }

    /**
     * M21) Receiving an Aesthetics object, draws the triangles contained in it&apos;s Features,
     * using the color that the Aesthethics object has.
     * @param {Aesthetic} aes - The Aesthetic object.
     * @returns {void}
     * @see Diogo&apos;s thesis Page 58/59
     * @memberOf Map
     */
    drawTriangles(aes) {
        const gl = this._webgl.gl;
        if (gl === null)
            return;

        const matrixProjection = new Float32Array(16);
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        const currentZoom = this.bGMap.getZoom();
        const pointSize = Math.max(currentZoom - 5.0, 1.0);
        const scale = 2 ** currentZoom;
        const offset = this.latLongToPixelXY(this.bGMap.getLngBound(), this.bGMap.getLatBound());
        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);
        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);
        let [r, g, b, a] = aes.getFillColor();

        matrixProjection.set(this._webgl.projection);
        this.scaleProjection(matrixProjection, scale, scale);
        this.translateProjection(matrixProjection, -offset.x, -offset.y);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);
        gl.uniform1f(isPointLocation, 0.0);
        gl.uniform4f(vertexColorLocation, r / 255, g / 255, b / 255, a);// Draw Polygons&apos; Interior

        let features = aes.getFeatures();
        for (const f of features) { // Draw Polygons&apos; Interior
            let triangles = f.getTriangles();
            for (const t of triangles) {
                gl.bindBuffer(gl.ARRAY_BUFFER, t);
                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                gl.drawArrays(gl.TRIANGLES, 0, t.numItems);
            }
        }
    }

    /**
     * M22) Scale matrix with the given x(scaleX) and y(scaleY) values.
     * Scaling x and y, which is just scaling first two rows of matrix
     * @param {Float32Array} matrix 
     * @param {number} scaleX - Scale in X axis.
     * @param {number} scaleY - Scale in Y axis.
     * @see http://www.c-jump.com/bcc/common/Talk3/Math/Matrices/const_images/applying_scaling.png
     * @see http://ptgmedia.pearsoncmg.com/images/chap3_9780321902924/elementLinks/03fig27.jpg Remember WebGL is Column major
     * @see http://prntscr.com/eononb
     * @memberOf Map
     */
    scaleProjection(matrix, scaleX, scaleY) {
        for (let i = 0; i &lt; 8; i++)
            i &lt; 4 ? (matrix[i] *= scaleX) : (matrix[i] *= scaleY);
    }

    /**
     * M23) The translation is performed in the last row of the matrix. 
     * @param {Float32Array} matrix - The matrix to hold the result.
     * @param {number} tx - Translation in X axis.  
     * @param {number} ty - Translation in Y axis.
     * @see http://polymathprogrammer.com/images/blog/200809/translationmatrix.png
     * @see http://prntscr.com/eononb
     * @memberOf Map
     */
    translateProjection(matrix, tx, ty) {
        for (let i = 0; i &lt; 4; i++)
            matrix[i + 12] += (matrix[i] * tx) + (matrix[i + 4] * ty);
    }

    /**
     * M24) Receiving an Aesthetics object, draws the borders contained in it&apos;s Features, 
     * aplying the color specified in the Aeshteic object for the line color(Aeshteic.strokeColor).
     * @param {Aesthetic} aes - The Aesthetic object.
     * @returns {void}
     * @memberOf Map
     */
    drawBorders(aes) {
        const gl = this._webgl.gl;
        if (gl === null)
            return;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        const matrixProjection = new Float32Array(16);
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        const currentZoom = this.bGMap.getZoom();
        const pointSize = Math.max(currentZoom - 5.0, 1.0);
        const scale = 2 ** currentZoom;
        const offset = this.latLongToPixelXY(this.bGMap.getLngBound(), this.bGMap.getLatBound());
        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);
        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);
        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        let [r, g, b, a] = aes.getStrokeColor();

        matrixProjection.set(this._webgl.projection);
        this.scaleProjection(matrixProjection, scale, scale);
        this.translateProjection(matrixProjection, -offset.x, -offset.y);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);
        gl.uniform1f(isPointLocation, 0.0);
        gl.uniform4f(vertexColorLocation, r / 255, g / 255, b / 255, a);

        let features = aes.getFeatures();
        for (const f of features) {
            let borders = f.getBorders();
            for (const b of borders) {
                gl.bindBuffer(gl.ARRAY_BUFFER, b);
                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                gl.drawArrays(gl.LINE_LOOP, 0, b.numItems);
            }
        }
    }

    /**
     * M?) Receiving an Aesthetics object, draws the borders contained in it&apos;s Features, 
     * aplying the filling color calculated using the attribute and the color scheme.
     * @param {Aesthetic} aes - The Aesthetic object.
     * @returns {void}
     * @memberOf Map
     */
    drawContinuousPolygons(aes) {
        const gl = this._webgl.gl;
        if (gl === null)
            return;

        const matrixProjection = new Float32Array(16);
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        const currentZoom = this.bGMap.getZoom();
        const pointSize = Math.max(currentZoom - 5.0, 1.0);
        const scale = 2 ** currentZoom;
        const offset = this.latLongToPixelXY(this.bGMap.getLngBound(), this.bGMap.getLatBound());
        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);
        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);

        matrixProjection.set(this._webgl.projection);
        this.scaleProjection(matrixProjection, scale, scale);
        this.translateProjection(matrixProjection, -offset.x, -offset.y);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);
        gl.uniform1f(isPointLocation, 0.0);

        let features = aes.getFeatures();
        for (const f of features) {
            let color;
            const diff = f.getProperties()[this.gisplayOptions.attr];
            if (diff === 0)
                color = aes.fillColor(0.5).rgb();
            else {
                if (diff &gt; 0)
                    color = aes.fillColor(0.5 + diff / this.max / 2).rgb();
                else
                    color = aes.fillColor(0.5 - diff / this.min / 2).rgb();
            }
            let [r, g, b, a] = [Math.round(color[0]) / 255, Math.round(color[1]) / 255, Math.round(color[2]) / 255, this.gisplayOptions.alpha];
            gl.uniform4f(vertexColorLocation, r, g, b, a);

            let triangles = f.getTriangles();
            for (const t of triangles) {
                gl.bindBuffer(gl.ARRAY_BUFFER, t);
                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);//gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);
                gl.drawArrays(gl.TRIANGLES, 0, t.numItems);
            }
        }
    }

    /**
     * M?) Receiving an Aesthetics object, draws the points contained in it&apos;s Features, 
     * aplying the values specified in that Aesthetic object visual variables (color and size).
     * @param {Aesthetic} aes - The Aesthetic object.
     * @returns {void}
     * @memberOf Map
     */
    drawPoints(aes) {
        const gl = this._webgl.gl;
        if (gl === null)
            return;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        const matrixProjection = new Float32Array(16);
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        const currentZoom = this.bGMap.getZoom();
        const scale = 2 ** currentZoom;
        const pointSize = Math.max(currentZoom - 4.0 + aes.getPointSize(), aes.getPointSize());
        const offset = this.latLongToPixelXY(this.bGMap.getLngBound(), this.bGMap.getLatBound());
        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);
        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);
        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        let [r, g, b, a] = aes.getFillColor();

        matrixProjection.set(this._webgl.projection);
        this.scaleProjection(matrixProjection, scale, scale);
        this.translateProjection(matrixProjection, -offset.x, -offset.y);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);
        gl.uniform1f(isPointLocation, 1.0);
        gl.uniform4f(vertexColorLocation, r / 255, g / 255, b / 255, a);

        let features = aes.getFeatures();
        let allFeatures = aes.getAllFeatures();
        if (this.gisplayOptions.isDynamic &amp;&amp; aes.getFeatures().length &gt; 0) {
            for (const f of features) {
                let points = f.getPoints();
                for (const p of points) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, p);
                    gl.enableVertexAttribArray(vertexCoordLocation);
                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                    gl.drawArrays(gl.POINTS, 0, p.numItems);
                }
            }
        }
        else if (allFeatures !== null &amp;&amp; !this.gisplayOptions.isDynamic) {
            for (const allF of allFeatures) {
                let points = allF.getPoints();
                for (const p of points) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, p);
                    gl.enableVertexAttribArray(vertexCoordLocation);
                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                    gl.drawArrays(gl.POINTS, 0, p.numItems);
                }
            }
        }
    }

    /**
     * M?) Receiving an Aesthetics object, draws the points contained in it&apos;s Features, 
     * aplying the color specified in the Aeshteic object for the line color(Aeshteic.strokeColor) 
     * and the size of the point is based on the attribute value and the specified limits.
     * @param {Aesthetic} aes - The Aesthetic object. 
     * @returns {void} 
     * @memberOf Map
     */
    drawProportionalPoints(aes) {
        const gl = this._webgl.gl;
        if (gl === null)
            return;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        const currentZoom = this.bGMap.getZoom();
        const scale = 2 ** currentZoom;
        const offset = this.latLongToPixelXY(this.bGMap.getLngBound(), this.bGMap.getLatBound());
        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);
        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);
        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        const matrixProjection = new Float32Array(16);

        matrixProjection.set(this._webgl.projection);
        this.scaleProjection(matrixProjection, scale, scale);
        this.translateProjection(matrixProjection, -offset.x, -offset.y);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);
        gl.uniform1f(isPointLocation, 1.0);

        let [r, g, b, a] = aes.getFillColor();
        gl.uniform4f(vertexColorLocation, r / 255, g / 255, b / 255, this.gisplayOptions.alpha); //TODO: Para 2.5D usar alpha a 0?

        const fsize = Float32Array.BYTES_PER_ELEMENT;
        let opts = this.gisplayOptions;
        if (this.gisplayOptions.isDynamic) {
            let features = aes.getFeatures();
            for (const f of features) {
                let points = f.getPoints();
                for (let p of points) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, p);
                    const propvalue = parseFloat(f.getProperties()[opts.attr]);
                    const temppointsize = ((opts.maxPointSize - opts.minPointSize) / (this.max - this.min)) * (propvalue - this.min);
                    const pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);
                    const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
                    gl.vertexAttrib1f(vertexSizeLocation, pointSize);
                    gl.enableVertexAttribArray(vertexCoordLocation);
                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                    gl.drawArrays(gl.POINTS, 0, p.numItems);
                }
            }
        }
    }

    /** ########################    ABSTRACT METHODS    ######################## */
    /**
     * M19) Draw map function. Must be overriden by subclasses.
     * @abstract 
     */
    draw() {
        throw new Error(&quot;Draw must be implemented by subclass.&quot;);
    }

    /**
     * Defaults for each map. Subclasses should override this method.
     * @param {any} defaultId 
     * @abstract 
     * @memberOf Map
     */
    defaults(defaultId) {
        throw new Error(&quot;This map has no defaults defined.&quot;);
    }

    /**
     * This function should be implemented by any subclass that wants to use another way of processing data.
     * By default it loads GeoJSON but if the user wants to load another type of data it should do so by implementing this method.
     * A function similar to loadGeoJSON should also be implemented
     * @param {Object|JSON} data - Dataset to be used. 
     * TODO: Add static to this method.
     * @abstract
     */
    processData(data) {
        this.loadGeoJSON(geojson);
    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
