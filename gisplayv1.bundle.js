var GisplayLibrary =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./src/Gisplay/Maps/Types/Choropleth.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Choropleth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ../Map */ 2);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03 - 23/03\r\n */\nvar Choropleth = exports.Choropleth = function (_Map) {\n    _inherits(Choropleth, _Map);\n\n    /**\r\n     * Creates an instance of Choropleth.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} userOptions - User options to be used.\r\n     * @memberOf Choropleth\r\n     */\n    function Choropleth(bgmap, geometry, userOptions) {\n        _classCallCheck(this, Choropleth);\n\n        var _this = _possibleConstructorReturn(this, (Choropleth.__proto__ || Object.getPrototypeOf(Choropleth)).call(this, bgmap, geometry, userOptions));\n\n        _this.loadOptions(userOptions, bgmap); // this.type = 'CP'; window.maps.push(this);\n        _this.initializeCanvasAndEvents();\n        return _this;\n    }\n\n    /**\r\n     * Draw Choropleth map, at the beginning and when the map is moved.\r\n     * @see initialize() and makeMap() methods.\r\n     * @override  \r\n     * @memberOf Choropleth\r\n     */\n\n\n    _createClass(Choropleth, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var aes = _step.value;\n\n                    if (aes.isEnabled()) this.drawTriangles(aes);\n                    this.drawBorders(aes);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Method called to build the Map Legend.\r\n         * For all Aesthethics that exist crate one polygon row and then insert the Legend to the map. \r\n         * @override \r\n         * @memberOf Choropleth\r\n         */\n\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            /**\r\n             * The Legend to be used through the life of the map.\r\n             * @type {Legend} \r\n             */\n            this.legend = new _Legend.Legend(this.id, this.gisplayOptions.legendTitle);\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.aesthetics[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var aes = _step2.value;\n\n                    this.legend.insertPolygonRow(aes, this);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.legend.insertLegend(this.bGMap);\n        }\n\n        /**\r\n         * Returns the color scheme and number of classes associated with the id given.\r\n         * @param {number} defaultColorSchemeId - The id of the default color scheme to choose the colors.\r\n         * @returns {{colorScheme: string[], numberOfClasses: number}} - Color scheme and number of classes associated with the id given, empty object otherwise.\r\n         * @override \r\n         * @memberOf Choropleth\r\n         */\n\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultColorSchemeId) {\n            var options = {};\n            switch (defaultColorSchemeId) {\n                case 1:\n                    options.colorScheme = ['white', 'yellow', 'orange', 'red'];\n                    options.numberOfClasses = 4;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Choropleth;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL1R5cGVzL0Nob3JvcGxldGguanM/NDBiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXAgfSBmcm9tICcuLi9NYXAnO1xyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQnO1xyXG5cclxuLyoqXHJcbiAqIENob3JvcGxldGggaW1wbGVtZW50YXRpb24gMDYvMDMgLSAyMy8wM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENob3JvcGxldGggZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDaG9yb3BsZXRoLlxyXG4gICAgICogQHBhcmFtIHtCR01hcFdyYXBwZXJ9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIEpTT04gb2JqZWN0IHdpdGggdGhlIGdlb21ldHJ5IHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9ucyAtIFVzZXIgb3B0aW9ucyB0byBiZSB1c2VkLlxyXG4gICAgICogQG1lbWJlck9mIENob3JvcGxldGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYmdtYXAsIGdlb21ldHJ5LCB1c2VyT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgdXNlck9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnModXNlck9wdGlvbnMsIGJnbWFwKTsvLyB0aGlzLnR5cGUgPSAnQ1AnOyB3aW5kb3cubWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNhbnZhc0FuZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBDaG9yb3BsZXRoIG1hcCwgYXQgdGhlIGJlZ2lubmluZyBhbmQgd2hlbiB0aGUgbWFwIGlzIG1vdmVkLlxyXG4gICAgICogQHNlZSBpbml0aWFsaXplKCkgYW5kIG1ha2VNYXAoKSBtZXRob2RzLlxyXG4gICAgICogQG92ZXJyaWRlICBcclxuICAgICAqIEBtZW1iZXJPZiBDaG9yb3BsZXRoXHJcbiAgICAgKi9cclxuICAgIGRyYXcoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYWVzIG9mIHRoaXMuYWVzdGhldGljcykge1xyXG4gICAgICAgICAgICBpZiAoYWVzLmlzRW5hYmxlZCgpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3VHJpYW5nbGVzKGFlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0JvcmRlcnMoYWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRob2QgY2FsbGVkIHRvIGJ1aWxkIHRoZSBNYXAgTGVnZW5kLlxyXG4gICAgICogRm9yIGFsbCBBZXN0aGV0aGljcyB0aGF0IGV4aXN0IGNyYXRlIG9uZSBwb2x5Z29uIHJvdyBhbmQgdGhlbiBpbnNlcnQgdGhlIExlZ2VuZCB0byB0aGUgbWFwLiBcclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBDaG9yb3BsZXRoXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBMZWdlbmQgdG8gYmUgdXNlZCB0aHJvdWdoIHRoZSBsaWZlIG9mIHRoZSBtYXAuXHJcbiAgICAgICAgICogQHR5cGUge0xlZ2VuZH0gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZWdlbmQgPSBuZXcgTGVnZW5kKHRoaXMuaWQsIHRoaXMuZ2lzcGxheU9wdGlvbnMubGVnZW5kVGl0bGUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYWVzIG9mIHRoaXMuYWVzdGhldGljcylcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UG9seWdvblJvdyhhZXMsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLmJHTWFwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbG9yIHNjaGVtZSBhbmQgbnVtYmVyIG9mIGNsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBpZCBnaXZlbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0Q29sb3JTY2hlbWVJZCAtIFRoZSBpZCBvZiB0aGUgZGVmYXVsdCBjb2xvciBzY2hlbWUgdG8gY2hvb3NlIHRoZSBjb2xvcnMuXHJcbiAgICAgKiBAcmV0dXJucyB7e2NvbG9yU2NoZW1lOiBzdHJpbmdbXSwgbnVtYmVyT2ZDbGFzc2VzOiBudW1iZXJ9fSAtIENvbG9yIHNjaGVtZSBhbmQgbnVtYmVyIG9mIGNsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBpZCBnaXZlbiwgZW1wdHkgb2JqZWN0IG90aGVyd2lzZS5cclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBDaG9yb3BsZXRoXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzKGRlZmF1bHRDb2xvclNjaGVtZUlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdENvbG9yU2NoZW1lSWQpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2xvclNjaGVtZSA9IFsnd2hpdGUnLCAneWVsbG93JywgJ29yYW5nZScsICdyZWQnXTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubnVtYmVyT2ZDbGFzc2VzID0gNDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvVHlwZXMvQ2hvcm9wbGV0aC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTs7OztBQUlBO0FBTEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/Gisplay/Maps/Legend.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class represents the Map Legend. 15/03\r\n * @see Diogo's thesis page 66/67 + 58/59 + 69(Figures)\r\n */\nvar Legend = exports.Legend = function () {\n    /**\r\n     * Creates an instance of Legend class.\r\n     * @param {number} id -  The id of the legend.\r\n     * @param {string} title - The title for the legend.\r\n     * \r\n     * @memberOf Legend\r\n     */\n    function Legend(id, title) {\n        _classCallCheck(this, Legend);\n\n        /**\r\n         * Title of the Gisplay map Legend.\r\n         * @type {string}\r\n         */\n        this.title = title;\n        /**\r\n         * The div that contains the Legend.\r\n         * @type {HTMLDivElement}\r\n         */\n        this.legendDiv = null;\n        /**\r\n         * The table element where the legend elements will be apppended.\r\n         * @type {HTMLTableElement}\r\n         */\n        this.table = null;\n        /**\r\n         * Class name for the Legend? Not used?\r\n         * @type {string}\r\n         */\n        this.className = null;\n        /**\r\n         * The last div to insert in the legend. Only for PSymbol Maps.\r\n         * @type {HTMLDivElement}\r\n         */\n        this.lastdiv = undefined;\n        /**\r\n         * If it is the first insertion or not. Only for PSymbol Maps.\r\n         * @type {boolean}\r\n         */\n        this.firstInsertion = false;\n        /**\r\n         * Constant to use when it's a Polygon.\r\n         * @constant {number} POLYGON\r\n         */\n        this.POLYGON = 1;\n        /**\r\n        * Constant to use when it's a Point.\r\n        * @constant {number} POLYGON\r\n        */\n        this.POINT = 2;\n\n        this.init(id, null);\n    }\n\n    /**\r\n     * Initialise Legend. Creates a table element and appends title, color element and value element.\r\n     * @param {number} id - The id of this Legend.\r\n     * @param {string} classname - The class name to be usde by the Legend.\r\n     * @memberOf Legend\r\n     */\n\n\n    _createClass(Legend, [{\n        key: 'init',\n        value: function init(id, classname) {\n            //const mapCanvas = document.getElementById(`mapCanvas${id}`); //@TODO: Remove\n            this.legendDiv = document.createElement('div');\n            if (classname != undefined && classname != null) this.legendDiv.className = classname;else this.legendDiv.className = '_gisplaylegendBR';\n\n            this.legendDiv.id = 'legendDiv' + id;\n\n            this.table = document.createElement('table');\n            this.table.style.zIndex = \"2000\";\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            thcolor.style.align = \"center\";\n\n            this.table.appendChild(thcolor);\n            this.table.appendChild(thvalue);\n\n            var titlerow = document.createElement('tr');\n            var titletd = document.createElement('td');\n            titletd.colSpan = 2;\n            titletd.style.textAlign = 'center';\n            titletd.style.width = 100;\n            var titletext = document.createTextNode(this.title);\n            titletd.appendChild(titletext);\n            titlerow.appendChild(titletd);\n            this.table.appendChild(titlerow);\n        }\n\n        /**\r\n         * Inserts one row for the Aesthetic object.\r\n         * Used in Dot Maps.\r\n         * @param {Aesthetic} currentaes - The Aesthetic object \r\n         * @param {Map} mapobj - The Map object where the point row will be added. \r\n         * @see Diogo's thesis Page 69 5.1c\r\n         * @memberOf Legend\r\n         */\n\n    }, {\n        key: 'insertPointRow',\n        value: function insertPointRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, this.POINT);\n        }\n\n        /**\r\n         * Inserts one polygon row into the Legend. Used for area based Maps (Choropleth and Chorocromatic).\r\n         * @param {Aesthetic} currentaes  - The Aesthetic object \r\n         * @param {Map} mapobj - The map where to insert a polygon row.\r\n         * @see Diogo's thesis Page 69 5.1b\r\n         * @memberOf Legend\r\n         */\n\n    }, {\n        key: 'insertPolygonRow',\n        value: function insertPolygonRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, this.POLYGON);\n        }\n\n        /**\r\n         * Adds one row to the Legend and attaches an on click event to said row.\r\n         * @param {Aesthetic} currentaes  - The Aesthetic object.\r\n         * @param {Map} mapobj - The map where to insert a polygon row.\r\n         * @param {number} type - The type of row to insert. 1=Polygon, 2=Point. @TODO: Should be constant\r\n         * @memberOf Legend\r\n         */\n\n    }, {\n        key: 'insertRow',\n        value: function insertRow(currentaes, mapobj, type) {\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var color = document.createElement('td');\n            var text = void 0;\n            if (typeof currentaes.range[0] === 'number') {\n                var mininput = currentaes.range[0] != null ? currentaes.range[0] : mapobj.min;\n                var maxinput = currentaes.range[1] != null ? currentaes.range[1] : mapobj.max;\n                if (!currentaes.isOuter()) text = document.createTextNode('[' + mininput + ', ' + maxinput + '[');else text = document.createTextNode('[' + mininput + ', ' + maxinput + ']');\n            } else text = document.createTextNode(currentaes.range[0]);\n\n            value.appendChild(text);\n            var colorDiv = document.createElement('div');\n            colorDiv.style.position = 'relative';\n\n            var _currentaes$getFillCo = currentaes.getFillColor(),\n                _currentaes$getFillCo2 = _slicedToArray(_currentaes$getFillCo, 4),\n                r = _currentaes$getFillCo2[0],\n                g = _currentaes$getFillCo2[1],\n                b = _currentaes$getFillCo2[2],\n                a = _currentaes$getFillCo2[3];\n\n            var rgba = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n            colorDiv.style['backgroundColor'] = rgba;\n            if (type === this.POLYGON) {\n                //polygon\n                colorDiv.style.height = 25;\n                colorDiv.style.width = 80;\n                if (currentaes.getStrokeColor() != null) {\n                    //&& currentaes != undefined\n                    var _currentaes$getStroke = currentaes.getStrokeColor(),\n                        _currentaes$getStroke2 = _slicedToArray(_currentaes$getStroke, 4),\n                        _r = _currentaes$getStroke2[0],\n                        _g = _currentaes$getStroke2[1],\n                        _b = _currentaes$getStroke2[2],\n                        _a = _currentaes$getStroke2[3];\n\n                    colorDiv.style['borderColor'] = 'rgba(' + _r + ',' + _g + ',' + _b + ',' + _a + ')';\n                }\n                colorDiv.className = '_gisplayrectangle';\n            } else if (type === this.POINT) {\n                //point\n                var size = void 0;\n                if (currentaes.getPointSize() != null) size = Math.max(currentaes.getPointSize(), 5);else size = 25;\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.className = '_gisplaycircle';\n            }\n\n            color.appendChild(colorDiv);\n            row.appendChild(color);\n            row.appendChild(value);\n\n            row.onclick = function () {\n                if (mapobj.gisplayOptions.legendToggle) {\n                    var toFade = !currentaes.enableDisable();\n                    if (toFade) this.className += \" _gisplayfade\";else this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                }\n                if (mapobj.gisplayOptions.legendOnClickFunction != null && mapobj.gisplayOptions.legendOnClickFunction != undefined) mapobj.gisplayOptions.legendOnClickFunction(currentaes);\n                mapobj.draw();\n            };\n            this.table.appendChild(row);\n        }\n\n        /**\r\n         * Inserts in the Legend one gradient according to the Aesthetic object.\r\n         * Use in Change Maps. \r\n         * @param {Map} mapobj - The map where to insert the gradient row.\r\n         * @param {number} left - Left value of the Legend (minimum change).\r\n         * @param {number} middle - Value at the center of the change(aka break point).\r\n         * @param {number} right - Right value of the legend (maximum value).\r\n         * @see Diogo's thesis page 69 Figure 5.1d\r\n         * @memberOf Legend\r\n         */\n\n    }, {\n        key: 'insertGradient',\n        value: function insertGradient(mapobj, left, middle, right) {\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var valueDiv = document.createElement('div');\n            value.colSpan = 2;\n            value.style.textAlign = 'center';\n            var numberofAesthetics = 5;\n            if (mapobj.aesthetics.length > 5) numberofAesthetics = mapobj.aesthetics.length;\n\n            var strcolor = '';\n            for (var i = 0; i < numberofAesthetics; i++) {\n                var _mapobj$fcolor$rgb = mapobj.fcolor(i / numberofAesthetics).rgb(),\n                    _mapobj$fcolor$rgb2 = _slicedToArray(_mapobj$fcolor$rgb, 3),\n                    r = _mapobj$fcolor$rgb2[0],\n                    g = _mapobj$fcolor$rgb2[1],\n                    b = _mapobj$fcolor$rgb2[2];\n\n                var _ref = [Math.round(r), Math.round(g), Math.round(b)],\n                    roundR = _ref[0],\n                    roundG = _ref[1],\n                    roundB = _ref[2];\n\n                strcolor += ',rgba(' + roundR + ',' + roundG + ',' + roundB + ',' + mapobj.gisplayOptions.alpha + ')';\n            }\n            valueDiv.style.background = '-webkit-linear-gradient(left' + strcolor + ')';\n\n            valueDiv.style.height = 25;\n            valueDiv.style.width = 130;\n\n            var row2 = document.createElement('tr');\n            var value2 = document.createElement('td');\n            var divleft = document.createElement('div');\n\n            value2.colSpan = 2;\n            divleft.style.textAlign = 'left';\n            divleft.style.width = '33%';\n            divleft.style.display = \"inline-block\";\n            var lefttext = document.createTextNode(left);\n            var divmid = document.createElement('div');\n            divmid.style.textAlign = 'center';\n            divmid.style.width = '33%';\n            divmid.style.display = \"inline-block\";\n            var text = document.createTextNode(middle);\n            var divright = document.createElement('div');\n            divright.style.textAlign = 'right';\n            divright.style.width = '33%';\n            divright.style.display = \"inline-block\";\n            var righttext = document.createTextNode(right);\n\n            divleft.appendChild(lefttext);\n            divmid.appendChild(text);\n            divright.appendChild(righttext);\n            value2.appendChild(divleft);\n            value2.appendChild(divmid);\n            value2.appendChild(divright);\n            value.appendChild(valueDiv);\n            row2.appendChild(value2);\n            row.appendChild(value);\n            this.table.appendChild(row);\n            this.table.appendChild(row2);\n        }\n\n        /**\r\n         * Inserts one Proportional symbols legend element.\r\n         * Used by PSymbols Maps.\r\n         * @param {Aesthetic} currentaes  - The Aesthetic object.\r\n         * @param {Map} mapobj - The map where to insert the proportion symbols element.\r\n         * @param {number} numLegendItems - Number of items to be created.\r\n         * @see Diogo's thesis Page 69 5.1a\r\n         * @memberOf Legend\r\n         */\n\n    }, {\n        key: 'insertProportionalSymbols',\n        value: function insertProportionalSymbols(currentaes, mapobj, numLegendItems) {\n            if (this.lastdiv === undefined) {\n                //First insertion\n                var row = document.createElement('tr');\n                var value = document.createElement('td');\n                value.colSpan = 2;\n                value.style.textAlign = 'center';\n                this.firstInsertion = true;\n            } else this.firstInsertion = false;\n\n            var strokecolor = void 0;\n\n            var _currentaes$getStroke3 = currentaes.getStrokeColor(),\n                _currentaes$getStroke4 = _slicedToArray(_currentaes$getStroke3, 4),\n                sr = _currentaes$getStroke4[0],\n                sg = _currentaes$getStroke4[1],\n                sb = _currentaes$getStroke4[2],\n                sa = _currentaes$getStroke4[3]; //console.log(\"PropSymbols Insert >>>\", sr, sg, sb, sa);\n\n\n            var _currentaes$getFillCo3 = currentaes.getFillColor(),\n                _currentaes$getFillCo4 = _slicedToArray(_currentaes$getFillCo3, 4),\n                r = _currentaes$getFillCo4[0],\n                g = _currentaes$getFillCo4[1],\n                b = _currentaes$getFillCo4[2],\n                a = _currentaes$getFillCo4[3]; //console.log(\"PropSymbols Insert >>>\", r, g, b, a);\n\n\n            var rgba = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // const rgbc = `rgba(${currentaes.fillColor[0]},${currentaes.fillColor[1]},${currentaes.fillColor[2]},${1})`;\n\n            if (currentaes.getStrokeColor() != null && currentaes != undefined) //TODO: Remove && curr..\n                strokecolor = 'rgba(' + sr + ',' + sg + ',' + sb + ',' + sa + ')';else strokecolor = 'rgba(' + 0 + ',' + 0 + ',' + 0 + ',' + 1 + ')';\n\n            for (var i = numLegendItems - 1; i >= 0; i--) {\n                var current = document.createElement('div');\n                var propvalue = void 0;\n                if (!this.firstInsertion && i === numLegendItems - 1 || numLegendItems === 1) propvalue = currentaes.range[1];else propvalue = mapobj.min + i / (numLegendItems - 1) * (mapobj.max - mapobj.min);\n\n                var text = document.createTextNode(Math.round(propvalue)); //TODO: this.round(propValue) ?\n                current.appendChild(text);\n                var colorDiv = document.createElement('div');\n                colorDiv.style.position = 'relative';\n                colorDiv.style.backgroundColor = rgba;\n                colorDiv.className = '_gisplayproportionalcircle';\n                colorDiv.style.borderColor = strokecolor;\n                var temppointsize = (mapobj.gisplayOptions.maxPointSize - mapobj.gisplayOptions.minPointSize) / (mapobj.max - mapobj.min) * (propvalue - mapobj.min);\n                var size = Math.max(temppointsize, 7.5);\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.style.inherit = false;\n\n                colorDiv.onclick = function (e) {\n                    if (mapobj.gisplayOptions.legendToggle) {\n                        var toFade = !currentaes.enableDisable();\n                        if (toFade) this.className += \" _gisplayfade\";else this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                    }\n                    if (mapobj.gisplayOptions.legendOnClickFunction != null && mapobj.gisplayOptions.legendOnClickFunction != undefined) mapobj.gisplayOptions.legendOnClickFunction(currentaes);\n                    mapobj.draw();\n\n                    /*if (!e)\r\n                        var e = window.event; //TODO: Remove??*/\n                    e.cancelBubble = true;\n                    if (e.stopPropagation) e.stopPropagation();\n                };\n\n                current.appendChild(colorDiv);\n                if (this.lastdiv != undefined) {\n                    this.lastdiv.appendChild(current);\n                    this.lastdiv = colorDiv;\n                } else {\n                    //1st insertion\n                    value.appendChild(current);\n                    this.lastdiv = colorDiv;\n                }\n            }\n\n            if (this.firstInsertion) {\n                //1st insertion\n                row.appendChild(value);\n                this.table.appendChild(row);\n            }\n        }\n\n        /**\r\n         * Appends the legend div element to the map container. Used by all Maps.\r\n         * @param {BGMapWrapper} bgMap - The background map where the legend will be appended to. \r\n         */\n\n    }, {\n        key: 'insertLegend',\n        value: function insertLegend(bgMap) {\n            this.legendDiv.appendChild(this.table);\n            bgMap.getContainer().appendChild(this.legendDiv);\n        }\n    }]);\n\n    return Legend;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0xlZ2VuZC5qcz9kZGVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIE1hcCBMZWdlbmQuIDE1LzAzXHJcbiAqIEBzZWUgRGlvZ28ncyB0aGVzaXMgcGFnZSA2Ni82NyArIDU4LzU5ICsgNjkoRmlndXJlcylcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMZWdlbmQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIExlZ2VuZCBjbGFzcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtICBUaGUgaWQgb2YgdGhlIGxlZ2VuZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFRoZSB0aXRsZSBmb3IgdGhlIGxlZ2VuZC5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIExlZ2VuZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgdGl0bGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaXRsZSBvZiB0aGUgR2lzcGxheSBtYXAgTGVnZW5kLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkaXYgdGhhdCBjb250YWlucyB0aGUgTGVnZW5kLlxyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxlZ2VuZERpdiA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhYmxlIGVsZW1lbnQgd2hlcmUgdGhlIGxlZ2VuZCBlbGVtZW50cyB3aWxsIGJlIGFwcHBlbmRlZC5cclxuICAgICAgICAgKiBAdHlwZSB7SFRNTFRhYmxlRWxlbWVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRhYmxlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGFzcyBuYW1lIGZvciB0aGUgTGVnZW5kPyBOb3QgdXNlZD9cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCBkaXYgdG8gaW5zZXJ0IGluIHRoZSBsZWdlbmQuIE9ubHkgZm9yIFBTeW1ib2wgTWFwcy5cclxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0ZGl2ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGl0IGlzIHRoZSBmaXJzdCBpbnNlcnRpb24gb3Igbm90LiBPbmx5IGZvciBQU3ltYm9sIE1hcHMuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maXJzdEluc2VydGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0YW50IHRvIHVzZSB3aGVuIGl0J3MgYSBQb2x5Z29uLlxyXG4gICAgICAgICAqIEBjb25zdGFudCB7bnVtYmVyfSBQT0xZR09OXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5QT0xZR09OID0gMTtcclxuICAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RhbnQgdG8gdXNlIHdoZW4gaXQncyBhIFBvaW50LlxyXG4gICAgICAgICAqIEBjb25zdGFudCB7bnVtYmVyfSBQT0xZR09OXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5QT0lOVCA9IDI7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdChpZCwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlIExlZ2VuZC4gQ3JlYXRlcyBhIHRhYmxlIGVsZW1lbnQgYW5kIGFwcGVuZHMgdGl0bGUsIGNvbG9yIGVsZW1lbnQgYW5kIHZhbHVlIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgaWQgb2YgdGhpcyBMZWdlbmQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NuYW1lIC0gVGhlIGNsYXNzIG5hbWUgdG8gYmUgdXNkZSBieSB0aGUgTGVnZW5kLlxyXG4gICAgICogQG1lbWJlck9mIExlZ2VuZFxyXG4gICAgICovXHJcbiAgICBpbml0KGlkLCBjbGFzc25hbWUpIHtcclxuICAgICAgICAvL2NvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke2lkfWApOyAvL0BUT0RPOiBSZW1vdmVcclxuICAgICAgICB0aGlzLmxlZ2VuZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGlmIChjbGFzc25hbWUgIT0gdW5kZWZpbmVkICYmIGNsYXNzbmFtZSAhPSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZERpdi5jbGFzc05hbWUgPSBjbGFzc25hbWU7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZERpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlsZWdlbmRCUic7XHJcblxyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2LmlkID0gYGxlZ2VuZERpdiR7aWR9YDtcclxuXHJcbiAgICAgICAgdGhpcy50YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XHJcbiAgICAgICAgdGhpcy50YWJsZS5zdHlsZS56SW5kZXggPSBcIjIwMDBcIjtcclxuICAgICAgICBjb25zdCB0aHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICBjb25zdCB0aGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICB0aGNvbG9yLnN0eWxlLmFsaWduID0gXCJjZW50ZXJcIjtcclxuXHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aGNvbG9yKTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRodmFsdWUpO1xyXG5cclxuICAgICAgICBjb25zdCB0aXRsZXJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgY29uc3QgdGl0bGV0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgdGl0bGV0ZC5jb2xTcGFuID0gMjtcclxuICAgICAgICB0aXRsZXRkLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIHRpdGxldGQuc3R5bGUud2lkdGggPSAxMDA7XHJcbiAgICAgICAgY29uc3QgdGl0bGV0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50aXRsZSk7XHJcbiAgICAgICAgdGl0bGV0ZC5hcHBlbmRDaGlsZCh0aXRsZXRleHQpO1xyXG4gICAgICAgIHRpdGxlcm93LmFwcGVuZENoaWxkKHRpdGxldGQpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQodGl0bGVyb3cpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBvbmUgcm93IGZvciB0aGUgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAqIFVzZWQgaW4gRG90IE1hcHMuXHJcbiAgICAgKiBAcGFyYW0ge0Flc3RoZXRpY30gY3VycmVudGFlcyAtIFRoZSBBZXN0aGV0aWMgb2JqZWN0IFxyXG4gICAgICogQHBhcmFtIHtNYXB9IG1hcG9iaiAtIFRoZSBNYXAgb2JqZWN0IHdoZXJlIHRoZSBwb2ludCByb3cgd2lsbCBiZSBhZGRlZC4gXHJcbiAgICAgKiBAc2VlIERpb2dvJ3MgdGhlc2lzIFBhZ2UgNjkgNS4xY1xyXG4gICAgICogQG1lbWJlck9mIExlZ2VuZFxyXG4gICAgICovXHJcbiAgICBpbnNlcnRQb2ludFJvdyhjdXJyZW50YWVzLCBtYXBvYmopIHtcclxuICAgICAgICB0aGlzLmluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIHRoaXMuUE9JTlQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBvbmUgcG9seWdvbiByb3cgaW50byB0aGUgTGVnZW5kLiBVc2VkIGZvciBhcmVhIGJhc2VkIE1hcHMgKENob3JvcGxldGggYW5kIENob3JvY3JvbWF0aWMpLlxyXG4gICAgICogQHBhcmFtIHtBZXN0aGV0aWN9IGN1cnJlbnRhZXMgIC0gVGhlIEFlc3RoZXRpYyBvYmplY3QgXHJcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwb2JqIC0gVGhlIG1hcCB3aGVyZSB0byBpbnNlcnQgYSBwb2x5Z29uIHJvdy5cclxuICAgICAqIEBzZWUgRGlvZ28ncyB0aGVzaXMgUGFnZSA2OSA1LjFiXHJcbiAgICAgKiBAbWVtYmVyT2YgTGVnZW5kXHJcbiAgICAgKi9cclxuICAgIGluc2VydFBvbHlnb25Sb3coY3VycmVudGFlcywgbWFwb2JqKSB7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRSb3coY3VycmVudGFlcywgbWFwb2JqLCB0aGlzLlBPTFlHT04pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgcm93IHRvIHRoZSBMZWdlbmQgYW5kIGF0dGFjaGVzIGFuIG9uIGNsaWNrIGV2ZW50IHRvIHNhaWQgcm93LlxyXG4gICAgICogQHBhcmFtIHtBZXN0aGV0aWN9IGN1cnJlbnRhZXMgIC0gVGhlIEFlc3RoZXRpYyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwb2JqIC0gVGhlIG1hcCB3aGVyZSB0byBpbnNlcnQgYSBwb2x5Z29uIHJvdy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIC0gVGhlIHR5cGUgb2Ygcm93IHRvIGluc2VydC4gMT1Qb2x5Z29uLCAyPVBvaW50LiBAVE9ETzogU2hvdWxkIGJlIGNvbnN0YW50XHJcbiAgICAgKiBAbWVtYmVyT2YgTGVnZW5kXHJcbiAgICAgKi9cclxuICAgIGluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIHR5cGUpIHtcclxuICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBjb25zdCBjb2xvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgbGV0IHRleHQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50YWVzLnJhbmdlWzBdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjb25zdCBtaW5pbnB1dCA9IGN1cnJlbnRhZXMucmFuZ2VbMF0gIT0gbnVsbCA/IGN1cnJlbnRhZXMucmFuZ2VbMF0gOiBtYXBvYmoubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhpbnB1dCA9IGN1cnJlbnRhZXMucmFuZ2VbMV0gIT0gbnVsbCA/IGN1cnJlbnRhZXMucmFuZ2VbMV0gOiBtYXBvYmoubWF4O1xyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRhZXMuaXNPdXRlcigpKVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGBbJHttaW5pbnB1dH0sICR7bWF4aW5wdXR9W2ApO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFske21pbmlucHV0fSwgJHttYXhpbnB1dH1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGN1cnJlbnRhZXMucmFuZ2VbMF0pO1xyXG5cclxuICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbG9yRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHJcbiAgICAgICAgY29uc3QgW3IsIGcsIGIsIGFdID0gY3VycmVudGFlcy5nZXRGaWxsQ29sb3IoKTtcclxuICAgICAgICBjb25zdCByZ2JhID0gYHJnYmEoJHtyfSwke2d9LCR7Yn0sJHthfSlgO1xyXG4gICAgICAgIGNvbG9yRGl2LnN0eWxlWydiYWNrZ3JvdW5kQ29sb3InXSA9IHJnYmE7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHRoaXMuUE9MWUdPTikgey8vcG9seWdvblxyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSAyNTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSA4MDtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRhZXMuZ2V0U3Ryb2tlQ29sb3IoKSAhPSBudWxsKSB7Ly8mJiBjdXJyZW50YWVzICE9IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgW3IsIGcsIGIsIGFdID0gY3VycmVudGFlcy5nZXRTdHJva2VDb2xvcigpO1xyXG4gICAgICAgICAgICAgICAgY29sb3JEaXYuc3R5bGVbJ2JvcmRlckNvbG9yJ10gPSBgcmdiYSgke3J9LCR7Z30sJHtifSwke2F9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29sb3JEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5cmVjdGFuZ2xlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gdGhpcy5QT0lOVCkgey8vcG9pbnRcclxuICAgICAgICAgICAgbGV0IHNpemU7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50YWVzLmdldFBvaW50U2l6ZSgpICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgoY3VycmVudGFlcy5nZXRQb2ludFNpemUoKSwgNSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNpemUgPSAyNTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXljaXJjbGUnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29sb3IuYXBwZW5kQ2hpbGQoY29sb3JEaXYpO1xyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZChjb2xvcik7XHJcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlKTtcclxuXHJcbiAgICAgICAgcm93Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXBvYmouZ2lzcGxheU9wdGlvbnMubGVnZW5kVG9nZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ZhZGUgPSAhY3VycmVudGFlcy5lbmFibGVEaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9GYWRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lICs9IFwiIF9naXNwbGF5ZmFkZVwiO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUucmVwbGFjZSgvKD86XnxcXHMpX2dpc3BsYXlmYWRlKD8hXFxTKS9nLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hcG9iai5naXNwbGF5T3B0aW9ucy5sZWdlbmRPbkNsaWNrRnVuY3Rpb24gIT0gbnVsbCAmJiBtYXBvYmouZ2lzcGxheU9wdGlvbnMubGVnZW5kT25DbGlja0Z1bmN0aW9uICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIG1hcG9iai5naXNwbGF5T3B0aW9ucy5sZWdlbmRPbkNsaWNrRnVuY3Rpb24oY3VycmVudGFlcyk7XHJcbiAgICAgICAgICAgIG1hcG9iai5kcmF3KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGluIHRoZSBMZWdlbmQgb25lIGdyYWRpZW50IGFjY29yZGluZyB0byB0aGUgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAqIFVzZSBpbiBDaGFuZ2UgTWFwcy4gXHJcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwb2JqIC0gVGhlIG1hcCB3aGVyZSB0byBpbnNlcnQgdGhlIGdyYWRpZW50IHJvdy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IC0gTGVmdCB2YWx1ZSBvZiB0aGUgTGVnZW5kIChtaW5pbXVtIGNoYW5nZSkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWlkZGxlIC0gVmFsdWUgYXQgdGhlIGNlbnRlciBvZiB0aGUgY2hhbmdlKGFrYSBicmVhayBwb2ludCkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgLSBSaWdodCB2YWx1ZSBvZiB0aGUgbGVnZW5kIChtYXhpbXVtIHZhbHVlKS5cclxuICAgICAqIEBzZWUgRGlvZ28ncyB0aGVzaXMgcGFnZSA2OSBGaWd1cmUgNS4xZFxyXG4gICAgICogQG1lbWJlck9mIExlZ2VuZFxyXG4gICAgICovXHJcbiAgICBpbnNlcnRHcmFkaWVudChtYXBvYmosIGxlZnQsIG1pZGRsZSwgcmlnaHQpIHtcclxuICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBjb25zdCB2YWx1ZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHZhbHVlLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgIHZhbHVlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIGxldCBudW1iZXJvZkFlc3RoZXRpY3MgPSA1O1xyXG4gICAgICAgIGlmIChtYXBvYmouYWVzdGhldGljcy5sZW5ndGggPiA1KVxyXG4gICAgICAgICAgICBudW1iZXJvZkFlc3RoZXRpY3MgPSBtYXBvYmouYWVzdGhldGljcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGxldCBzdHJjb2xvciA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyb2ZBZXN0aGV0aWNzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IFtyLCBnLCBiXSA9IG1hcG9iai5mY29sb3IoaSAvIG51bWJlcm9mQWVzdGhldGljcykucmdiKCk7XHJcbiAgICAgICAgICAgIGxldCBbcm91bmRSLCByb3VuZEcsIHJvdW5kQl0gPSBbTWF0aC5yb3VuZChyKSwgTWF0aC5yb3VuZChnKSwgTWF0aC5yb3VuZChiKV07XHJcbiAgICAgICAgICAgIHN0cmNvbG9yICs9IGAscmdiYSgke3JvdW5kUn0sJHtyb3VuZEd9LCR7cm91bmRCfSwke21hcG9iai5naXNwbGF5T3B0aW9ucy5hbHBoYX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUuYmFja2dyb3VuZCA9IGAtd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0JHtzdHJjb2xvcn0pYDtcclxuXHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7XHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUud2lkdGggPSAxMzA7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgY29uc3QgZGl2bGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgICAgICB2YWx1ZTIuY29sU3BhbiA9IDI7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdmxlZnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgY29uc3QgbGVmdHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWZ0KTtcclxuICAgICAgICBjb25zdCBkaXZtaWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXZtaWQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLndpZHRoID0gJzMzJSc7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtaWRkbGUpO1xyXG4gICAgICAgIGNvbnN0IGRpdnJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2cmlnaHQuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICBkaXZyaWdodC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdnJpZ2h0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0dGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJpZ2h0KTtcclxuXHJcbiAgICAgICAgZGl2bGVmdC5hcHBlbmRDaGlsZChsZWZ0dGV4dCk7XHJcbiAgICAgICAgZGl2bWlkLmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgIGRpdnJpZ2h0LmFwcGVuZENoaWxkKHJpZ2h0dGV4dCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdmxlZnQpO1xyXG4gICAgICAgIHZhbHVlMi5hcHBlbmRDaGlsZChkaXZtaWQpO1xyXG4gICAgICAgIHZhbHVlMi5hcHBlbmRDaGlsZChkaXZyaWdodCk7XHJcbiAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQodmFsdWVEaXYpO1xyXG4gICAgICAgIHJvdzIuYXBwZW5kQ2hpbGQodmFsdWUyKTtcclxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQocm93KTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdzIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBvbmUgUHJvcG9ydGlvbmFsIHN5bWJvbHMgbGVnZW5kIGVsZW1lbnQuXHJcbiAgICAgKiBVc2VkIGJ5IFBTeW1ib2xzIE1hcHMuXHJcbiAgICAgKiBAcGFyYW0ge0Flc3RoZXRpY30gY3VycmVudGFlcyAgLSBUaGUgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBvYmogLSBUaGUgbWFwIHdoZXJlIHRvIGluc2VydCB0aGUgcHJvcG9ydGlvbiBzeW1ib2xzIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtTGVnZW5kSXRlbXMgLSBOdW1iZXIgb2YgaXRlbXMgdG8gYmUgY3JlYXRlZC5cclxuICAgICAqIEBzZWUgRGlvZ28ncyB0aGVzaXMgUGFnZSA2OSA1LjFhXHJcbiAgICAgKiBAbWVtYmVyT2YgTGVnZW5kXHJcbiAgICAgKi9cclxuICAgIGluc2VydFByb3BvcnRpb25hbFN5bWJvbHMoY3VycmVudGFlcywgbWFwb2JqLCBudW1MZWdlbmRJdGVtcykge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RkaXYgPT09IHVuZGVmaW5lZCkgey8vRmlyc3QgaW5zZXJ0aW9uXHJcbiAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICB2YWx1ZS5jb2xTcGFuID0gMjtcclxuICAgICAgICAgICAgdmFsdWUuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RJbnNlcnRpb24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RJbnNlcnRpb24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgbGV0IHN0cm9rZWNvbG9yO1xyXG4gICAgICAgIGxldCBbc3IsIHNnLCBzYiwgc2FdID0gY3VycmVudGFlcy5nZXRTdHJva2VDb2xvcigpOy8vY29uc29sZS5sb2coXCJQcm9wU3ltYm9scyBJbnNlcnQgPj4+XCIsIHNyLCBzZywgc2IsIHNhKTtcclxuICAgICAgICBsZXQgW3IsIGcsIGIsIGFdID0gY3VycmVudGFlcy5nZXRGaWxsQ29sb3IoKTsgLy9jb25zb2xlLmxvZyhcIlByb3BTeW1ib2xzIEluc2VydCA+Pj5cIiwgciwgZywgYiwgYSk7XHJcbiAgICAgICAgY29uc3QgcmdiYSA9IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7YX0pYDsvLyBjb25zdCByZ2JjID0gYHJnYmEoJHtjdXJyZW50YWVzLmZpbGxDb2xvclswXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsxXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsyXX0sJHsxfSlgO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudGFlcy5nZXRTdHJva2VDb2xvcigpICE9IG51bGwgJiYgY3VycmVudGFlcyAhPSB1bmRlZmluZWQpIC8vVE9ETzogUmVtb3ZlICYmIGN1cnIuLlxyXG4gICAgICAgICAgICBzdHJva2Vjb2xvciA9IGByZ2JhKCR7c3J9LCR7c2d9LCR7c2J9LCR7c2F9KWA7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzdHJva2Vjb2xvciA9IGByZ2JhKCR7MH0sJHswfSwkezB9LCR7MX0pYDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG51bUxlZ2VuZEl0ZW1zIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBsZXQgcHJvcHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlyc3RJbnNlcnRpb24gJiYgaSA9PT0gKG51bUxlZ2VuZEl0ZW1zIC0gMSkgfHwgbnVtTGVnZW5kSXRlbXMgPT09IDEpXHJcbiAgICAgICAgICAgICAgICBwcm9wdmFsdWUgPSBjdXJyZW50YWVzLnJhbmdlWzFdO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwcm9wdmFsdWUgPSBtYXBvYmoubWluICsgaSAvIChudW1MZWdlbmRJdGVtcyAtIDEpICogKG1hcG9iai5tYXggLSBtYXBvYmoubWluKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShNYXRoLnJvdW5kKHByb3B2YWx1ZSkpOyAvL1RPRE86IHRoaXMucm91bmQocHJvcFZhbHVlKSA/XHJcbiAgICAgICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmdiYTtcclxuICAgICAgICAgICAgY29sb3JEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5cHJvcG9ydGlvbmFsY2lyY2xlJztcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSBzdHJva2Vjb2xvcjtcclxuICAgICAgICAgICAgY29uc3QgdGVtcHBvaW50c2l6ZSA9ICgobWFwb2JqLmdpc3BsYXlPcHRpb25zLm1heFBvaW50U2l6ZSAtIG1hcG9iai5naXNwbGF5T3B0aW9ucy5taW5Qb2ludFNpemUpIC8gKG1hcG9iai5tYXggLSBtYXBvYmoubWluKSkgKiAocHJvcHZhbHVlIC0gbWFwb2JqLm1pbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCh0ZW1wcG9pbnRzaXplLCA3LjUpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS53aWR0aCA9IHNpemU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmluaGVyaXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGNvbG9yRGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcG9iai5naXNwbGF5T3B0aW9ucy5sZWdlbmRUb2dnbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0ZhZGUgPSAhY3VycmVudGFlcy5lbmFibGVEaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvRmFkZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gXCIgX2dpc3BsYXlmYWRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5ZmFkZSg/IVxcUykvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcG9iai5naXNwbGF5T3B0aW9ucy5sZWdlbmRPbkNsaWNrRnVuY3Rpb24gIT0gbnVsbCAmJiBtYXBvYmouZ2lzcGxheU9wdGlvbnMubGVnZW5kT25DbGlja0Z1bmN0aW9uICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICBtYXBvYmouZ2lzcGxheU9wdGlvbnMubGVnZW5kT25DbGlja0Z1bmN0aW9uKGN1cnJlbnRhZXMpO1xyXG4gICAgICAgICAgICAgICAgbWFwb2JqLmRyYXcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKmlmICghZSlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHdpbmRvdy5ldmVudDsgLy9UT0RPOiBSZW1vdmU/PyovXHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQoY29sb3JEaXYpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0ZGl2ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ZGl2LmFwcGVuZENoaWxkKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ZGl2ID0gY29sb3JEaXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7Ly8xc3QgaW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdiA9IGNvbG9yRGl2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5maXJzdEluc2VydGlvbikgey8vMXN0IGluc2VydGlvblxyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB0aGUgbGVnZW5kIGRpdiBlbGVtZW50IHRvIHRoZSBtYXAgY29udGFpbmVyLiBVc2VkIGJ5IGFsbCBNYXBzLlxyXG4gICAgICogQHBhcmFtIHtCR01hcFdyYXBwZXJ9IGJnTWFwIC0gVGhlIGJhY2tncm91bmQgbWFwIHdoZXJlIHRoZSBsZWdlbmQgd2lsbCBiZSBhcHBlbmRlZCB0by4gXHJcbiAgICAgKi9cclxuICAgIGluc2VydExlZ2VuZChiZ01hcCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2LmFwcGVuZENoaWxkKHRoaXMudGFibGUpO1xyXG4gICAgICAgIGJnTWFwLmdldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMubGVnZW5kRGl2KTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0xlZ2VuZC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFvQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQVpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/Gisplay/Maps/Map.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Map = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BGMapWrapper = __webpack_require__(/*! ./BGMapWrapper */ 3);\n\nvar _Aesthetic = __webpack_require__(/*! ./Aesthetic */ 4);\n\nvar _GisplayOptions = __webpack_require__(/*! ../GisplayOptions */ 7);\n\nvar _WebGLUtils = __webpack_require__(/*! ./WebGLUtils */ 12);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class contains the Map class which represents the current map.\r\n * Each map has a group of functions available. There is only one map yet(maybe there will be two if we want to compare two).\r\n * @see Diogo's thesis 57-60 + 64/65\r\n */\nvar Map = exports.Map = function () {\n\n    /**\r\n     * Map constructor. All Map subclasses should call this first with super(...).\r\n     * @param {BGMapWrapper|Object} bgmap - Background map.\r\n     * @param {JSON} geometry - Geometry read from the file.\r\n     * @param {Object} userOptions - The user defined options. \r\n     * @todo With the type of the map we can do an if statement inside constructor to use or not some of the variables.\r\n     */\n    function Map(bgmap, geometry, userOptions) {\n        _classCallCheck(this, Map);\n\n        //console.log(\"Map constructor called -> super()\");\n        /**\r\n          * This object holds for each point it's long, lat and associated properties. \r\n          * This points will be used by k-d Tree. And k-d Tree is used to find the closest point to where the user clicked.\r\n          * @type {Array<{lon: number, lat: number, properties: JSON}>}\r\n          */\n        this.treepoints = [];\n\n        // ####################### DOT MAP ONLY\n        /**\r\n          * Holds the points for each Aesthethic object.\r\n          * @type {Array<Array<number>>}\r\n          */\n        this.tempAestheticPoints = new Array();\n\n        // ####################### ALL MAPS\n        /**\r\n         * Aesthetic objects that were saved.\r\n         * @type {Array<Aesthetic>}\r\n         */\n        this.aesthetics = new Array();\n        /**\r\n         * JSON object with the geometry that was read from the file.\r\n         * @type {JSON}\r\n         */\n        this.geometry = geometry;\n        /**\r\n         * This map unique identifier.\r\n         * @type {number}\r\n         */\n        this.id = window.mapcount++;\n\n        /**\r\n         * KdTree object to hold that will be used to calculate the closest point to the coordinates where the user made a click.\r\n         * @type {kdTree}\r\n         * @see Diogo's thesis Page 61.\r\n         * @see https://github.com/ubilabs/kd-tree-javascript\r\n         */\n        this.kdtree = undefined;\n        /**\r\n         * RBush(Rtree implementation) that is used to calculate the polygon closest to the coordinates where the user made a click.\r\n         * @type {PolygonLookup}\r\n         * @see Diogo's thesis page 61.\r\n         * @see https://github.com/pelias/polygon-lookup\r\n         * @see https://github.com/mourner/rbush\r\n         */\n        this.rtree = undefined;\n        /**\r\n         * Polygons do/do not exist. This is used to know if it to create a rtree or not on buildTrees method.\r\n         * @type {boolean}\r\n         */\n        this.hasPolygons = false;\n\n        /**\r\n         * This is the maixmum value found on the dataset. The final value for the break. E.g. [2, 37[ 37 is the max. \r\n         * Used for PSymbol Map and Change Map because on those maps it's important to take in consideration this values to define the Feature color.\r\n         * @see Diogo's thesis page 63 5.1.3 \r\n         * @type {number}\r\n         */\n        this.max = null;\n        /**\r\n         * This is the minimum value found on the dataset. The initial value for the break. E.g. [2, 37[ 2 is the min.\r\n         * Used for PSymbol Map and Change Map because on those maps it's important to take in consideration this values to define the Feature color.\r\n         * @see Diogo's thesis page 63 5.1.3\r\n         * @type {number}\r\n         */\n        this.min = null;\n    }\n\n    /**\r\n     * M1) Loads user and default options. For each case if it isn't provided by the user, then it uses\r\n     * the default option. 1st method to be called.\r\n     * @param {Object} userOptions - Options given by the user. \r\n     * @param {Object} bgmap  - The background map provider.\r\n     */\n\n\n    _createClass(Map, [{\n        key: 'loadOptions',\n        value: function loadOptions(userOptions, bgmap) {\n            /**\r\n             * All the options available in the Gisplay API.\r\n             * @type {GisplayOptions}\r\n             */\n            this.gisplayOptions = new _GisplayOptions.GisplayOptions(userOptions);\n\n            /**\r\n             * This is the Gisplay API Background map wrapper. It contains the background map provider object to access it's methods (zoom, coordinates,etc).\r\n             * This map(Gisplay Map) will  be drawn over the background map(bGMap).\r\n             * @type {BGMapWrapper}\r\n             */\n            this.bGMap = this.gisplayOptions.useCustomMapService ? bgmap : new _BGMapWrapper.BGMapWrapper(bgmap);\n            if (this.gisplayOptions.showLoader) this.showLoader();\n        }\n\n        /**\r\n         * M2) Calls the Background Map Wrapper to create the loader to be used later when the user feeds data to the API.\r\n         * @deprecated Not used anymore\r\n         */\n\n    }, {\n        key: 'showLoader',\n        value: function showLoader() {\n            this.bGMap.showLoader();\n        }\n\n        /**\r\n         * M3) Initializes the API by: creating canvas, the WebGL program and setting up all needed events.\r\n         * @return {void}\r\n         */\n\n    }, {\n        key: 'initializeCanvasAndEvents',\n        value: function initializeCanvasAndEvents() {\n            this.createCanvas();\n            _WebGLUtils.WebGLUtils.createWebGLProgram(this._webgl);\n            this.setupEvents(this.id);\n        }\n\n        /**\r\n         * M4) Creates a canvas element and WebGL associated information.\r\n         */\n\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas() {\n            var canvas = this.bGMap.createCanvas(this.id);\n\n            /**\r\n             * @type {Object} _webgl - WebGL object.  Init webgl properties\r\n             * @property  {WebGLRenderingContext} _webgl.gl - The WebGLRenderingContext to be used.\r\n             * @property  {WebGLProgram} _webgl.program -  The WebGLProgram to be used. \r\n             * @property  {Float32Array} _webgl.projection - The projection to be used. Deprecated in favor of better projection to work with multiple map background providers.\r\n             * @see Diogo's thesis page 64+\r\n             */\n            this._webgl = {\n                gl: null,\n                program: null\n            };\n\n            this._webgl.gl = canvas.getContext(\"webgl\");\n            window.canvas = canvas;\n            this._webgl.gl.viewport(0, 0, this.bGMap.getContainer().offsetWidth, this.bGMap.getContainer().offsetHeight);\n            this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);\n        }\n\n        /**\r\n         * M8) Setup all events used by the API. Right now the API uses: drag, zoom and click events. \r\n         * This events will be fired by the background map provider and we can use them to draw(zoom and pan) or alert information(click).\r\n         * Pan/Zoom = move, click = click\r\n         * rtree will be used to find the closest polygon to the where the clicked event happened.\r\n         * kdtree will be used to find the closest point to where the click event happened.\r\n         * @todo This method is doing uneccessary job if the user set interative to false and mapOnClickFunction is undefined.\r\n         * @param {number} mappos - This map id. \r\n         * @return {void}\r\n         * @see https://www.mapbox.com/mapbox-gl-js/api/#events\r\n         * @see http://stackoverflow.com/a/34349737\r\n         */\n\n    }, {\n        key: 'setupEvents',\n        value: function setupEvents(mappos) {\n            var _this = this;\n\n            /*if(!this.gisplayOptions.interactive && this.gisplayOptions.mapOnClickFunction === undefined)\r\n                return;*/\n            this.bGMap.addEventListener('move', function () {\n                _this.draw();\n            });\n            this.bGMap.addEventListener('click', function (e) {\n                //TODO: Create 2 methods (1 for rtree another for kdtree)\n                var lng = ((180 + e.latlng.lng) % 360 + 360) % 360 - 180;\n                var lat = e.latlng.lat;\n                /**\r\n                 * When dealing with polygons rtree will be used.\r\n                 * @see Diogo's thesis Page 62\r\n                 */\n                if (_this.rtree !== undefined) _this.searchRTree(lng, lat);\n\n                /**\r\n                 * When dealing with points kdtree will be used.\r\n                 * @see Diogo's thesis page 62\r\n                 */\n                if (_this.kdtree !== undefined) _this.searchKdTree(lng, lat);\n            });\n        }\n\n        /**\r\n         * Search the rtree for the closest polygon from the lng, lat that was clicked.\r\n         * @param {number} lng - The longitude of the click.\r\n         * @param {number} lat - The latitude of the click.\r\n         * @returns \r\n         * \r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'searchRTree',\n        value: function searchRTree(lng, lat) {\n            var rtreeSearchResult = this.rtree.search(lng, lat);\n            if (rtreeSearchResult === undefined) return;else {\n                var res = \"\";\n                var showPrtOnClick = this.gisplayOptions.showPropertiesOnClick;\n                if (showPrtOnClick !== null) {\n                    for (var i = 0; i < showPrtOnClick.length; i += 2) {\n                        if (i === 0) res += showPrtOnClick[i + 1] + ': ' + rtreeSearchResult.properties[showPrtOnClick[i]];else res += '\\n' + showPrtOnClick[i + 1] + ': ' + rtreeSearchResult.properties[showPrtOnClick[i]];\n                    }\n                } else {\n                    var keys = Object.keys(rtreeSearchResult.properties);\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n\n                    try {\n                        for (var _iterator = keys.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            var _step$value = _slicedToArray(_step.value, 2),\n                                _i = _step$value[0],\n                                key = _step$value[1];\n\n                            if (key !== \"_gisplayid\") _i == 0 ? res += key + ': ' + rtreeSearchResult.properties[key] : res += '\\n' + key + ': ' + rtreeSearchResult.properties[key];\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                }\n\n                if (this.gisplayOptions.interactive) alert(res); //todo\n                if (this.gisplayOptions.mapOnClickFunction !== undefined) this.gisplayOptions.mapOnClickFunction(rtreeSearchResult);\n            }\n        }\n\n        /**\r\n         * Search the rtree for the closest point from the lng, lat that was clicked. \r\n         * @param {number} lon - The longitude of the click.\r\n         * @param {number} lat - The latitude of the click.\r\n         * @returns \r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'searchKdTree',\n        value: function searchKdTree(lon, lat) {\n            var nearest = this.kdtree.nearest({ lon: lon, lat: lat }, 1, 128 / 2 ** (this.bGMap.getZoom() * 2));\n            console.log(\"21\", nearest);\n            if (nearest.length <= 0) return;else {\n                console.log(\"22\");\n                var kdTreeSearchResult = nearest[0][0];\n                var res = \"\";\n                var showPrtOnClick = this.gisplayOptions.showPropertiesOnClick;\n                if (showPrtOnClick !== null) {\n                    //TODO: Remove if dentro do for e passar a comear no i=1 e passar o if para antes do for\n                    for (var i = 0; i < showPrtOnClick.length; i += 2) {\n                        if (i === 0) res += showPrtOnClick[i + 1] + ': ' + kdTreeSearchResult.properties[showPrtOnClick[i]];else res += '\\n' + showPrtOnClick[i + 1] + ': ' + kdTreeSearchResult.properties[showPrtOnClick[i]];\n                    }\n                } else {\n                    var keys = Object.keys(kdTreeSearchResult.properties);\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = keys.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var _step2$value = _slicedToArray(_step2.value, 2),\n                                _i2 = _step2$value[0],\n                                key = _step2$value[1];\n\n                            if (key !== \"_gisplayid\") _i2 == 0 ? res += key + ': ' + kdTreeSearchResult.properties[key] : res += '\\n' + key + ': ' + kdTreeSearchResult.properties[key];\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                }\n\n                if (this.gisplayOptions.interactive) alert(res);\n                if (this.gisplayOptions.mapOnClickFunction !== undefined) this.gisplayOptions.mapOnClickFunction(kdTreeSearchResult);\n            }\n        }\n\n        /** ########################   METHOD from Gisplay.js    ######################## */\n        /**\r\n         * M9) Method that executes all the process associated with the creation of the thematic map.\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'makeMap',\n        value: function makeMap() {\n            var _this2 = this;\n\n            var opts = this.gisplayOptions;\n            setTimeout(function (console) {\n                if (opts.colorScheme === undefined) opts.colorScheme = _this2.defaults(opts.colorSchemeId).colorScheme;\n                if (opts.classBreaks === undefined) {\n                    if (opts.numberOfClasses === undefined) opts.numberOfClasses = _this2.defaults(opts.colorSchemeId).numberOfClasses;\n                    _this2.preProcessData(_this2.geometry, opts.numberOfClasses, opts.classBreaksMethod, opts.colorScheme);\n                }\n\n                _this2.loadGeoJSON(_this2.geometry);\n                _this2.draw();\n\n                if (opts.showLegend) _this2.buildLegend();\n                if (opts.showLoader) //@TODO: Change this if to be the 1st thing done inside the setTimeout\n                    _this2.showLoader();\n            }, 1);\n        }\n\n        /**\r\n         * M11) Creates Aesthetic objects. If there's the need to calculate the class intervals,\r\n         * the method calcClassBreaks is called \r\n         * @param {JSON} geojson - GeoJSON object.\r\n         * @param {number} numberOfClasses - Number of classes that the Legend will contain.\r\n         * @param {string} classBreaksMethod - Algorithm to be used to calculate class breaks. Only used it class breaks are not given by the user.\r\n         * @param {string[]} colorscheme - Color scheme to be used by this map.\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOfClasses, classBreaksMethod, colorscheme) {\n            /**\r\n             * @type {Array<Aesthetic>}\r\n             */\n            var aesarray = []; //Array of aesthetic objects loaded from the file\n            var numberValues = []; //The attr is a number\n            var stringValues = []; //The attr is a string\n            var classBreaks = void 0; //Class Breaks given by the user or calculated by the API\n            var fcolor = void 0; //Colors to be used\n            var opts = this.gisplayOptions; //Options given by the user and defaults\n\n            var geoJsonFeaturesLength = geojson.features.length;\n            for (var i = 0; i < geoJsonFeaturesLength && i < opts.maxFeatures; i++) {\n                //@TODO?: Two fors one if attr is a string another if it a number\n                var attrValue = geojson.features[i].properties[opts.attr];\n                if (attrValue !== null && typeof attrValue === 'number') {\n                    //If \"f3\" exists and its a number\n                    numberValues.push(attrValue);\n                    this.max = Math.max(this.max, attrValue);\n                    this.min = Math.min(this.min, attrValue);\n                } else if (!stringValues.includes(attrValue)) //If its a string\n                    stringValues.push(geojson.features[i].properties[opts.attr]);\n            }\n\n            if (numberValues.length > 0) {\n                //Quantitative\n                if (opts.classBreaks === undefined) {\n                    //Not given by the user then calculate them\n                    if (numberOfClasses > 1) classBreaks = this.calcClassBreaks(numberValues, classBreaksMethod, numberOfClasses);else classBreaks = [this.min, this.max]; //Change Map\n                } else //Given by the user\n                    classBreaks = opts.classBreaks;\n\n                if (classBreaks.length > 2) {\n                    fcolor = chroma.scale(colorscheme).colors(classBreaks.length - 1);\n                    for (var _i3 = 0; _i3 < classBreaks.length - 1; _i3++) {\n                        var _chroma$rgb = chroma(fcolor[_i3]).rgb(),\n                            _chroma$rgb2 = _slicedToArray(_chroma$rgb, 3),\n                            r = _chroma$rgb2[0],\n                            g = _chroma$rgb2[1],\n                            b = _chroma$rgb2[2]; // let color = chroma(fcolor[i]).rgb();\n\n\n                        var aes = void 0;\n                        if (_i3 !== classBreaks.length - 2) aes = new _Aesthetic.Aesthetic(_i3, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[_i3], classBreaks[_i3 + 1]]);else {\n                            aes = new _Aesthetic.Aesthetic(_i3, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[_i3], classBreaks[_i3 + 1]]);\n                            aes.outer = true;\n                        }\n                        aesarray.push(aes);\n                    }\n                } else {\n                    var _chroma$rgb3 = chroma(colorscheme[0]).rgb(),\n                        _chroma$rgb4 = _slicedToArray(_chroma$rgb3, 3),\n                        r = _chroma$rgb4[0],\n                        g = _chroma$rgb4[1],\n                        b = _chroma$rgb4[2]; // let color = chroma(colorscheme[0]).rgb();\n\n\n                    var _aes = new _Aesthetic.Aesthetic(0, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[0], classBreaks[1]]);\n                    _aes.outer = true;\n                    aesarray.push(_aes);\n                }\n            } else {\n                //Qualitative\n                if (stringValues.length > 0) {\n                    classBreaks = stringValues;\n                    if (typeof colorscheme === 'string') //string\n                        fcolor = chroma.scale(colorscheme).colors(classBreaks.length);else //array\n                        fcolor = chroma.scale(colorscheme).colors(classBreaks.length);\n\n                    for (var _i4 = 0; _i4 < classBreaks.length; _i4++) {\n                        var _chroma$rgb5 = chroma(fcolor[_i4]).rgb(),\n                            _chroma$rgb6 = _slicedToArray(_chroma$rgb5, 3),\n                            _r = _chroma$rgb6[0],\n                            _g = _chroma$rgb6[1],\n                            _b = _chroma$rgb6[2]; // let color = chroma(fcolor[i]).rgb();\n\n\n                        var _aes2 = new _Aesthetic.Aesthetic(_i4, opts.attr, [Math.round(_r), Math.round(_g), Math.round(_b), 1], [0, 0, 0, 1], null, [stringValues[_i4]]);\n                        aesarray.push(_aes2);\n                    }\n                }\n            }\n\n            /**\r\n             * All the Aesthetics that were read from the GeoJSON file.\r\n             * @type {Array<Aesthetic>}\r\n             */\n            this.aesthetics = aesarray;\n        }\n\n        /**\r\n         * M12) Calculates the class breaks using the algorithm given(k-means, quantile or equidistant). \r\n         * There will be as many class breaks as number of classes(numberOfClasses) given as input. \r\n         * @param {number[]} numberValues - The data values that will be used to be compute the breaks. \r\n         * @param {string} classBreakMethod - The algorithm to use to calculate the class breaks.\r\n         * @param {number} numberOfClasses - Number of classes the result expects.\r\n         * @returns {number[]} - The class breaks resulting from the use of the given algorithm and the number of classes.\r\n         * @see http://gka.github.io/chroma.js/#chroma-limits\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'calcClassBreaks',\n        value: function calcClassBreaks(numberValues, classBreakMethod, numberOfClasses) {\n            var classBreaks = void 0;\n            switch (classBreakMethod) {\n                case 'equidistant':\n                    classBreaks = chroma.limits(numberValues, 'e', numberOfClasses);\n                    break;\n\n                case 'quantile':\n                    classBreaks = chroma.limits(numberValues, 'q', numberOfClasses);\n                    break;\n\n                case 'k-means':\n                    classBreaks = chroma.limits(numberValues, 'k', numberOfClasses);\n                    break;\n\n                default:\n                    classBreaks = chroma.limits(numberValues, 'q', numberOfClasses);\n                    break;\n            }\n            return classBreaks;\n        }\n\n        /**\r\n         * M13) Loads GeoJSON object that came from the file uploaded by the user. \r\n         * Extracts the Features present in the geometry object and inserts them in Aesthetic object(s)\r\n         * This method will create and insert features to Aesthetic objects and build trees of relationships between points or polygons.\r\n         * @param {JSON} geojson - GeoJSON read from the file.\r\n         * @see https://www.dashingd3js.com/lessons/geojson\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'loadGeoJSON',\n        value: function loadGeoJSON(geojson) {\n            for (var i = 0; i < geojson.features.length && (this.gisplayOptions.maxFeatures === undefined || i < this.gisplayOptions.maxFeatures); i++) {\n                geojson.features[i].properties['_gisplayid'] = i;\n                var geometry = geojson.features[i].geometry;\n                var properties = geojson.features[i].properties;\n                this.createAndInsertFeature(i, geometry, properties);\n            }\n            this.buildTrees(geojson); //@TODO: Only call this method if it's a low end device aka options.memorySaver is on\n        }\n\n        /**\r\n         * M14) Creates a Feature and then calls a method to insert said Feature in one or more Aesthetic objects.\r\n         * @param {number} featureId - Id of the Feature.\r\n         * @param {JSON} geometry - GeoJSON Geometry Object. \r\n         * @param {JSON} properties - GeoJSON properties Object.\r\n         * @see http://geojson.org/geojson-spec.html#geometry-objects\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'createAndInsertFeature',\n        value: function createAndInsertFeature(featureId, geometry, properties) {\n            var gl = this._webgl.gl;\n            /**\r\n             * @type {GisplayOptions}\r\n             */\n            var opts = this.gisplayOptions;\n            if (opts.minuend !== undefined && opts.subtrahend !== undefined && typeof properties[opts.minuend] === 'number' && typeof properties[opts.subtrahend] === 'number' && properties[opts.minuend] !== undefined && properties[opts.subtrahend] !== undefined) {\n                properties[opts.attr] = properties[opts.minuend] - properties[opts.subtrahend]; //Used for Change map\n            }\n\n            //let isPoint = geometry.type == \"Point\";\n            if (geometry.type === \"Polygon\" || geometry.type === \"MultiPolygon\") {\n                this.hasPolygons = true;\n                var polygons = this.processPolygon({ geometry: geometry, properties: properties });\n\n                var currentTriangles = []; //Polygon Triangles vertices\n                var bufferT = []; //WebGL Buffers with  triangles\n                var currentBorders = []; //Polygon Borders vertices\n                var bufferB = []; //Buffer borders\n\n                for (var i = 0; i < polygons.length; i++) {\n                    //For each Polygon\n                    var trianglesPolygon = polygons[i].triangles;\n                    var border = polygons[i].vertices;\n                    currentTriangles[i] = new Array(); //Add This Polygon triangles\n                    currentBorders[i] = new Array(); //Add this Polygon borders\n\n                    for (var j = 0; j < trianglesPolygon.length; j++) {\n                        //Triangles\n                        currentTriangles[i].push(border[trianglesPolygon[j] * 2], border[trianglesPolygon[j] * 2 + 1]);\n\n                        if (j === trianglesPolygon.length - 1) {\n                            bufferT.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentTriangles[i]);\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[i]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferT[i].itemSize = 2;\n                            bufferT[i].numItems = vertArray.length / 2;\n                        }\n                    }\n\n                    for (var k = 0; k < border.length; k += 2) {\n                        //Borders\n                        currentBorders[i].push(border[k], border[k + 1]);\n\n                        if (k === border.length - 2) {\n                            bufferB.push(gl.createBuffer());\n\n                            var _vertArray = new Float32Array(currentBorders[i]);\n                            gl.fsize = _vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[i]);\n                            gl.bufferData(gl.ARRAY_BUFFER, _vertArray, gl.STATIC_DRAW);\n\n                            bufferB[i].itemSize = 2;\n                            bufferB[i].numItems = _vertArray.length / 2;\n                        }\n                    }\n                }\n                this.insertFeature(featureId, properties, bufferT, bufferB, []);\n            } else if (geometry.type === \"Point\" && opts.isDynamic) {\n                var currentPoints = new Array();\n                currentPoints.push(geometry.coordinates[0], geometry.coordinates[1]);\n                var bufferPoints = []; //Buffer points\n                var _vertArray2 = new Float32Array(currentPoints);\n\n                bufferPoints.push(gl.createBuffer());\n                gl.fsize = _vertArray2.BYTES_PER_ELEMENT;\n                gl.bindBuffer(gl.ARRAY_BUFFER, bufferPoints[0]);\n                gl.bufferData(gl.ARRAY_BUFFER, _vertArray2, gl.STATIC_DRAW);\n\n                bufferPoints[0].itemSize = 2;\n                bufferPoints[0].numItems = _vertArray2.length / 2;\n\n                this.insertFeature(featureId, properties, [], [], bufferPoints);\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            } else if (geometry.type === \"Point\" && !opts.isDynamic) {\n                if (this.tempAestheticPoints.length === 0) for (var _i5 = 0; _i5 < this.aesthetics.length; _i5++) {\n                    this.tempAestheticPoints[_i5] = [];\n                }var aesPositions = this.fitFeature(properties);\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = aesPositions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var aesPos = _step3.value;\n\n                        this.tempAestheticPoints[aesPos].push(geometry.coordinates[0], geometry.coordinates[1]);\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            }\n        }\n\n        /**\r\n         * M15) Deals with polygon triangulation.\r\n         * @param {{geometry: JSON, properties: JSON}} polygon - The geometry and properties of the polygon.\r\n         * @returns {{triangles: Array<number>, vertices: Array<number>}} - The triangles and vertices calculated by earcut triangulation. The vertices are the outside of the polygon, the triangles are the inside.\r\n         * @see http://www.macwright.org/2015/03/23/geojson-second-bite.html#polygons\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'processPolygon',\n        value: function processPolygon(polygon) {\n            var polyarray = [];\n            if (polygon.geometry.type === \"Polygon\") {\n                //@TODO: [Demos never use this if statement.]\n                var outsidepolygon = polygon.geometry.coordinates[0]; //See: http://geojson.org/geojson-spec.html#polygon\n                var tempVerts = new Array();\n                for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                    tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n                } //_vertexcount += (outsidepolygon.length + 1) / 2;\n                var triangles_vert = earcut(tempVerts); // _tricount += (triangles_vert.length / 3);\n                polyarray.push({ triangles: triangles_vert, vertices: tempVerts });\n            } else if (polygon.geometry.type == \"MultiPolygon\") {\n                //See http://geojson.org/geojson-spec.html#multipolygon\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    for (var _iterator4 = polygon.geometry.coordinates[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var cs = _step4.value;\n\n                        var _outsidepolygon = cs[0];\n                        var _tempVerts = new Array();\n                        var _iteratorNormalCompletion5 = true;\n                        var _didIteratorError5 = false;\n                        var _iteratorError5 = undefined;\n\n                        try {\n                            for (var _iterator5 = _outsidepolygon[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                                var c = _step5.value;\n\n                                _tempVerts.push(c[0], c[1]);\n                            }\n                        } catch (err) {\n                            _didIteratorError5 = true;\n                            _iteratorError5 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                    _iterator5.return();\n                                }\n                            } finally {\n                                if (_didIteratorError5) {\n                                    throw _iteratorError5;\n                                }\n                            }\n                        }\n\n                        var _triangles_vert = earcut(_tempVerts);\n                        polyarray.push({ triangles: _triangles_vert, vertices: _tempVerts });\n                    }\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n            }\n            return polyarray;\n        }\n\n        /**\r\n         * M16) Converts geographic coordinates(latitude, longitude) to canvas coordinate pixels.\r\n         * @param {number} longitude - The longitude.\r\n         * @param {number} latitude - The latitude.\r\n         * @returns {x: number, y: number} - canvas coordinate system pixels.\r\n         * @see http://gisgeography.com/latitude-longitude-coordinates/\r\n         * @see https://www.w3schools.com/graphics/canvas_coordinates.asp\r\n         * @deprecated Not used anymore. YEAH...\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'latLongToPixelXY',\n        value: function latLongToPixelXY(longitude, latitude) {\n            var pi_180 = Math.PI / 180.0;\n            var pi_4 = Math.PI * 4;\n            var sinLatitude = Math.sin(latitude * pi_180);\n            var pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / pi_4) * 256;\n            var pixelX = (longitude + 180) / 360 * 256;\n\n            var pixel = { x: pixelX, y: pixelY };\n            return pixel;\n        }\n\n        /**\r\n         * M17) Inserts the Feature into one or more Aesthetic objects. If the Feature does not fit in any Aesthetic then does nothing.\r\n         * @param {number} id - The Feature id. \r\n         * @param {JSON} properties - The Feature properties. \r\n         * @param {{itemSize: number, numItems: number}} triangles - Triangles, each in one WebGLBuffer.\r\n         * @param {{itemSize: number, numItems: number}} borders - Borders, each in one WebGLBuffer.\r\n         * @param {{itemSize: number, numItems: number}} points - Points, each in one WebGLBuffer.\r\n         * @return {void}\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'insertFeature',\n        value: function insertFeature(id, properties, triangles, borders, points) {\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = this.aesthetics[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var aes = _step6.value;\n\n                    if (aes.checkProperty(properties[aes.getAttr()])) aes.addFeature(id, properties, triangles, borders, points);\n                } /* for (let i = 0; i < this.aesthetics.length; i++)\r\n                       if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]))\r\n                           this.aesthetics[i].addFeature(id, properties, triangles, borders, points);*/\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * M18) Returns an array of Aesthetic ids that tells us the objects where the Feature belongs.\r\n         * @param {JSON} properties - The Feature properties\r\n         * @returns {Array<number>} - The Aesthetic ids where the Feature belongs.\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'fitFeature',\n        value: function fitFeature(properties) {\n            var res = [];\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()])) res.push(i);\n            }return res;\n        }\n\n        /**\r\n         * M19) Receives the dataset as parameter. This dataset in each row contains geometry and associated properties, then it creates one tree\r\n         * either for points or polygons. This tree can be k-d Treee or RBush(RTree)\r\n         * @param {JSON} geojson \r\n         * @return {void}\r\n         * @see Diogo's thesis page 62\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'buildTrees',\n        value: function buildTrees(geojson) {\n            var gl = this._webgl.gl;\n            if (this.tempAestheticPoints.length > 0) {\n                for (var i = 0; i < this.tempAestheticPoints.length; i++) {\n                    if (this.tempAestheticPoints[i].length > 0) {\n                        var vertArray = new Float32Array(this.tempAestheticPoints[i]);\n                        var bufferP = [];\n                        bufferP.push(gl.createBuffer());\n\n                        gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n                        bufferP[0].itemSize = 2;\n                        bufferP[0].numItems = vertArray.length / 2;\n                        this.insertGroupedFeature(i, [], [], bufferP);\n                    }\n                }\n            }\n            if (this.treepoints !== null) this.kdtree = new kdTree(this.treepoints, function (a, b) {\n                return (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2;\n            }, [\"lon\", \"lat\", \"properties\"]);\n            if (this.hasPolygons) this.rtree = new PolygonLookup(geojson);\n        }\n\n        /**\r\n         * M20) Similar to insertFeature, in this case inserts a group of Features like it was only one.\r\n         * It creates one WebGLBuffer with all the points instead of one WebGLBuffer per point.\r\n         * This method should only be used when we already grouped the Features by Aesthetic class (fitFeature() method).\r\n         * This method exists to provide one alternative less expensive in terms of memory for low end devices.\r\n         * Used only on Dot Map because on those we can easily end up with millions of different Features.\r\n         * @param {number} id - Aesthethics id. \r\n         * @param {{itemSize: number, numItems: number}} triangles - Not used ?\r\n         * @param {{itemSize: number, numItems: number}} borders - Not used ?\r\n         * @param {{itemSize: number, numItems: number}} points - All the points for the Aesthethic object in one WebGLBuffer.\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'insertGroupedFeature',\n        value: function insertGroupedFeature(id, triangles, borders, points) {\n            this.aesthetics[id].addGroupedFeature(null, triangles, borders, points);\n        }\n\n        /** ########################    LEGEND METHODS    ######################## */\n        /**\r\n         * M17) Creates a Legend element suitable for polygons based on the Aesthethic objects.\r\n         * Should be overriden by subclasses.\r\n         * @return {void}\r\n         * @abstract\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            var mapCanvas = document.getElementById('mapCanvas' + this.id);\n            var legendDiv = document.createElement('div');\n            legendDiv.id = 'legendDiv' + this.id;\n            legendDiv.style.position = 'absolute';\n            legendDiv.style.backgroundColor = 'white';\n            legendDiv.style.width = 250;\n            legendDiv.style.bottom = 20;\n            legendDiv.style.right = 0;\n            legendDiv.style.borderColor = 'black';\n            legendDiv.style.border = 'solid';\n\n            var table = document.createElement('table');\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            table.style.zIndex = \"2000\";\n            thcolor.style.width = 100;\n            table.appendChild(thcolor);\n            table.appendChild(thvalue);\n\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n                for (var _iterator7 = this.aesthetics[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var currentaes = _step7.value;\n\n                    var row = document.createElement('tr');\n                    var value = document.createElement('td');\n                    var color = document.createElement('td');\n                    var ptext = document.createElement('p');\n                    var text = void 0;\n                    if (typeof currentaes.range[0] === 'number') text = document.createTextNode('[' + currentaes.range[0] + ', ' + currentaes.range[1] + '[');else text = document.createTextNode(currentaes.range[0]);\n                    ptext.appendChild(text);\n                    value.appendChild(ptext);\n\n                    var colorDiv = document.createElement('div');\n                    colorDiv.style.position = 'relative';\n                    var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n                    colorDiv.style['backgroundColor'] = rgbc;\n                    colorDiv.style.height = 25;\n                    colorDiv.style.width = 80;\n                    color.appendChild(colorDiv);\n\n                    row.appendChild(color);\n                    row.appendChild(value);\n                    table.appendChild(row);\n                }\n            } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                        _iterator7.return();\n                    }\n                } finally {\n                    if (_didIteratorError7) {\n                        throw _iteratorError7;\n                    }\n                }\n            }\n\n            legendDiv.appendChild(table);\n            this.bGMap.getContainer().appendChild(legendDiv);\n        }\n\n        /** ########################    WEBGL METHODS    ######################## */\n        /**\r\n         * M22) Clear current buffers to preset values.\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/clear\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var gl = this._webgl.gl;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.disable(gl.DEPTH_TEST);\n        }\n\n        /**\r\n         * M23) Receiving an Aesthetics object, draws the triangles contained in it's Features,\r\n         * using the color that the Aesthethics object has.\r\n         * @param {Aesthetic} aes - The Aesthetic object.\r\n         * @returns {void}\r\n         * @see Diogo's thesis Page 58/59\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'drawTriangles',\n        value: function drawTriangles(aes) {\n            var gl = this._webgl.gl;\n            if (gl === null) return;\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            var currentZoom = this.bGMap.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n            var vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, 'coords');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            var fragmentColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n\n            var _aes$getFillColor = aes.getFillColor(),\n                _aes$getFillColor2 = _slicedToArray(_aes$getFillColor, 4),\n                r = _aes$getFillColor2[0],\n                g = _aes$getFillColor2[1],\n                b = _aes$getFillColor2[2],\n                a = _aes$getFillColor2[3];\n\n            this.setMatrices(gl);\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n            gl.uniform1f(isPointLocation, 0.0);\n            gl.uniform4f(fragmentColorLocation, r / 255, g / 255, b / 255, a); // Draw Polygons' Interior\n\n            var features = aes.getFeatures();\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n                for (var _iterator8 = features[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var f = _step8.value;\n                    // Draw Polygons' Interior\n                    var triangles = f.getTriangles();\n                    var _iteratorNormalCompletion9 = true;\n                    var _didIteratorError9 = false;\n                    var _iteratorError9 = undefined;\n\n                    try {\n                        for (var _iterator9 = triangles[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                            var t = _step9.value;\n\n                            gl.bindBuffer(gl.ARRAY_BUFFER, t);\n                            gl.enableVertexAttribArray(vertexCoordsLocation);\n                            gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                            gl.drawArrays(gl.TRIANGLES, 0, t.numItems);\n                        }\n                    } catch (err) {\n                        _didIteratorError9 = true;\n                        _iteratorError9 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                                _iterator9.return();\n                            }\n                        } finally {\n                            if (_didIteratorError9) {\n                                throw _iteratorError9;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                    }\n                } finally {\n                    if (_didIteratorError8) {\n                        throw _iteratorError8;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * M24) Receiving an Aesthetics object, draws the borders contained in it's Features, \r\n         * aplying the color specified in the Aeshteic object for the line color(Aeshteic.strokeColor).\r\n         * @param {Aesthetic} aes - The Aesthetic object.\r\n         * @returns {void}\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'drawBorders',\n        value: function drawBorders(aes) {\n            var gl = this._webgl.gl;\n            if (gl === null) return;\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            var currentZoom = this.bGMap.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n            var vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, 'coords');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            var fragmentColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n\n            var _aes$getStrokeColor = aes.getStrokeColor(),\n                _aes$getStrokeColor2 = _slicedToArray(_aes$getStrokeColor, 4),\n                r = _aes$getStrokeColor2[0],\n                g = _aes$getStrokeColor2[1],\n                b = _aes$getStrokeColor2[2],\n                a = _aes$getStrokeColor2[3];\n\n            this.setMatrices(gl);\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n            gl.uniform1f(isPointLocation, 0.0);\n            gl.uniform4f(fragmentColorLocation, r / 255, g / 255, b / 255, a);\n\n            var features = aes.getFeatures();\n            var _iteratorNormalCompletion10 = true;\n            var _didIteratorError10 = false;\n            var _iteratorError10 = undefined;\n\n            try {\n                for (var _iterator10 = features[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                    var f = _step10.value;\n\n                    var borders = f.getBorders();\n                    var _iteratorNormalCompletion11 = true;\n                    var _didIteratorError11 = false;\n                    var _iteratorError11 = undefined;\n\n                    try {\n                        for (var _iterator11 = borders[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                            var _b2 = _step11.value;\n\n                            gl.bindBuffer(gl.ARRAY_BUFFER, _b2);\n                            gl.enableVertexAttribArray(vertexCoordsLocation);\n                            gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                            gl.drawArrays(gl.LINE_LOOP, 0, _b2.numItems);\n                        }\n                    } catch (err) {\n                        _didIteratorError11 = true;\n                        _iteratorError11 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                                _iterator11.return();\n                            }\n                        } finally {\n                            if (_didIteratorError11) {\n                                throw _iteratorError11;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError10 = true;\n                _iteratorError10 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                        _iterator10.return();\n                    }\n                } finally {\n                    if (_didIteratorError10) {\n                        throw _iteratorError10;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * M25) Receiving an Aesthetics object, draws the borders contained in it's Features, \r\n         * aplying the filling color calculated using the attribute and the color scheme.\r\n         * @param {Aesthetic} aes - The Aesthetic object.\r\n         * @returns {void}\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'drawContinuousPolygons',\n        value: function drawContinuousPolygons(aes) {\n            var gl = this._webgl.gl;\n            if (gl === null) return;\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            var currentZoom = this.bGMap.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n            var vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, 'coords');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            var fragmentColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n\n            this.setMatrices(gl);\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var features = aes.getFeatures();\n            var _iteratorNormalCompletion12 = true;\n            var _didIteratorError12 = false;\n            var _iteratorError12 = undefined;\n\n            try {\n                for (var _iterator12 = features[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                    var f = _step12.value;\n\n                    var color = void 0;\n                    var diff = f.getProperties()[this.gisplayOptions.attr];\n                    if (diff === 0) color = aes.fillColor(0.5).rgb();else {\n                        if (diff > 0) color = aes.fillColor(0.5 + diff / this.max / 2).rgb();else color = aes.fillColor(0.5 - diff / this.min / 2).rgb();\n                    }\n                    var _ref = [Math.round(color[0]) / 255, Math.round(color[1]) / 255, Math.round(color[2]) / 255, this.gisplayOptions.alpha],\n                        r = _ref[0],\n                        g = _ref[1],\n                        b = _ref[2],\n                        a = _ref[3];\n\n                    gl.uniform4f(fragmentColorLocation, r, g, b, a);\n\n                    var triangles = f.getTriangles();\n                    var _iteratorNormalCompletion13 = true;\n                    var _didIteratorError13 = false;\n                    var _iteratorError13 = undefined;\n\n                    try {\n                        for (var _iterator13 = triangles[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                            var t = _step13.value;\n\n                            gl.bindBuffer(gl.ARRAY_BUFFER, t);\n                            gl.enableVertexAttribArray(vertexCoordsLocation);\n                            gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, fsize * 2, 0); //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                            gl.drawArrays(gl.TRIANGLES, 0, t.numItems);\n                        }\n                    } catch (err) {\n                        _didIteratorError13 = true;\n                        _iteratorError13 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                                _iterator13.return();\n                            }\n                        } finally {\n                            if (_didIteratorError13) {\n                                throw _iteratorError13;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                        _iterator12.return();\n                    }\n                } finally {\n                    if (_didIteratorError12) {\n                        throw _iteratorError12;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * M26) Receiving an Aesthetics object, draws the points contained in it's Features, \r\n         * aplying the values specified in that Aesthetic object visual variables (color and size).\r\n         * @param {Aesthetic} aes - The Aesthetic object.\r\n         * @returns {void}\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'drawPoints',\n        value: function drawPoints(aes) {\n            var gl = this._webgl.gl;\n            if (gl === null) return;\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            var currentZoom = this.bGMap.getZoom();\n            var pointSize = Math.max(currentZoom - 4.0 + aes.getPointSize(), aes.getPointSize());\n            var vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, 'coords');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            var fragmentColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n\n            var _aes$getFillColor3 = aes.getFillColor(),\n                _aes$getFillColor4 = _slicedToArray(_aes$getFillColor3, 4),\n                r = _aes$getFillColor4[0],\n                g = _aes$getFillColor4[1],\n                b = _aes$getFillColor4[2],\n                a = _aes$getFillColor4[3];\n\n            this.setMatrices(gl); //Set M1, M2 and M3\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n            gl.uniform1f(isPointLocation, 1.0);\n            gl.uniform4f(fragmentColorLocation, r / 255, g / 255, b / 255, a);\n\n            var features = aes.getFeatures();\n            var allFeatures = aes.getAllFeatures();\n            if (this.gisplayOptions.isDynamic && aes.getFeatures().length > 0) {\n                var _iteratorNormalCompletion14 = true;\n                var _didIteratorError14 = false;\n                var _iteratorError14 = undefined;\n\n                try {\n                    for (var _iterator14 = features[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                        var f = _step14.value;\n\n                        var points = f.getPoints();\n                        var _iteratorNormalCompletion15 = true;\n                        var _didIteratorError15 = false;\n                        var _iteratorError15 = undefined;\n\n                        try {\n                            for (var _iterator15 = points[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                                var p = _step15.value;\n\n                                gl.bindBuffer(gl.ARRAY_BUFFER, p);\n                                gl.enableVertexAttribArray(vertexCoordsLocation);\n                                gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                                gl.drawArrays(gl.POINTS, 0, p.numItems);\n                            }\n                        } catch (err) {\n                            _didIteratorError15 = true;\n                            _iteratorError15 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                                    _iterator15.return();\n                                }\n                            } finally {\n                                if (_didIteratorError15) {\n                                    throw _iteratorError15;\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError14 = true;\n                    _iteratorError14 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                            _iterator14.return();\n                        }\n                    } finally {\n                        if (_didIteratorError14) {\n                            throw _iteratorError14;\n                        }\n                    }\n                }\n            } else if (allFeatures !== null && !this.gisplayOptions.isDynamic) {\n                var _iteratorNormalCompletion16 = true;\n                var _didIteratorError16 = false;\n                var _iteratorError16 = undefined;\n\n                try {\n                    for (var _iterator16 = allFeatures[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                        var allF = _step16.value;\n\n                        var _points = allF.getPoints();\n                        var _iteratorNormalCompletion17 = true;\n                        var _didIteratorError17 = false;\n                        var _iteratorError17 = undefined;\n\n                        try {\n                            for (var _iterator17 = _points[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                                var _p = _step17.value;\n\n                                gl.bindBuffer(gl.ARRAY_BUFFER, _p);\n                                gl.enableVertexAttribArray(vertexCoordsLocation);\n                                gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                                gl.drawArrays(gl.POINTS, 0, _p.numItems);\n                            }\n                        } catch (err) {\n                            _didIteratorError17 = true;\n                            _iteratorError17 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion17 && _iterator17.return) {\n                                    _iterator17.return();\n                                }\n                            } finally {\n                                if (_didIteratorError17) {\n                                    throw _iteratorError17;\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError16 = true;\n                    _iteratorError16 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                            _iterator16.return();\n                        }\n                    } finally {\n                        if (_didIteratorError16) {\n                            throw _iteratorError16;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * M27) Receiving an Aesthetics object, draws the points contained in it's Features, \r\n         * aplying the color specified in the Aeshteic object for the line color(Aeshteic.strokeColor) \r\n         * and the size of the point is based on the attribute value and the specified limits.\r\n         * @param {Aesthetic} aes - The Aesthetic object. \r\n         * @returns {void} \r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'drawProportionalPoints',\n        value: function drawProportionalPoints(aes) {\n            var gl = this._webgl.gl;\n            if (gl === null) return;\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.bGMap.getZoom();\n            var vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, 'coords');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            var fragmentColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n\n            var _aes$getFillColor5 = aes.getFillColor(),\n                _aes$getFillColor6 = _slicedToArray(_aes$getFillColor5, 3),\n                r = _aes$getFillColor6[0],\n                g = _aes$getFillColor6[1],\n                b = _aes$getFillColor6[2];\n\n            this.setMatrices(gl);\n            gl.uniform1f(isPointLocation, 1.0);\n            gl.uniform4f(fragmentColorLocation, r / 255, g / 255, b / 255, this.gisplayOptions.alpha); //TODO: Para 2.5D usar alpha a 0?\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            var opts = this.gisplayOptions;\n            if (this.gisplayOptions.isDynamic) {\n                var features = aes.getFeatures();\n                var _iteratorNormalCompletion18 = true;\n                var _didIteratorError18 = false;\n                var _iteratorError18 = undefined;\n\n                try {\n                    for (var _iterator18 = features[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n                        var f = _step18.value;\n\n                        var propvalue = parseFloat(f.getProperties()[opts.attr]);\n                        var temppointsize = (opts.maxPointSize - opts.minPointSize) / (this.max - this.min) * (propvalue - this.min);\n                        var pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);\n\n                        var points = f.getPoints();\n                        var _iteratorNormalCompletion19 = true;\n                        var _didIteratorError19 = false;\n                        var _iteratorError19 = undefined;\n\n                        try {\n                            for (var _iterator19 = points[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n                                var p = _step19.value;\n\n                                gl.bindBuffer(gl.ARRAY_BUFFER, p);\n                                gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n                                gl.enableVertexAttribArray(vertexCoordsLocation);\n                                gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                                gl.drawArrays(gl.POINTS, 0, p.numItems);\n                            }\n                        } catch (err) {\n                            _didIteratorError19 = true;\n                            _iteratorError19 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion19 && _iterator19.return) {\n                                    _iterator19.return();\n                                }\n                            } finally {\n                                if (_didIteratorError19) {\n                                    throw _iteratorError19;\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError18 = true;\n                    _iteratorError18 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion18 && _iterator18.return) {\n                            _iterator18.return();\n                        }\n                    } finally {\n                        if (_didIteratorError18) {\n                            throw _iteratorError18;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * This method will set all matrices needed to compute each point/vertex position. This will use the \r\n         * Before sending the matrix to webGL we change the last column transformation in X and Y to the last row X and Y \r\n         * because WebGL is column major. See MMatrix[6] =...\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'setMatrices',\n        value: function setMatrices(gl) {\n            var lngCenter = this.bGMap.getCenterLng();\n            var latCenter = this.bGMap.getCenterLat();\n            var zoom = this.bGMap.getZoom();\n            var tileSize = this.gisplayOptions.tileSize;\n            var width = this.bGMap.getWidth();\n            var height = this.bGMap.getHeight();\n            /* if(window.first){\r\n                 console.log(\"HERE\")\r\n                 width = 2432;\r\n             }*/\n            var mercator = _WebGLUtils.WebGLUtils.webMercatorProjection(lngCenter, latCenter, zoom, tileSize, width, height);\n            /*  let M1Matrix = WebGLUtils.createM1(this._webgl.gl.drawingBufferWidth, this._webgl.gl.drawingBufferHeight); //TODO: This does not solve the resizing issue 100%.\r\n              let M2Matrix = WebGLUtils.createM2(mercator.scale, mercator.offsetX, mercator.offsetY);\r\n              let M3Matrix = WebGLUtils.createM3();\r\n                let M1xM2 = WebGLUtils.matrixMultiplication(M1Matrix, M2Matrix);\r\n              let MMatrix = WebGLUtils.matrixMultiplication(M1xM2, M3Matrix);\r\n              MMatrix[6] = MMatrix[2];\r\n              MMatrix[7] = MMatrix[5];\r\n              MMatrix[2] = 0;\r\n              MMatrix[5] = 0;*/\n            var MMatrix = _WebGLUtils.WebGLUtils.finalMatrix(mercator.scale, width, height, mercator.offsetX, mercator.offsetY);\n            var Mloc = gl.getUniformLocation(this._webgl.program, 'M');\n            gl.uniformMatrix3fv(Mloc, false, MMatrix);\n        }\n\n        /**\r\n         * M28) Scale matrix with the given x(scaleX) and y(scaleY) values.\r\n         * Scaling x and y, which is just scaling first two rows of matrix\r\n         * @param {Float32Array} matrix \r\n         * @param {number} scaleX - Scale in X axis.\r\n         * @param {number} scaleY - Scale in Y axis.\r\n         * @see http://www.c-jump.com/bcc/common/Talk3/Math/Matrices/const_images/applying_scaling.png\r\n         * @see http://ptgmedia.pearsoncmg.com/images/chap3_9780321902924/elementLinks/03fig27.jpg Remember WebGL is Column major\r\n         * @see http://prntscr.com/eononb\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'scaleProjection',\n        value: function scaleProjection(matrix, scaleX, scaleY) {\n            for (var i = 0; i < 8; i++) {\n                i < 4 ? matrix[i] *= scaleX : matrix[i] *= scaleY;\n            }\n        }\n\n        /**\r\n         * M29) The translation is performed in the last row of the matrix. \r\n         * @param {Float32Array} matrix - The matrix to hold the result.\r\n         * @param {number} tx - Translation in X axis.  \r\n         * @param {number} ty - Translation in Y axis.\r\n         * @see http://polymathprogrammer.com/images/blog/200809/translationmatrix.png\r\n         * @see http://prntscr.com/eononb\r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'translateProjection',\n        value: function translateProjection(matrix, tx, ty) {\n            for (var i = 0; i < 4; i++) {\n                matrix[i + 12] += matrix[i] * tx + matrix[i + 4] * ty;\n            }\n        }\n\n        /** ########################    ABSTRACT METHODS    ######################## */\n        /**\r\n         * M21) Draw map function. Must be overriden by subclasses.\r\n         * @abstract \r\n         */\n\n    }, {\n        key: 'draw',\n        value: function draw() {\n            throw new Error(\"Draw must be implemented by subclass.\");\n        }\n\n        /**\r\n         * M10) Defaults for each map. Subclasses should override this method.\r\n         * @param {any} defaultId \r\n         * @abstract \r\n         * @memberOf Map\r\n         */\n\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultId) {\n            throw new Error(\"This map has no defaults defined.\");\n        }\n\n        /**\r\n         * This function should be implemented by any subclass that wants to use another way of processing data.\r\n         * By default it loads GeoJSON but if the user wants to load another type of data it should do so by implementing this method.\r\n         * A function similar to loadGeoJSON should also be implemented\r\n         * @param {Object|JSON} data - Dataset to be used. \r\n         * TODO: Add static to this method.\r\n         * @abstract\r\n         */\n\n    }, {\n        key: 'processData',\n        value: function processData(data) {\n            this.loadGeoJSON(geojson);\n        }\n    }]);\n\n    return Map;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL01hcC5qcz8xZDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJHTWFwV3JhcHBlciB9IGZyb20gJy4vQkdNYXBXcmFwcGVyJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi9BZXN0aGV0aWMnO1xyXG5pbXBvcnQgeyBHaXNwbGF5T3B0aW9ucyB9IGZyb20gJy4uL0dpc3BsYXlPcHRpb25zJztcclxuaW1wb3J0IHsgV2ViR0xVdGlscyB9IGZyb20gJy4vV2ViR0xVdGlscyc7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjb250YWlucyB0aGUgTWFwIGNsYXNzIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbWFwLlxyXG4gKiBFYWNoIG1hcCBoYXMgYSBncm91cCBvZiBmdW5jdGlvbnMgYXZhaWxhYmxlLiBUaGVyZSBpcyBvbmx5IG9uZSBtYXAgeWV0KG1heWJlIHRoZXJlIHdpbGwgYmUgdHdvIGlmIHdlIHdhbnQgdG8gY29tcGFyZSB0d28pLlxyXG4gKiBAc2VlIERpb2dvJ3MgdGhlc2lzIDU3LTYwICsgNjQvNjVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYXAge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIGNvbnN0cnVjdG9yLiBBbGwgTWFwIHN1YmNsYXNzZXMgc2hvdWxkIGNhbGwgdGhpcyBmaXJzdCB3aXRoIHN1cGVyKC4uLikuXHJcbiAgICAgKiBAcGFyYW0ge0JHTWFwV3JhcHBlcnxPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gR2VvbWV0cnkgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zIC0gVGhlIHVzZXIgZGVmaW5lZCBvcHRpb25zLiBcclxuICAgICAqIEB0b2RvIFdpdGggdGhlIHR5cGUgb2YgdGhlIG1hcCB3ZSBjYW4gZG8gYW4gaWYgc3RhdGVtZW50IGluc2lkZSBjb25zdHJ1Y3RvciB0byB1c2Ugb3Igbm90IHNvbWUgb2YgdGhlIHZhcmlhYmxlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYmdtYXAsIGdlb21ldHJ5LCB1c2VyT3B0aW9ucykge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJNYXAgY29uc3RydWN0b3IgY2FsbGVkIC0+IHN1cGVyKClcIik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAqIFRoaXMgb2JqZWN0IGhvbGRzIGZvciBlYWNoIHBvaW50IGl0J3MgbG9uZywgbGF0IGFuZCBhc3NvY2lhdGVkIHByb3BlcnRpZXMuIFxyXG4gICAgICAgICAgKiBUaGlzIHBvaW50cyB3aWxsIGJlIHVzZWQgYnkgay1kIFRyZWUuIEFuZCBrLWQgVHJlZSBpcyB1c2VkIHRvIGZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgdG8gd2hlcmUgdGhlIHVzZXIgY2xpY2tlZC5cclxuICAgICAgICAgICogQHR5cGUge0FycmF5PHtsb246IG51bWJlciwgbGF0OiBudW1iZXIsIHByb3BlcnRpZXM6IEpTT059Pn1cclxuICAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50cmVlcG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIERPVCBNQVAgT05MWVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgKiBIb2xkcyB0aGUgcG9pbnRzIGZvciBlYWNoIEFlc3RoZXRoaWMgb2JqZWN0LlxyXG4gICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59XHJcbiAgICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGVtcEFlc3RoZXRpY1BvaW50cyA9IG5ldyBBcnJheSgpO1xyXG5cclxuICAgICAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBBTEwgTUFQU1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFlc3RoZXRpYyBvYmplY3RzIHRoYXQgd2VyZSBzYXZlZC5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QWVzdGhldGljPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBKU09OIG9iamVjdCB3aXRoIHRoZSBnZW9tZXRyeSB0aGF0IHdhcyByZWFkIGZyb20gdGhlIGZpbGUuXHJcbiAgICAgICAgICogQHR5cGUge0pTT059XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWFwIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IHdpbmRvdy5tYXBjb3VudCsrO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZFRyZWUgb2JqZWN0IHRvIGhvbGQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBjbG9zZXN0IHBvaW50IHRvIHRoZSBjb29yZGluYXRlcyB3aGVyZSB0aGUgdXNlciBtYWRlIGEgY2xpY2suXHJcbiAgICAgICAgICogQHR5cGUge2tkVHJlZX1cclxuICAgICAgICAgKiBAc2VlIERpb2dvJ3MgdGhlc2lzIFBhZ2UgNjEuXHJcbiAgICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdWJpbGFicy9rZC10cmVlLWphdmFzY3JpcHRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtkdHJlZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSQnVzaChSdHJlZSBpbXBsZW1lbnRhdGlvbikgdGhhdCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9seWdvbiBjbG9zZXN0IHRvIHRoZSBjb29yZGluYXRlcyB3aGVyZSB0aGUgdXNlciBtYWRlIGEgY2xpY2suXHJcbiAgICAgICAgICogQHR5cGUge1BvbHlnb25Mb29rdXB9XHJcbiAgICAgICAgICogQHNlZSBEaW9nbydzIHRoZXNpcyBwYWdlIDYxLlxyXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BlbGlhcy9wb2x5Z29uLWxvb2t1cFxyXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2hcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJ0cmVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvbHlnb25zIGRvL2RvIG5vdCBleGlzdC4gVGhpcyBpcyB1c2VkIHRvIGtub3cgaWYgaXQgdG8gY3JlYXRlIGEgcnRyZWUgb3Igbm90IG9uIGJ1aWxkVHJlZXMgbWV0aG9kLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFzUG9seWdvbnMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWFpeG11bSB2YWx1ZSBmb3VuZCBvbiB0aGUgZGF0YXNldC4gVGhlIGZpbmFsIHZhbHVlIGZvciB0aGUgYnJlYWsuIEUuZy4gWzIsIDM3WyAzNyBpcyB0aGUgbWF4LiBcclxuICAgICAgICAgKiBVc2VkIGZvciBQU3ltYm9sIE1hcCBhbmQgQ2hhbmdlIE1hcCBiZWNhdXNlIG9uIHRob3NlIG1hcHMgaXQncyBpbXBvcnRhbnQgdG8gdGFrZSBpbiBjb25zaWRlcmF0aW9uIHRoaXMgdmFsdWVzIHRvIGRlZmluZSB0aGUgRmVhdHVyZSBjb2xvci5cclxuICAgICAgICAgKiBAc2VlIERpb2dvJ3MgdGhlc2lzIHBhZ2UgNjMgNS4xLjMgXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1heCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWluaW11bSB2YWx1ZSBmb3VuZCBvbiB0aGUgZGF0YXNldC4gVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBicmVhay4gRS5nLiBbMiwgMzdbIDIgaXMgdGhlIG1pbi5cclxuICAgICAgICAgKiBVc2VkIGZvciBQU3ltYm9sIE1hcCBhbmQgQ2hhbmdlIE1hcCBiZWNhdXNlIG9uIHRob3NlIG1hcHMgaXQncyBpbXBvcnRhbnQgdG8gdGFrZSBpbiBjb25zaWRlcmF0aW9uIHRoaXMgdmFsdWVzIHRvIGRlZmluZSB0aGUgRmVhdHVyZSBjb2xvci5cclxuICAgICAgICAgKiBAc2VlIERpb2dvJ3MgdGhlc2lzIHBhZ2UgNjMgNS4xLjNcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0xKSBMb2FkcyB1c2VyIGFuZCBkZWZhdWx0IG9wdGlvbnMuIEZvciBlYWNoIGNhc2UgaWYgaXQgaXNuJ3QgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIHRoZW4gaXQgdXNlc1xyXG4gICAgICogdGhlIGRlZmF1bHQgb3B0aW9uLiAxc3QgbWV0aG9kIHRvIGJlIGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9ucyAtIE9wdGlvbnMgZ2l2ZW4gYnkgdGhlIHVzZXIuIFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwICAtIFRoZSBiYWNrZ3JvdW5kIG1hcCBwcm92aWRlci5cclxuICAgICAqL1xyXG4gICAgbG9hZE9wdGlvbnModXNlck9wdGlvbnMsIGJnbWFwKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBpbiB0aGUgR2lzcGxheSBBUEkuXHJcbiAgICAgICAgICogQHR5cGUge0dpc3BsYXlPcHRpb25zfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2lzcGxheU9wdGlvbnMgPSBuZXcgR2lzcGxheU9wdGlvbnModXNlck9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBHaXNwbGF5IEFQSSBCYWNrZ3JvdW5kIG1hcCB3cmFwcGVyLiBJdCBjb250YWlucyB0aGUgYmFja2dyb3VuZCBtYXAgcHJvdmlkZXIgb2JqZWN0IHRvIGFjY2VzcyBpdCdzIG1ldGhvZHMgKHpvb20sIGNvb3JkaW5hdGVzLGV0YykuXHJcbiAgICAgICAgICogVGhpcyBtYXAoR2lzcGxheSBNYXApIHdpbGwgIGJlIGRyYXduIG92ZXIgdGhlIGJhY2tncm91bmQgbWFwKGJHTWFwKS5cclxuICAgICAgICAgKiBAdHlwZSB7QkdNYXBXcmFwcGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYkdNYXAgPSB0aGlzLmdpc3BsYXlPcHRpb25zLnVzZUN1c3RvbU1hcFNlcnZpY2UgPyBiZ21hcCA6IG5ldyBCR01hcFdyYXBwZXIoYmdtYXApO1xyXG4gICAgICAgIGlmICh0aGlzLmdpc3BsYXlPcHRpb25zLnNob3dMb2FkZXIpXHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvYWRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTIpIENhbGxzIHRoZSBCYWNrZ3JvdW5kIE1hcCBXcmFwcGVyIHRvIGNyZWF0ZSB0aGUgbG9hZGVyIHRvIGJlIHVzZWQgbGF0ZXIgd2hlbiB0aGUgdXNlciBmZWVkcyBkYXRhIHRvIHRoZSBBUEkuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBOb3QgdXNlZCBhbnltb3JlXHJcbiAgICAgKi9cclxuICAgIHNob3dMb2FkZXIoKSB7XHJcbiAgICAgICAgdGhpcy5iR01hcC5zaG93TG9hZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNMykgSW5pdGlhbGl6ZXMgdGhlIEFQSSBieTogY3JlYXRpbmcgY2FudmFzLCB0aGUgV2ViR0wgcHJvZ3JhbSBhbmQgc2V0dGluZyB1cCBhbGwgbmVlZGVkIGV2ZW50cy5cclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxpemVDYW52YXNBbmRFdmVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcclxuICAgICAgICBXZWJHTFV0aWxzLmNyZWF0ZVdlYkdMUHJvZ3JhbSh0aGlzLl93ZWJnbCk7XHJcbiAgICAgICAgdGhpcy5zZXR1cEV2ZW50cyh0aGlzLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE00KSBDcmVhdGVzIGEgY2FudmFzIGVsZW1lbnQgYW5kIFdlYkdMIGFzc29jaWF0ZWQgaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNhbnZhcygpIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmJHTWFwLmNyZWF0ZUNhbnZhcyh0aGlzLmlkKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH0gX3dlYmdsIC0gV2ViR0wgb2JqZWN0LiAgSW5pdCB3ZWJnbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICogQHByb3BlcnR5ICB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBfd2ViZ2wuZ2wgLSBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIGJlIHVzZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5ICB7V2ViR0xQcm9ncmFtfSBfd2ViZ2wucHJvZ3JhbSAtICBUaGUgV2ViR0xQcm9ncmFtIHRvIGJlIHVzZWQuIFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSAge0Zsb2F0MzJBcnJheX0gX3dlYmdsLnByb2plY3Rpb24gLSBUaGUgcHJvamVjdGlvbiB0byBiZSB1c2VkLiBEZXByZWNhdGVkIGluIGZhdm9yIG9mIGJldHRlciBwcm9qZWN0aW9uIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBtYXAgYmFja2dyb3VuZCBwcm92aWRlcnMuXHJcbiAgICAgICAgICogQHNlZSBEaW9nbydzIHRoZXNpcyBwYWdlIDY0K1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3dlYmdsID0ge1xyXG4gICAgICAgICAgICBnbDogbnVsbCxcclxuICAgICAgICAgICAgcHJvZ3JhbTogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcclxuICAgICAgICB3aW5kb3cuY2FudmFzID0gY2FudmFzO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuYkdNYXAuZ2V0Q29udGFpbmVyKCkub2Zmc2V0V2lkdGgsIHRoaXMuYkdNYXAuZ2V0Q29udGFpbmVyKCkub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5kaXNhYmxlKHRoaXMuX3dlYmdsLmdsLkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTgpIFNldHVwIGFsbCBldmVudHMgdXNlZCBieSB0aGUgQVBJLiBSaWdodCBub3cgdGhlIEFQSSB1c2VzOiBkcmFnLCB6b29tIGFuZCBjbGljayBldmVudHMuIFxyXG4gICAgICogVGhpcyBldmVudHMgd2lsbCBiZSBmaXJlZCBieSB0aGUgYmFja2dyb3VuZCBtYXAgcHJvdmlkZXIgYW5kIHdlIGNhbiB1c2UgdGhlbSB0byBkcmF3KHpvb20gYW5kIHBhbikgb3IgYWxlcnQgaW5mb3JtYXRpb24oY2xpY2spLlxyXG4gICAgICogUGFuL1pvb20gPSBtb3ZlLCBjbGljayA9IGNsaWNrXHJcbiAgICAgKiBydHJlZSB3aWxsIGJlIHVzZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBwb2x5Z29uIHRvIHRoZSB3aGVyZSB0aGUgY2xpY2tlZCBldmVudCBoYXBwZW5lZC5cclxuICAgICAqIGtkdHJlZSB3aWxsIGJlIHVzZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBwb2ludCB0byB3aGVyZSB0aGUgY2xpY2sgZXZlbnQgaGFwcGVuZWQuXHJcbiAgICAgKiBAdG9kbyBUaGlzIG1ldGhvZCBpcyBkb2luZyB1bmVjY2Vzc2FyeSBqb2IgaWYgdGhlIHVzZXIgc2V0IGludGVyYXRpdmUgdG8gZmFsc2UgYW5kIG1hcE9uQ2xpY2tGdW5jdGlvbiBpcyB1bmRlZmluZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFwcG9zIC0gVGhpcyBtYXAgaWQuIFxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqIEBzZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNldmVudHNcclxuICAgICAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQzNDk3MzdcclxuICAgICAqL1xyXG4gICAgc2V0dXBFdmVudHMobWFwcG9zKSB7XHJcbiAgICAgICAgLyppZighdGhpcy5naXNwbGF5T3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLmdpc3BsYXlPcHRpb25zLm1hcE9uQ2xpY2tGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm47Ki9cclxuICAgICAgICB0aGlzLmJHTWFwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdmUnLCAoKSA9PiB7IHRoaXMuZHJhdygpOyB9KTtcclxuICAgICAgICB0aGlzLmJHTWFwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7IC8vVE9ETzogQ3JlYXRlIDIgbWV0aG9kcyAoMSBmb3IgcnRyZWUgYW5vdGhlciBmb3Iga2R0cmVlKVxyXG4gICAgICAgICAgICBjb25zdCBsbmcgPSAoKCgoMTgwICsgZS5sYXRsbmcubG5nKSAlIDM2MCkgKyAzNjApICUgMzYwKSAtIDE4MDtcclxuICAgICAgICAgICAgY29uc3QgbGF0ID0gZS5sYXRsbmcubGF0O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hlbiBkZWFsaW5nIHdpdGggcG9seWdvbnMgcnRyZWUgd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgKiBAc2VlIERpb2dvJ3MgdGhlc2lzIFBhZ2UgNjJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ0cmVlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFJUcmVlKGxuZywgbGF0KTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGVuIGRlYWxpbmcgd2l0aCBwb2ludHMga2R0cmVlIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgICAgICogQHNlZSBEaW9nbydzIHRoZXNpcyBwYWdlIDYyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5rZHRyZWUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoS2RUcmVlKGxuZywgbGF0KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2ggdGhlIHJ0cmVlIGZvciB0aGUgY2xvc2VzdCBwb2x5Z29uIGZyb20gdGhlIGxuZywgbGF0IHRoYXQgd2FzIGNsaWNrZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG5nIC0gVGhlIGxvbmdpdHVkZSBvZiB0aGUgY2xpY2suXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF0IC0gVGhlIGxhdGl0dWRlIG9mIHRoZSBjbGljay5cclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHNlYXJjaFJUcmVlKGxuZywgbGF0KSB7XHJcbiAgICAgICAgbGV0IHJ0cmVlU2VhcmNoUmVzdWx0ID0gdGhpcy5ydHJlZS5zZWFyY2gobG5nLCBsYXQpO1xyXG4gICAgICAgIGlmIChydHJlZVNlYXJjaFJlc3VsdCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCByZXMgPSBcIlwiO1xyXG4gICAgICAgICAgICBsZXQgc2hvd1BydE9uQ2xpY2sgPSB0aGlzLmdpc3BsYXlPcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljaztcclxuICAgICAgICAgICAgaWYgKHNob3dQcnRPbkNsaWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3dQcnRPbkNsaWNrLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBgJHtzaG93UHJ0T25DbGlja1tpICsgMV19OiAke3J0cmVlU2VhcmNoUmVzdWx0LnByb3BlcnRpZXNbc2hvd1BydE9uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gYFxcbiR7c2hvd1BydE9uQ2xpY2tbaSArIDFdfTogJHtydHJlZVNlYXJjaFJlc3VsdC5wcm9wZXJ0aWVzW3Nob3dQcnRPbkNsaWNrW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhydHJlZVNlYXJjaFJlc3VsdC5wcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IFtpLCBrZXldIG9mIGtleXMuZW50cmllcygpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiX2dpc3BsYXlpZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID09IDAgPyByZXMgKz0gYCR7a2V5fTogJHtydHJlZVNlYXJjaFJlc3VsdC5wcm9wZXJ0aWVzW2tleV19YCA6IHJlcyArPSBgXFxuJHtrZXl9OiAke3J0cmVlU2VhcmNoUmVzdWx0LnByb3BlcnRpZXNba2V5XX1gO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5naXNwbGF5T3B0aW9ucy5pbnRlcmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgIGFsZXJ0KHJlcyk7Ly90b2RvXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdpc3BsYXlPcHRpb25zLm1hcE9uQ2xpY2tGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5naXNwbGF5T3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb24ocnRyZWVTZWFyY2hSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCB0aGUgcnRyZWUgZm9yIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gdGhlIGxuZywgbGF0IHRoYXQgd2FzIGNsaWNrZWQuIFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvbiAtIFRoZSBsb25naXR1ZGUgb2YgdGhlIGNsaWNrLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdCAtIFRoZSBsYXRpdHVkZSBvZiB0aGUgY2xpY2suXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqIEBtZW1iZXJPZiBNYXBcclxuICAgICAqL1xyXG4gICAgc2VhcmNoS2RUcmVlKGxvbiwgbGF0KSB7XHJcbiAgICAgICAgbGV0IG5lYXJlc3QgPSB0aGlzLmtkdHJlZS5uZWFyZXN0KHsgbG9uLCBsYXQgfSwgMSwgMTI4IC8gKCgyICoqICh0aGlzLmJHTWFwLmdldFpvb20oKSAqIDIpKSkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiMjFcIiwgbmVhcmVzdClcclxuICAgICAgICBpZiAobmVhcmVzdC5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIjIyXCIpXHJcbiAgICAgICAgICAgIGxldCBrZFRyZWVTZWFyY2hSZXN1bHQgPSBuZWFyZXN0WzBdWzBdO1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gXCJcIjtcclxuICAgICAgICAgICAgbGV0IHNob3dQcnRPbkNsaWNrID0gdGhpcy5naXNwbGF5T3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2s7XHJcbiAgICAgICAgICAgIGlmIChzaG93UHJ0T25DbGljayAhPT0gbnVsbCkgeyAvL1RPRE86IFJlbW92ZSBpZiBkZW50cm8gZG8gZm9yIGUgcGFzc2FyIGEgY29tZcOnYXIgbm8gaT0xIGUgcGFzc2FyIG8gaWYgcGFyYSBhbnRlcyBkbyBmb3JcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hvd1BydE9uQ2xpY2subGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGAke3Nob3dQcnRPbkNsaWNrW2kgKyAxXX06ICR7a2RUcmVlU2VhcmNoUmVzdWx0LnByb3BlcnRpZXNbc2hvd1BydE9uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gYFxcbiR7c2hvd1BydE9uQ2xpY2tbaSArIDFdfTogJHtrZFRyZWVTZWFyY2hSZXN1bHQucHJvcGVydGllc1tzaG93UHJ0T25DbGlja1tpXV19YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoa2RUcmVlU2VhcmNoUmVzdWx0LnByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2ksIGtleV0gb2Yga2V5cy5lbnRyaWVzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJfZ2lzcGxheWlkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPT0gMCA/IHJlcyArPSBgJHtrZXl9OiAke2tkVHJlZVNlYXJjaFJlc3VsdC5wcm9wZXJ0aWVzW2tleV19YCA6IHJlcyArPSBgXFxuJHtrZXl9OiAke2tkVHJlZVNlYXJjaFJlc3VsdC5wcm9wZXJ0aWVzW2tleV19YDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2lzcGxheU9wdGlvbnMuaW50ZXJhY3RpdmUpXHJcbiAgICAgICAgICAgICAgICBhbGVydChyZXMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5naXNwbGF5T3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb24gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2lzcGxheU9wdGlvbnMubWFwT25DbGlja0Z1bmN0aW9uKGtkVHJlZVNlYXJjaFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICBNRVRIT0QgZnJvbSBHaXNwbGF5LmpzICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBNOSkgTWV0aG9kIHRoYXQgZXhlY3V0ZXMgYWxsIHRoZSBwcm9jZXNzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3JlYXRpb24gb2YgdGhlIHRoZW1hdGljIG1hcC5cclxuICAgICAqIEBtZW1iZXJPZiBNYXBcclxuICAgICAqL1xyXG4gICAgbWFrZU1hcCgpIHtcclxuICAgICAgICBsZXQgb3B0cyA9IHRoaXMuZ2lzcGxheU9wdGlvbnM7XHJcbiAgICAgICAgc2V0VGltZW91dChjb25zb2xlID0+IHtcclxuICAgICAgICAgICAgaWYgKG9wdHMuY29sb3JTY2hlbWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3JTY2hlbWUgPSB0aGlzLmRlZmF1bHRzKG9wdHMuY29sb3JTY2hlbWVJZCkuY29sb3JTY2hlbWU7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmNsYXNzQnJlYWtzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRzLm51bWJlck9mQ2xhc3NlcyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMubnVtYmVyT2ZDbGFzc2VzID0gdGhpcy5kZWZhdWx0cyhvcHRzLmNvbG9yU2NoZW1lSWQpLm51bWJlck9mQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlUHJvY2Vzc0RhdGEodGhpcy5nZW9tZXRyeSwgb3B0cy5udW1iZXJPZkNsYXNzZXMsIG9wdHMuY2xhc3NCcmVha3NNZXRob2QsIG9wdHMuY29sb3JTY2hlbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvYWRHZW9KU09OKHRoaXMuZ2VvbWV0cnkpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRzLnNob3dMZWdlbmQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkTGVnZW5kKCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLnNob3dMb2FkZXIpIC8vQFRPRE86IENoYW5nZSB0aGlzIGlmIHRvIGJlIHRoZSAxc3QgdGhpbmcgZG9uZSBpbnNpZGUgdGhlIHNldFRpbWVvdXRcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0xvYWRlcigpO1xyXG4gICAgICAgIH0sIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTExKSBDcmVhdGVzIEFlc3RoZXRpYyBvYmplY3RzLiBJZiB0aGVyZSdzIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgY2xhc3MgaW50ZXJ2YWxzLFxyXG4gICAgICogdGhlIG1ldGhvZCBjYWxjQ2xhc3NCcmVha3MgaXMgY2FsbGVkIFxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9qc29uIC0gR2VvSlNPTiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZDbGFzc2VzIC0gTnVtYmVyIG9mIGNsYXNzZXMgdGhhdCB0aGUgTGVnZW5kIHdpbGwgY29udGFpbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc0JyZWFrc01ldGhvZCAtIEFsZ29yaXRobSB0byBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBjbGFzcyBicmVha3MuIE9ubHkgdXNlZCBpdCBjbGFzcyBicmVha3MgYXJlIG5vdCBnaXZlbiBieSB0aGUgdXNlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbG9yc2NoZW1lIC0gQ29sb3Igc2NoZW1lIHRvIGJlIHVzZWQgYnkgdGhpcyBtYXAuXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHByZVByb2Nlc3NEYXRhKGdlb2pzb24sIG51bWJlck9mQ2xhc3NlcywgY2xhc3NCcmVha3NNZXRob2QsIGNvbG9yc2NoZW1lKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEFlc3RoZXRpYz59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgYWVzYXJyYXkgPSBbXTsgLy9BcnJheSBvZiBhZXN0aGV0aWMgb2JqZWN0cyBsb2FkZWQgZnJvbSB0aGUgZmlsZVxyXG4gICAgICAgIGNvbnN0IG51bWJlclZhbHVlcyA9IFtdOyAvL1RoZSBhdHRyIGlzIGEgbnVtYmVyXHJcbiAgICAgICAgY29uc3Qgc3RyaW5nVmFsdWVzID0gW107IC8vVGhlIGF0dHIgaXMgYSBzdHJpbmdcclxuICAgICAgICBsZXQgY2xhc3NCcmVha3M7IC8vQ2xhc3MgQnJlYWtzIGdpdmVuIGJ5IHRoZSB1c2VyIG9yIGNhbGN1bGF0ZWQgYnkgdGhlIEFQSVxyXG4gICAgICAgIGxldCBmY29sb3I7IC8vQ29sb3JzIHRvIGJlIHVzZWRcclxuICAgICAgICBsZXQgb3B0cyA9IHRoaXMuZ2lzcGxheU9wdGlvbnM7IC8vT3B0aW9ucyBnaXZlbiBieSB0aGUgdXNlciBhbmQgZGVmYXVsdHNcclxuXHJcbiAgICAgICAgbGV0IGdlb0pzb25GZWF0dXJlc0xlbmd0aCA9IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvSnNvbkZlYXR1cmVzTGVuZ3RoICYmIChpIDwgb3B0cy5tYXhGZWF0dXJlcyk7IGkrKykgeyAvL0BUT0RPPzogVHdvIGZvcnMgb25lIGlmIGF0dHIgaXMgYSBzdHJpbmcgYW5vdGhlciBpZiBpdCBhIG51bWJlclxyXG4gICAgICAgICAgICBsZXQgYXR0clZhbHVlID0gZ2VvanNvbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzW29wdHMuYXR0cl07XHJcbiAgICAgICAgICAgIGlmIChhdHRyVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ251bWJlcicpIHsgLy9JZiBcImYzXCIgZXhpc3RzIGFuZCBpdHMgYSBudW1iZXJcclxuICAgICAgICAgICAgICAgIG51bWJlclZhbHVlcy5wdXNoKGF0dHJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCBhdHRyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbih0aGlzLm1pbiwgYXR0clZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghc3RyaW5nVmFsdWVzLmluY2x1ZGVzKGF0dHJWYWx1ZSkpIC8vSWYgaXRzIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZXMucHVzaChnZW9qc29uLmZlYXR1cmVzW2ldLnByb3BlcnRpZXNbb3B0cy5hdHRyXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobnVtYmVyVmFsdWVzLmxlbmd0aCA+IDApIHsgLy9RdWFudGl0YXRpdmVcclxuICAgICAgICAgICAgaWYgKG9wdHMuY2xhc3NCcmVha3MgPT09IHVuZGVmaW5lZCkgeyAvL05vdCBnaXZlbiBieSB0aGUgdXNlciB0aGVuIGNhbGN1bGF0ZSB0aGVtXHJcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyT2ZDbGFzc2VzID4gMSlcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc0JyZWFrcyA9IHRoaXMuY2FsY0NsYXNzQnJlYWtzKG51bWJlclZhbHVlcywgY2xhc3NCcmVha3NNZXRob2QsIG51bWJlck9mQ2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NCcmVha3MgPSBbdGhpcy5taW4sIHRoaXMubWF4XTsgLy9DaGFuZ2UgTWFwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSAvL0dpdmVuIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICAgICAgICBjbGFzc0JyZWFrcyA9IG9wdHMuY2xhc3NCcmVha3M7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2xhc3NCcmVha3MubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKS5jb2xvcnMoY2xhc3NCcmVha3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzQnJlYWtzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBbciwgZywgYl0gPSBjaHJvbWEoZmNvbG9yW2ldKS5yZ2IoKTsgLy8gbGV0IGNvbG9yID0gY2hyb21hKGZjb2xvcltpXSkucmdiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFlcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gY2xhc3NCcmVha3MubGVuZ3RoIC0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCBvcHRzLmF0dHIsIFtNYXRoLnJvdW5kKHIpLCBNYXRoLnJvdW5kKGcpLCBNYXRoLnJvdW5kKGIpLCBvcHRzLmFscGhhXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbY2xhc3NCcmVha3NbaV0sIGNsYXNzQnJlYWtzW2kgKyAxXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZXMgPSBuZXcgQWVzdGhldGljKGksIG9wdHMuYXR0ciwgW01hdGgucm91bmQociksIE1hdGgucm91bmQoZyksIE1hdGgucm91bmQoYiksIG9wdHMuYWxwaGFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFtjbGFzc0JyZWFrc1tpXSwgY2xhc3NCcmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFlcy5vdXRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFlc2FycmF5LnB1c2goYWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBbciwgZywgYl0gPSBjaHJvbWEoY29sb3JzY2hlbWVbMF0pLnJnYigpOy8vIGxldCBjb2xvciA9IGNocm9tYShjb2xvcnNjaGVtZVswXSkucmdiKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWVzID0gbmV3IEFlc3RoZXRpYygwLCBvcHRzLmF0dHIsIFtNYXRoLnJvdW5kKHIpLCBNYXRoLnJvdW5kKGcpLCBNYXRoLnJvdW5kKGIpLCBvcHRzLmFscGhhXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbY2xhc3NCcmVha3NbMF0sIGNsYXNzQnJlYWtzWzFdXSk7XHJcbiAgICAgICAgICAgICAgICBhZXMub3V0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYWVzYXJyYXkucHVzaChhZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvL1F1YWxpdGF0aXZlXHJcbiAgICAgICAgICAgIGlmIChzdHJpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NCcmVha3MgPSBzdHJpbmdWYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yc2NoZW1lID09PSAnc3RyaW5nJykgLy9zdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBmY29sb3IgPSBjaHJvbWEuc2NhbGUoY29sb3JzY2hlbWUpLmNvbG9ycyhjbGFzc0JyZWFrcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSAgLy9hcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGZjb2xvciA9IGNocm9tYS5zY2FsZShjb2xvcnNjaGVtZSkuY29sb3JzKGNsYXNzQnJlYWtzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0JyZWFrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBbciwgZywgYl0gPSBjaHJvbWEoZmNvbG9yW2ldKS5yZ2IoKTsvLyBsZXQgY29sb3IgPSBjaHJvbWEoZmNvbG9yW2ldKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCBvcHRzLmF0dHIsIFtNYXRoLnJvdW5kKHIpLCBNYXRoLnJvdW5kKGcpLCBNYXRoLnJvdW5kKGIpLCAxXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbc3RyaW5nVmFsdWVzW2ldXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWVzYXJyYXkucHVzaChhZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGwgdGhlIEFlc3RoZXRpY3MgdGhhdCB3ZXJlIHJlYWQgZnJvbSB0aGUgR2VvSlNPTiBmaWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxBZXN0aGV0aWM+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IGFlc2FycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTEyKSBDYWxjdWxhdGVzIHRoZSBjbGFzcyBicmVha3MgdXNpbmcgdGhlIGFsZ29yaXRobSBnaXZlbihrLW1lYW5zLCBxdWFudGlsZSBvciBlcXVpZGlzdGFudCkuIFxyXG4gICAgICogVGhlcmUgd2lsbCBiZSBhcyBtYW55IGNsYXNzIGJyZWFrcyBhcyBudW1iZXIgb2YgY2xhc3NlcyhudW1iZXJPZkNsYXNzZXMpIGdpdmVuIGFzIGlucHV0LiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG51bWJlclZhbHVlcyAtIFRoZSBkYXRhIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBiZSBjb21wdXRlIHRoZSBicmVha3MuIFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzQnJlYWtNZXRob2QgLSBUaGUgYWxnb3JpdGhtIHRvIHVzZSB0byBjYWxjdWxhdGUgdGhlIGNsYXNzIGJyZWFrcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkNsYXNzZXMgLSBOdW1iZXIgb2YgY2xhc3NlcyB0aGUgcmVzdWx0IGV4cGVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gVGhlIGNsYXNzIGJyZWFrcyByZXN1bHRpbmcgZnJvbSB0aGUgdXNlIG9mIHRoZSBnaXZlbiBhbGdvcml0aG0gYW5kIHRoZSBudW1iZXIgb2YgY2xhc3Nlcy5cclxuICAgICAqIEBzZWUgaHR0cDovL2drYS5naXRodWIuaW8vY2hyb21hLmpzLyNjaHJvbWEtbGltaXRzXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIGNhbGNDbGFzc0JyZWFrcyhudW1iZXJWYWx1ZXMsIGNsYXNzQnJlYWtNZXRob2QsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgIGxldCBjbGFzc0JyZWFrcztcclxuICAgICAgICBzd2l0Y2ggKGNsYXNzQnJlYWtNZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSAnZXF1aWRpc3RhbnQnOlxyXG4gICAgICAgICAgICAgICAgY2xhc3NCcmVha3MgPSBjaHJvbWEubGltaXRzKG51bWJlclZhbHVlcywgJ2UnLCBudW1iZXJPZkNsYXNzZXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdxdWFudGlsZSc6XHJcbiAgICAgICAgICAgICAgICBjbGFzc0JyZWFrcyA9IGNocm9tYS5saW1pdHMobnVtYmVyVmFsdWVzLCAncScsIG51bWJlck9mQ2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2stbWVhbnMnOlxyXG4gICAgICAgICAgICAgICAgY2xhc3NCcmVha3MgPSBjaHJvbWEubGltaXRzKG51bWJlclZhbHVlcywgJ2snLCBudW1iZXJPZkNsYXNzZXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY2xhc3NCcmVha3MgPSBjaHJvbWEubGltaXRzKG51bWJlclZhbHVlcywgJ3EnLCBudW1iZXJPZkNsYXNzZXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc0JyZWFrcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0xMykgTG9hZHMgR2VvSlNPTiBvYmplY3QgdGhhdCBjYW1lIGZyb20gdGhlIGZpbGUgdXBsb2FkZWQgYnkgdGhlIHVzZXIuIFxyXG4gICAgICogRXh0cmFjdHMgdGhlIEZlYXR1cmVzIHByZXNlbnQgaW4gdGhlIGdlb21ldHJ5IG9iamVjdCBhbmQgaW5zZXJ0cyB0aGVtIGluIEFlc3RoZXRpYyBvYmplY3QocylcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY3JlYXRlIGFuZCBpbnNlcnQgZmVhdHVyZXMgdG8gQWVzdGhldGljIG9iamVjdHMgYW5kIGJ1aWxkIHRyZWVzIG9mIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBwb2ludHMgb3IgcG9seWdvbnMuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb2pzb24gLSBHZW9KU09OIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly93d3cuZGFzaGluZ2QzanMuY29tL2xlc3NvbnMvZ2VvanNvblxyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBsb2FkR2VvSlNPTihnZW9qc29uKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCAmJiAodGhpcy5naXNwbGF5T3B0aW9ucy5tYXhGZWF0dXJlcyA9PT0gdW5kZWZpbmVkIHx8IGkgPCB0aGlzLmdpc3BsYXlPcHRpb25zLm1heEZlYXR1cmVzKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGdlb2pzb24uZmVhdHVyZXNbaV0ucHJvcGVydGllc1snX2dpc3BsYXlpZCddID0gaTtcclxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2VvanNvbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZEluc2VydEZlYXR1cmUoaSwgZ2VvbWV0cnksIHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1aWxkVHJlZXMoZ2VvanNvbik7IC8vQFRPRE86IE9ubHkgY2FsbCB0aGlzIG1ldGhvZCBpZiBpdCdzIGEgbG93IGVuZCBkZXZpY2UgYWthIG9wdGlvbnMubWVtb3J5U2F2ZXIgaXMgb25cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0xNCkgQ3JlYXRlcyBhIEZlYXR1cmUgYW5kIHRoZW4gY2FsbHMgYSBtZXRob2QgdG8gaW5zZXJ0IHNhaWQgRmVhdHVyZSBpbiBvbmUgb3IgbW9yZSBBZXN0aGV0aWMgb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSWQgLSBJZCBvZiB0aGUgRmVhdHVyZS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBHZW9KU09OIEdlb21ldHJ5IE9iamVjdC4gXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IHByb3BlcnRpZXMgLSBHZW9KU09OIHByb3BlcnRpZXMgT2JqZWN0LlxyXG4gICAgICogQHNlZSBodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWwjZ2VvbWV0cnktb2JqZWN0c1xyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVBbmRJbnNlcnRGZWF0dXJlKGZlYXR1cmVJZCwgZ2VvbWV0cnksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtHaXNwbGF5T3B0aW9uc31cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgb3B0cyA9IHRoaXMuZ2lzcGxheU9wdGlvbnM7XHJcbiAgICAgICAgaWYgKG9wdHMubWludWVuZCAhPT0gdW5kZWZpbmVkICYmIG9wdHMuc3VidHJhaGVuZCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiBwcm9wZXJ0aWVzW29wdHMubWludWVuZF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBwcm9wZXJ0aWVzW29wdHMuc3VidHJhaGVuZF0gPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICYmIHByb3BlcnRpZXNbb3B0cy5taW51ZW5kXSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXNbb3B0cy5zdWJ0cmFoZW5kXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXNbb3B0cy5hdHRyXSA9IHByb3BlcnRpZXNbb3B0cy5taW51ZW5kXSAtIHByb3BlcnRpZXNbb3B0cy5zdWJ0cmFoZW5kXTsgLy9Vc2VkIGZvciBDaGFuZ2UgbWFwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xldCBpc1BvaW50ID0gZ2VvbWV0cnkudHlwZSA9PSBcIlBvaW50XCI7XHJcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiUG9seWdvblwiIHx8IGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNQb2x5Z29ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb25zID0gdGhpcy5wcm9jZXNzUG9seWdvbih7IGdlb21ldHJ5LCBwcm9wZXJ0aWVzIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRyaWFuZ2xlcyA9IFtdOyAvL1BvbHlnb24gVHJpYW5nbGVzIHZlcnRpY2VzXHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclQgPSBbXTsgLy9XZWJHTCBCdWZmZXJzIHdpdGggIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Qm9yZGVycyA9IFtdOyAvL1BvbHlnb24gQm9yZGVycyB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJCID0gW107IC8vQnVmZmVyIGJvcmRlcnNcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHsgLy9Gb3IgZWFjaCBQb2x5Z29uXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmlhbmdsZXNQb2x5Z29uID0gcG9seWdvbnNbaV0udHJpYW5nbGVzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyID0gcG9seWdvbnNbaV0udmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJpYW5nbGVzW2ldID0gbmV3IEFycmF5KCk7IC8vQWRkIFRoaXMgUG9seWdvbiB0cmlhbmdsZXNcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCb3JkZXJzW2ldID0gbmV3IEFycmF5KCk7IC8vQWRkIHRoaXMgUG9seWdvbiBib3JkZXJzXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0cmlhbmdsZXNQb2x5Z29uLmxlbmd0aDsgaisrKSB7IC8vVHJpYW5nbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyaWFuZ2xlc1tpXS5wdXNoKGJvcmRlclt0cmlhbmdsZXNQb2x5Z29uW2pdICogMl0sIGJvcmRlclt0cmlhbmdsZXNQb2x5Z29uW2pdICogMiArIDFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IHRyaWFuZ2xlc1BvbHlnb24ubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJULnB1c2goZ2wuY3JlYXRlQnVmZmVyKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY3VycmVudFRyaWFuZ2xlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyVFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclRbaV0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJUW2ldLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYm9yZGVyLmxlbmd0aDsgayArPSAyKSB7IC8vQm9yZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCb3JkZXJzW2ldLnB1c2goYm9yZGVyW2tdLCBib3JkZXJbayArIDFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT09IGJvcmRlci5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckIucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50Qm9yZGVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyQltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJbaV0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJCW2ldLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RmVhdHVyZShmZWF0dXJlSWQsIHByb3BlcnRpZXMsIGJ1ZmZlclQsIGJ1ZmZlckIsIFtdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiUG9pbnRcIiAmJiBvcHRzLmlzRHluYW1pYykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9pbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0pO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJQb2ludHMgPSBbXTsvL0J1ZmZlciBwb2ludHNcclxuICAgICAgICAgICAgbGV0IHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY3VycmVudFBvaW50cyk7XHJcblxyXG4gICAgICAgICAgICBidWZmZXJQb2ludHMucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyUG9pbnRzWzBdKTtcclxuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyUG9pbnRzWzBdLml0ZW1TaXplID0gMjtcclxuICAgICAgICAgICAgYnVmZmVyUG9pbnRzWzBdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmluc2VydEZlYXR1cmUoZmVhdHVyZUlkLCBwcm9wZXJ0aWVzLCBbXSwgW10sIGJ1ZmZlclBvaW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMudHJlZXBvaW50cy5wdXNoKHsgbG9uOiBnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgbGF0OiBnZW9tZXRyeS5jb29yZGluYXRlc1sxXSwgcHJvcGVydGllcyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiUG9pbnRcIiAmJiAhb3B0cy5pc0R5bmFtaWMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVtcEFlc3RoZXRpY1BvaW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBBZXN0aGV0aWNQb2ludHNbaV0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFlc1Bvc2l0aW9ucyA9IHRoaXMuZml0RmVhdHVyZShwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBhZXNQb3Mgb2YgYWVzUG9zaXRpb25zKVxyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wQWVzdGhldGljUG9pbnRzW2Flc1Bvc10ucHVzaChnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50cmVlcG9pbnRzLnB1c2goeyBsb246IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBsYXQ6IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBwcm9wZXJ0aWVzIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0xNSkgRGVhbHMgd2l0aCBwb2x5Z29uIHRyaWFuZ3VsYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge3tnZW9tZXRyeTogSlNPTiwgcHJvcGVydGllczogSlNPTn19IHBvbHlnb24gLSBUaGUgZ2VvbWV0cnkgYW5kIHByb3BlcnRpZXMgb2YgdGhlIHBvbHlnb24uXHJcbiAgICAgKiBAcmV0dXJucyB7e3RyaWFuZ2xlczogQXJyYXk8bnVtYmVyPiwgdmVydGljZXM6IEFycmF5PG51bWJlcj59fSAtIFRoZSB0cmlhbmdsZXMgYW5kIHZlcnRpY2VzIGNhbGN1bGF0ZWQgYnkgZWFyY3V0IHRyaWFuZ3VsYXRpb24uIFRoZSB2ZXJ0aWNlcyBhcmUgdGhlIG91dHNpZGUgb2YgdGhlIHBvbHlnb24sIHRoZSB0cmlhbmdsZXMgYXJlIHRoZSBpbnNpZGUuXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cubWFjd3JpZ2h0Lm9yZy8yMDE1LzAzLzIzL2dlb2pzb24tc2Vjb25kLWJpdGUuaHRtbCNwb2x5Z29uc1xyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzUG9seWdvbihwb2x5Z29uKSB7XHJcbiAgICAgICAgbGV0IHBvbHlhcnJheSA9IFtdO1xyXG4gICAgICAgIGlmIChwb2x5Z29uLmdlb21ldHJ5LnR5cGUgPT09IFwiUG9seWdvblwiKSB7IC8vQFRPRE86IFtEZW1vcyBuZXZlciB1c2UgdGhpcyBpZiBzdGF0ZW1lbnQuXVxyXG4gICAgICAgICAgICBsZXQgb3V0c2lkZXBvbHlnb24gPSBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdOyAvL1NlZTogaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sI3BvbHlnb25cclxuICAgICAgICAgICAgbGV0IHRlbXBWZXJ0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBvdXQgPSAwOyBvdXQgPCBvdXRzaWRlcG9seWdvbi5sZW5ndGggLSAxOyBvdXQrKylcclxuICAgICAgICAgICAgICAgIHRlbXBWZXJ0cy5wdXNoKG91dHNpZGVwb2x5Z29uW291dF1bMF0sIG91dHNpZGVwb2x5Z29uW291dF1bMV0pOy8vX3ZlcnRleGNvdW50ICs9IChvdXRzaWRlcG9seWdvbi5sZW5ndGggKyAxKSAvIDI7XHJcbiAgICAgICAgICAgIGxldCB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpOyAvLyBfdHJpY291bnQgKz0gKHRyaWFuZ2xlc192ZXJ0Lmxlbmd0aCAvIDMpO1xyXG4gICAgICAgICAgICBwb2x5YXJyYXkucHVzaCh7IHRyaWFuZ2xlczogdHJpYW5nbGVzX3ZlcnQsIHZlcnRpY2VzOiB0ZW1wVmVydHMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBvbHlnb24uZ2VvbWV0cnkudHlwZSA9PSBcIk11bHRpUG9seWdvblwiKSB7IC8vU2VlIGh0dHA6Ly9nZW9qc29uLm9yZy9nZW9qc29uLXNwZWMuaHRtbCNtdWx0aXBvbHlnb25cclxuICAgICAgICAgICAgZm9yIChjb25zdCBjcyBvZiBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3V0c2lkZXBvbHlnb24gPSBjc1swXTtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wVmVydHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBvdXRzaWRlcG9seWdvbilcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wVmVydHMucHVzaChjWzBdLCBjWzFdKTtcclxuICAgICAgICAgICAgICAgIGxldCB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG4gICAgICAgICAgICAgICAgcG9seWFycmF5LnB1c2goeyB0cmlhbmdsZXM6IHRyaWFuZ2xlc192ZXJ0LCB2ZXJ0aWNlczogdGVtcFZlcnRzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2x5YXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNMTYpIENvbnZlcnRzIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMobGF0aXR1ZGUsIGxvbmdpdHVkZSkgdG8gY2FudmFzIGNvb3JkaW5hdGUgcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGUgLSBUaGUgbGF0aXR1ZGUuXHJcbiAgICAgKiBAcmV0dXJucyB7eDogbnVtYmVyLCB5OiBudW1iZXJ9IC0gY2FudmFzIGNvb3JkaW5hdGUgc3lzdGVtIHBpeGVscy5cclxuICAgICAqIEBzZWUgaHR0cDovL2dpc2dlb2dyYXBoeS5jb20vbGF0aXR1ZGUtbG9uZ2l0dWRlLWNvb3JkaW5hdGVzL1xyXG4gICAgICogQHNlZSBodHRwczovL3d3dy53M3NjaG9vbHMuY29tL2dyYXBoaWNzL2NhbnZhc19jb29yZGluYXRlcy5hc3BcclxuICAgICAqIEBkZXByZWNhdGVkIE5vdCB1c2VkIGFueW1vcmUuIFlFQUguLi5cclxuICAgICAqIEBtZW1iZXJPZiBNYXBcclxuICAgICAqL1xyXG4gICAgbGF0TG9uZ1RvUGl4ZWxYWShsb25naXR1ZGUsIGxhdGl0dWRlKSB7XHJcbiAgICAgICAgY29uc3QgcGlfMTgwID0gTWF0aC5QSSAvIDE4MC4wO1xyXG4gICAgICAgIGNvbnN0IHBpXzQgPSBNYXRoLlBJICogNDtcclxuICAgICAgICBjb25zdCBzaW5MYXRpdHVkZSA9IE1hdGguc2luKGxhdGl0dWRlICogcGlfMTgwKTtcclxuICAgICAgICBjb25zdCBwaXhlbFkgPSAoMC41IC0gTWF0aC5sb2coKDEgKyBzaW5MYXRpdHVkZSkgLyAoMSAtIHNpbkxhdGl0dWRlKSkgLyAocGlfNCkpICogMjU2O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsWCA9ICgobG9uZ2l0dWRlICsgMTgwKSAvIDM2MCkgKiAyNTY7XHJcblxyXG4gICAgICAgIGNvbnN0IHBpeGVsID0geyB4OiBwaXhlbFgsIHk6IHBpeGVsWSB9O1xyXG4gICAgICAgIHJldHVybiBwaXhlbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0xNykgSW5zZXJ0cyB0aGUgRmVhdHVyZSBpbnRvIG9uZSBvciBtb3JlIEFlc3RoZXRpYyBvYmplY3RzLiBJZiB0aGUgRmVhdHVyZSBkb2VzIG5vdCBmaXQgaW4gYW55IEFlc3RoZXRpYyB0aGVuIGRvZXMgbm90aGluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIFRoZSBGZWF0dXJlIGlkLiBcclxuICAgICAqIEBwYXJhbSB7SlNPTn0gcHJvcGVydGllcyAtIFRoZSBGZWF0dXJlIHByb3BlcnRpZXMuIFxyXG4gICAgICogQHBhcmFtIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IHRyaWFuZ2xlcyAtIFRyaWFuZ2xlcywgZWFjaCBpbiBvbmUgV2ViR0xCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gYm9yZGVycyAtIEJvcmRlcnMsIGVhY2ggaW4gb25lIFdlYkdMQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IHBvaW50cyAtIFBvaW50cywgZWFjaCBpbiBvbmUgV2ViR0xCdWZmZXIuXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBpbnNlcnRGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgYWVzIG9mIHRoaXMuYWVzdGhldGljcylcclxuICAgICAgICAgICAgaWYgKGFlcy5jaGVja1Byb3BlcnR5KHByb3BlcnRpZXNbYWVzLmdldEF0dHIoKV0pKVxyXG4gICAgICAgICAgICAgICAgYWVzLmFkZEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKTtcclxuICAgICAgICAvKiBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgIGlmICh0aGlzLmFlc3RoZXRpY3NbaV0uY2hlY2tQcm9wZXJ0eShwcm9wZXJ0aWVzW3RoaXMuYWVzdGhldGljc1tpXS5nZXRBdHRyKCldKSlcclxuICAgICAgICAgICAgICAgICB0aGlzLmFlc3RoZXRpY3NbaV0uYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpOyovXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNMTgpIFJldHVybnMgYW4gYXJyYXkgb2YgQWVzdGhldGljIGlkcyB0aGF0IHRlbGxzIHVzIHRoZSBvYmplY3RzIHdoZXJlIHRoZSBGZWF0dXJlIGJlbG9uZ3MuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IHByb3BlcnRpZXMgLSBUaGUgRmVhdHVyZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gLSBUaGUgQWVzdGhldGljIGlkcyB3aGVyZSB0aGUgRmVhdHVyZSBiZWxvbmdzLlxyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBmaXRGZWF0dXJlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljc1tpXS5jaGVja1Byb3BlcnR5KHByb3BlcnRpZXNbdGhpcy5hZXN0aGV0aWNzW2ldLmdldEF0dHIoKV0pKVxyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0xOSkgUmVjZWl2ZXMgdGhlIGRhdGFzZXQgYXMgcGFyYW1ldGVyLiBUaGlzIGRhdGFzZXQgaW4gZWFjaCByb3cgY29udGFpbnMgZ2VvbWV0cnkgYW5kIGFzc29jaWF0ZWQgcHJvcGVydGllcywgdGhlbiBpdCBjcmVhdGVzIG9uZSB0cmVlXHJcbiAgICAgKiBlaXRoZXIgZm9yIHBvaW50cyBvciBwb2x5Z29ucy4gVGhpcyB0cmVlIGNhbiBiZSBrLWQgVHJlZWUgb3IgUkJ1c2goUlRyZWUpXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb2pzb24gXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICogQHNlZSBEaW9nbydzIHRoZXNpcyBwYWdlIDYyXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkVHJlZXMoZ2VvanNvbikge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMudGVtcEFlc3RoZXRpY1BvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50ZW1wQWVzdGhldGljUG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50ZW1wQWVzdGhldGljUG9pbnRzW2ldLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudGVtcEFlc3RoZXRpY1BvaW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclAucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJQWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydEFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0R3JvdXBlZEZlYXR1cmUoaSwgW10sIFtdLCBidWZmZXJQKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy50cmVlcG9pbnRzICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLmtkdHJlZSA9IG5ldyBrZFRyZWUodGhpcy50cmVlcG9pbnRzLCAoYSwgYikgPT4gKGEubG9uIC0gYi5sb24pICoqIDIgKyAoYS5sYXQgLSBiLmxhdCkgKiogMiwgW1wibG9uXCIsIFwibGF0XCIsIFwicHJvcGVydGllc1wiXSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUG9seWdvbnMpXHJcbiAgICAgICAgICAgIHRoaXMucnRyZWUgPSBuZXcgUG9seWdvbkxvb2t1cChnZW9qc29uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0yMCkgU2ltaWxhciB0byBpbnNlcnRGZWF0dXJlLCBpbiB0aGlzIGNhc2UgaW5zZXJ0cyBhIGdyb3VwIG9mIEZlYXR1cmVzIGxpa2UgaXQgd2FzIG9ubHkgb25lLlxyXG4gICAgICogSXQgY3JlYXRlcyBvbmUgV2ViR0xCdWZmZXIgd2l0aCBhbGwgdGhlIHBvaW50cyBpbnN0ZWFkIG9mIG9uZSBXZWJHTEJ1ZmZlciBwZXIgcG9pbnQuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gd2UgYWxyZWFkeSBncm91cGVkIHRoZSBGZWF0dXJlcyBieSBBZXN0aGV0aWMgY2xhc3MgKGZpdEZlYXR1cmUoKSBtZXRob2QpLlxyXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHRvIHByb3ZpZGUgb25lIGFsdGVybmF0aXZlIGxlc3MgZXhwZW5zaXZlIGluIHRlcm1zIG9mIG1lbW9yeSBmb3IgbG93IGVuZCBkZXZpY2VzLlxyXG4gICAgICogVXNlZCBvbmx5IG9uIERvdCBNYXAgYmVjYXVzZSBvbiB0aG9zZSB3ZSBjYW4gZWFzaWx5IGVuZCB1cCB3aXRoIG1pbGxpb25zIG9mIGRpZmZlcmVudCBGZWF0dXJlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIEFlc3RoZXRoaWNzIGlkLiBcclxuICAgICAqIEBwYXJhbSB7e2l0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fSB0cmlhbmdsZXMgLSBOb3QgdXNlZCA/XHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gYm9yZGVycyAtIE5vdCB1c2VkID9cclxuICAgICAqIEBwYXJhbSB7e2l0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fSBwb2ludHMgLSBBbGwgdGhlIHBvaW50cyBmb3IgdGhlIEFlc3RoZXRoaWMgb2JqZWN0IGluIG9uZSBXZWJHTEJ1ZmZlci5cclxuICAgICAqIEBtZW1iZXJPZiBNYXBcclxuICAgICAqL1xyXG4gICAgaW5zZXJ0R3JvdXBlZEZlYXR1cmUoaWQsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzW2lkXS5hZGRHcm91cGVkRmVhdHVyZShudWxsLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICBMRUdFTkQgTUVUSE9EUyAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIC8qKlxyXG4gICAgICogTTE3KSBDcmVhdGVzIGEgTGVnZW5kIGVsZW1lbnQgc3VpdGFibGUgZm9yIHBvbHlnb25zIGJhc2VkIG9uIHRoZSBBZXN0aGV0aGljIG9iamVjdHMuXHJcbiAgICAgKiBTaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHN1YmNsYXNzZXMuXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke3RoaXMuaWR9YCk7XHJcbiAgICAgICAgY29uc3QgbGVnZW5kRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbGVnZW5kRGl2LmlkID0gYGxlZ2VuZERpdiR7dGhpcy5pZH1gO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLndpZHRoID0gMjUwO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3R0b20gPSAyMDtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUucmlnaHQgPSAwO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3JkZXJDb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLmJvcmRlciA9ICdzb2xpZCc7XHJcblxyXG4gICAgICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcclxuICAgICAgICBjb25zdCB0aHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICBjb25zdCB0aGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICB0YWJsZS5zdHlsZS56SW5kZXggPSBcIjIwMDBcIjtcclxuICAgICAgICB0aGNvbG9yLnN0eWxlLndpZHRoID0gMTAwO1xyXG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRoY29sb3IpO1xyXG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRodmFsdWUpO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRhZXMgb2YgdGhpcy5hZXN0aGV0aWNzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBwdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcclxuICAgICAgICAgICAgbGV0IHRleHQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudGFlcy5yYW5nZVswXSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFske2N1cnJlbnRhZXMucmFuZ2VbMF19LCAke2N1cnJlbnRhZXMucmFuZ2VbMV19W2ApO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3VycmVudGFlcy5yYW5nZVswXSk7XHJcbiAgICAgICAgICAgIHB0ZXh0LmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZChwdGV4dCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJnYmMgPSBgcmdiYSgke2N1cnJlbnRhZXMuZmlsbENvbG9yWzBdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzFdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzJdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzNdfSlgO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZVsnYmFja2dyb3VuZENvbG9yJ10gPSByZ2JjO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSAyNTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSA4MDtcclxuICAgICAgICAgICAgY29sb3IuYXBwZW5kQ2hpbGQoY29sb3JEaXYpO1xyXG5cclxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGNvbG9yKTtcclxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlKTtcclxuICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlZ2VuZERpdi5hcHBlbmRDaGlsZCh0YWJsZSk7XHJcbiAgICAgICAgdGhpcy5iR01hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChsZWdlbmREaXYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgV0VCR0wgTUVUSE9EUyAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIC8qKlxyXG4gICAgICogTTIyKSBDbGVhciBjdXJyZW50IGJ1ZmZlcnMgdG8gcHJlc2V0IHZhbHVlcy5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC9jbGVhclxyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNMjMpIFJlY2VpdmluZyBhbiBBZXN0aGV0aWNzIG9iamVjdCwgZHJhd3MgdGhlIHRyaWFuZ2xlcyBjb250YWluZWQgaW4gaXQncyBGZWF0dXJlcyxcclxuICAgICAqIHVzaW5nIHRoZSBjb2xvciB0aGF0IHRoZSBBZXN0aGV0aGljcyBvYmplY3QgaGFzLlxyXG4gICAgICogQHBhcmFtIHtBZXN0aGV0aWN9IGFlcyAtIFRoZSBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAc2VlIERpb2dvJ3MgdGhlc2lzIFBhZ2UgNTgvNTlcclxuICAgICAqIEBtZW1iZXJPZiBNYXBcclxuICAgICAqL1xyXG4gICAgZHJhd1RyaWFuZ2xlcyhhZXMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMuYkdNYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3Jkc0xvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2Nvb3JkcycpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdhUG9pbnRTaXplJyk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBsZXQgW3IsIGcsIGIsIGFdID0gYWVzLmdldEZpbGxDb2xvcigpO1xyXG5cclxuICAgICAgICB0aGlzLnNldE1hdHJpY2VzKGdsKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuICAgICAgICBnbC51bmlmb3JtNGYoZnJhZ21lbnRDb2xvckxvY2F0aW9uLCByIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhKTsvLyBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG5cclxuICAgICAgICBsZXQgZmVhdHVyZXMgPSBhZXMuZ2V0RmVhdHVyZXMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgZmVhdHVyZXMpIHsgLy8gRHJhdyBQb2x5Z29ucycgSW50ZXJpb3JcclxuICAgICAgICAgICAgbGV0IHRyaWFuZ2xlcyA9IGYuZ2V0VHJpYW5nbGVzKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0cmlhbmdsZXMpIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0KTtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3Jkc0xvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRzTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiAyLCAwKTtcclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCB0Lm51bUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0yNCkgUmVjZWl2aW5nIGFuIEFlc3RoZXRpY3Mgb2JqZWN0LCBkcmF3cyB0aGUgYm9yZGVycyBjb250YWluZWQgaW4gaXQncyBGZWF0dXJlcywgXHJcbiAgICAgKiBhcGx5aW5nIHRoZSBjb2xvciBzcGVjaWZpZWQgaW4gdGhlIEFlc2h0ZWljIG9iamVjdCBmb3IgdGhlIGxpbmUgY29sb3IoQWVzaHRlaWMuc3Ryb2tlQ29sb3IpLlxyXG4gICAgICogQHBhcmFtIHtBZXN0aGV0aWN9IGFlcyAtIFRoZSBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIGRyYXdCb3JkZXJzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5iR01hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA1LjAsIDEuMCk7XHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29vcmRzTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnY29vcmRzJyk7XHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG4gICAgICAgIGNvbnN0IGlzUG9pbnRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnaXNQb2ludCcpO1xyXG4gICAgICAgIGxldCBbciwgZywgYiwgYV0gPSBhZXMuZ2V0U3Ryb2tlQ29sb3IoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRNYXRyaWNlcyhnbCk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliMWYodmVydGV4U2l6ZUxvY2F0aW9uLCBwb2ludFNpemUpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihpc1BvaW50TG9jYXRpb24sIDAuMCk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKGZyYWdtZW50Q29sb3JMb2NhdGlvbiwgciAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgYSk7XHJcblxyXG4gICAgICAgIGxldCBmZWF0dXJlcyA9IGFlcy5nZXRGZWF0dXJlcygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZiBvZiBmZWF0dXJlcykge1xyXG4gICAgICAgICAgICBsZXQgYm9yZGVycyA9IGYuZ2V0Qm9yZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgYm9yZGVycykge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGIpO1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4Q29vcmRzTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZHNMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX0xPT1AsIDAsIGIubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTI1KSBSZWNlaXZpbmcgYW4gQWVzdGhldGljcyBvYmplY3QsIGRyYXdzIHRoZSBib3JkZXJzIGNvbnRhaW5lZCBpbiBpdCdzIEZlYXR1cmVzLCBcclxuICAgICAqIGFwbHlpbmcgdGhlIGZpbGxpbmcgY29sb3IgY2FsY3VsYXRlZCB1c2luZyB0aGUgYXR0cmlidXRlIGFuZCB0aGUgY29sb3Igc2NoZW1lLlxyXG4gICAgICogQHBhcmFtIHtBZXN0aGV0aWN9IGFlcyAtIFRoZSBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIGRyYXdDb250aW51b3VzUG9seWdvbnMoYWVzKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl93ZWJnbC5nbDtcclxuICAgICAgICBpZiAoZ2wgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLmJHTWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZHNMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdjb29yZHMnKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50Q29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0TWF0cmljZXMoZ2wpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAwLjApO1xyXG5cclxuICAgICAgICBsZXQgZmVhdHVyZXMgPSBhZXMuZ2V0RmVhdHVyZXMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgbGV0IGNvbG9yO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZi5nZXRQcm9wZXJ0aWVzKClbdGhpcy5naXNwbGF5T3B0aW9ucy5hdHRyXTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApXHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGFlcy5maWxsQ29sb3IoMC41KS5yZ2IoKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSArIGRpZmYgLyB0aGlzLm1heCAvIDIpLnJnYigpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWVzLmZpbGxDb2xvcigwLjUgLSBkaWZmIC8gdGhpcy5taW4gLyAyKS5yZ2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgW3IsIGcsIGIsIGFdID0gW01hdGgucm91bmQoY29sb3JbMF0pIC8gMjU1LCBNYXRoLnJvdW5kKGNvbG9yWzFdKSAvIDI1NSwgTWF0aC5yb3VuZChjb2xvclsyXSkgLyAyNTUsIHRoaXMuZ2lzcGxheU9wdGlvbnMuYWxwaGFdO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtNGYoZnJhZ21lbnRDb2xvckxvY2F0aW9uLCByLCBnLCBiLCBhKTtcclxuXHJcbiAgICAgICAgICAgIGxldCB0cmlhbmdsZXMgPSBmLmdldFRyaWFuZ2xlcygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHJpYW5nbGVzKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdCk7XHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZHNMb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvb3Jkc0xvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7Ly9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIHQubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTI2KSBSZWNlaXZpbmcgYW4gQWVzdGhldGljcyBvYmplY3QsIGRyYXdzIHRoZSBwb2ludHMgY29udGFpbmVkIGluIGl0J3MgRmVhdHVyZXMsIFxyXG4gICAgICogYXBseWluZyB0aGUgdmFsdWVzIHNwZWNpZmllZCBpbiB0aGF0IEFlc3RoZXRpYyBvYmplY3QgdmlzdWFsIHZhcmlhYmxlcyAoY29sb3IgYW5kIHNpemUpLlxyXG4gICAgICogQHBhcmFtIHtBZXN0aGV0aWN9IGFlcyAtIFRoZSBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIGRyYXdQb2ludHMoYWVzKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl93ZWJnbC5nbDtcclxuICAgICAgICBpZiAoZ2wgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLmJHTWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDQuMCArIGFlcy5nZXRQb2ludFNpemUoKSwgYWVzLmdldFBvaW50U2l6ZSgpKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZHNMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdjb29yZHMnKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50Q29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgbGV0IFtyLCBnLCBiLCBhXSA9IGFlcy5nZXRGaWxsQ29sb3IoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRNYXRyaWNlcyhnbCk7IC8vU2V0IE0xLCBNMiBhbmQgTTNcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMS4wKTtcclxuICAgICAgICBnbC51bmlmb3JtNGYoZnJhZ21lbnRDb2xvckxvY2F0aW9uLCByIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhKTtcclxuXHJcbiAgICAgICAgbGV0IGZlYXR1cmVzID0gYWVzLmdldEZlYXR1cmVzKCk7XHJcbiAgICAgICAgbGV0IGFsbEZlYXR1cmVzID0gYWVzLmdldEFsbEZlYXR1cmVzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2lzcGxheU9wdGlvbnMuaXNEeW5hbWljICYmIGFlcy5nZXRGZWF0dXJlcygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRzID0gZi5nZXRQb2ludHMoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBwb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4Q29vcmRzTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRzTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiAyLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgcC5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWxsRmVhdHVyZXMgIT09IG51bGwgJiYgIXRoaXMuZ2lzcGxheU9wdGlvbnMuaXNEeW5hbWljKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWxsRiBvZiBhbGxGZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50cyA9IGFsbEYuZ2V0UG9pbnRzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3Jkc0xvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvb3Jkc0xvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHAubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTI3KSBSZWNlaXZpbmcgYW4gQWVzdGhldGljcyBvYmplY3QsIGRyYXdzIHRoZSBwb2ludHMgY29udGFpbmVkIGluIGl0J3MgRmVhdHVyZXMsIFxyXG4gICAgICogYXBseWluZyB0aGUgY29sb3Igc3BlY2lmaWVkIGluIHRoZSBBZXNodGVpYyBvYmplY3QgZm9yIHRoZSBsaW5lIGNvbG9yKEFlc2h0ZWljLnN0cm9rZUNvbG9yKSBcclxuICAgICAqIGFuZCB0aGUgc2l6ZSBvZiB0aGUgcG9pbnQgaXMgYmFzZWQgb24gdGhlIGF0dHJpYnV0ZSB2YWx1ZSBhbmQgdGhlIHNwZWNpZmllZCBsaW1pdHMuXHJcbiAgICAgKiBAcGFyYW0ge0Flc3RoZXRpY30gYWVzIC0gVGhlIEFlc3RoZXRpYyBvYmplY3QuIFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9IFxyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBkcmF3UHJvcG9ydGlvbmFsUG9pbnRzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5iR01hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29vcmRzTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnY29vcmRzJyk7XHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG4gICAgICAgIGNvbnN0IGlzUG9pbnRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnaXNQb2ludCcpO1xyXG4gICAgICAgIGxldCBbciwgZywgYl0gPSBhZXMuZ2V0RmlsbENvbG9yKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0TWF0cmljZXMoZ2wpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihpc1BvaW50TG9jYXRpb24sIDEuMCk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKGZyYWdtZW50Q29sb3JMb2NhdGlvbiwgciAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgdGhpcy5naXNwbGF5T3B0aW9ucy5hbHBoYSk7IC8vVE9ETzogUGFyYSAyLjVEIHVzYXIgYWxwaGEgYSAwP1xyXG5cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICBsZXQgb3B0cyA9IHRoaXMuZ2lzcGxheU9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2lzcGxheU9wdGlvbnMuaXNEeW5hbWljKSB7XHJcbiAgICAgICAgICAgIGxldCBmZWF0dXJlcyA9IGFlcy5nZXRGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3B2YWx1ZSA9IHBhcnNlRmxvYXQoZi5nZXRQcm9wZXJ0aWVzKClbb3B0cy5hdHRyXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wcG9pbnRzaXplID0gKChvcHRzLm1heFBvaW50U2l6ZSAtIG9wdHMubWluUG9pbnRTaXplKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSkgKiAocHJvcHZhbHVlIC0gdGhpcy5taW4pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA0LjAgKyB0ZW1wcG9pbnRzaXplICogY3VycmVudFpvb20gLyA0LCAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRzID0gZi5nZXRQb2ludHMoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZHNMb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZHNMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBwLm51bUl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2V0IGFsbCBtYXRyaWNlcyBuZWVkZWQgdG8gY29tcHV0ZSBlYWNoIHBvaW50L3ZlcnRleCBwb3NpdGlvbi4gVGhpcyB3aWxsIHVzZSB0aGUgXHJcbiAgICAgKiBCZWZvcmUgc2VuZGluZyB0aGUgbWF0cml4IHRvIHdlYkdMIHdlIGNoYW5nZSB0aGUgbGFzdCBjb2x1bW4gdHJhbnNmb3JtYXRpb24gaW4gWCBhbmQgWSB0byB0aGUgbGFzdCByb3cgWCBhbmQgWSBcclxuICAgICAqIGJlY2F1c2UgV2ViR0wgaXMgY29sdW1uIG1ham9yLiBTZWUgTU1hdHJpeFs2XSA9Li4uXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHNldE1hdHJpY2VzKGdsKSB7XHJcbiAgICAgICAgbGV0IGxuZ0NlbnRlciA9IHRoaXMuYkdNYXAuZ2V0Q2VudGVyTG5nKCk7XHJcbiAgICAgICAgbGV0IGxhdENlbnRlciA9IHRoaXMuYkdNYXAuZ2V0Q2VudGVyTGF0KCk7XHJcbiAgICAgICAgbGV0IHpvb20gPSB0aGlzLmJHTWFwLmdldFpvb20oKTtcclxuICAgICAgICBsZXQgdGlsZVNpemUgPSB0aGlzLmdpc3BsYXlPcHRpb25zLnRpbGVTaXplO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuYkdNYXAuZ2V0V2lkdGgoKTtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5iR01hcC5nZXRIZWlnaHQoKTtcclxuICAgICAgICAvKiBpZih3aW5kb3cuZmlyc3Qpe1xyXG4gICAgICAgICAgICAgY29uc29sZS5sb2coXCJIRVJFXCIpXHJcbiAgICAgICAgICAgICB3aWR0aCA9IDI0MzI7XHJcbiAgICAgICAgIH0qL1xyXG4gICAgICAgIGxldCBtZXJjYXRvciA9IFdlYkdMVXRpbHMud2ViTWVyY2F0b3JQcm9qZWN0aW9uKGxuZ0NlbnRlciwgbGF0Q2VudGVyLCB6b29tLCB0aWxlU2l6ZSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgIC8qICBsZXQgTTFNYXRyaXggPSBXZWJHTFV0aWxzLmNyZWF0ZU0xKHRoaXMuX3dlYmdsLmdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgdGhpcy5fd2ViZ2wuZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7IC8vVE9ETzogVGhpcyBkb2VzIG5vdCBzb2x2ZSB0aGUgcmVzaXppbmcgaXNzdWUgMTAwJS5cclxuICAgICAgICBsZXQgTTJNYXRyaXggPSBXZWJHTFV0aWxzLmNyZWF0ZU0yKG1lcmNhdG9yLnNjYWxlLCBtZXJjYXRvci5vZmZzZXRYLCBtZXJjYXRvci5vZmZzZXRZKTtcclxuICAgICAgICBsZXQgTTNNYXRyaXggPSBXZWJHTFV0aWxzLmNyZWF0ZU0zKCk7XHJcblxyXG4gICAgICAgIGxldCBNMXhNMiA9IFdlYkdMVXRpbHMubWF0cml4TXVsdGlwbGljYXRpb24oTTFNYXRyaXgsIE0yTWF0cml4KTtcclxuICAgICAgICBsZXQgTU1hdHJpeCA9IFdlYkdMVXRpbHMubWF0cml4TXVsdGlwbGljYXRpb24oTTF4TTIsIE0zTWF0cml4KTtcclxuICAgICAgICBNTWF0cml4WzZdID0gTU1hdHJpeFsyXTtcclxuICAgICAgICBNTWF0cml4WzddID0gTU1hdHJpeFs1XTtcclxuICAgICAgICBNTWF0cml4WzJdID0gMDtcclxuICAgICAgICBNTWF0cml4WzVdID0gMDsqL1xyXG4gICAgICAgIGxldCBNTWF0cml4ID0gV2ViR0xVdGlscy5maW5hbE1hdHJpeChtZXJjYXRvci5zY2FsZSwgd2lkdGgsIGhlaWdodCwgbWVyY2F0b3Iub2Zmc2V0WCwgbWVyY2F0b3Iub2Zmc2V0WSk7XHJcbiAgICAgICAgY29uc3QgTWxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnTScpXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihNbG9jLCBmYWxzZSwgTU1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNMjgpIFNjYWxlIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiB4KHNjYWxlWCkgYW5kIHkoc2NhbGVZKSB2YWx1ZXMuXHJcbiAgICAgKiBTY2FsaW5nIHggYW5kIHksIHdoaWNoIGlzIGp1c3Qgc2NhbGluZyBmaXJzdCB0d28gcm93cyBvZiBtYXRyaXhcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBtYXRyaXggXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYIC0gU2NhbGUgaW4gWCBheGlzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWSAtIFNjYWxlIGluIFkgYXhpcy5cclxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5jLWp1bXAuY29tL2JjYy9jb21tb24vVGFsazMvTWF0aC9NYXRyaWNlcy9jb25zdF9pbWFnZXMvYXBwbHlpbmdfc2NhbGluZy5wbmdcclxuICAgICAqIEBzZWUgaHR0cDovL3B0Z21lZGlhLnBlYXJzb25jbWcuY29tL2ltYWdlcy9jaGFwM185NzgwMzIxOTAyOTI0L2VsZW1lbnRMaW5rcy8wM2ZpZzI3LmpwZyBSZW1lbWJlciBXZWJHTCBpcyBDb2x1bW4gbWFqb3JcclxuICAgICAqIEBzZWUgaHR0cDovL3BybnRzY3IuY29tL2Vvbm9uYlxyXG4gICAgICogQG1lbWJlck9mIE1hcFxyXG4gICAgICovXHJcbiAgICBzY2FsZVByb2plY3Rpb24obWF0cml4LCBzY2FsZVgsIHNjYWxlWSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxyXG4gICAgICAgICAgICBpIDwgNCA/IChtYXRyaXhbaV0gKj0gc2NhbGVYKSA6IChtYXRyaXhbaV0gKj0gc2NhbGVZKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE0yOSkgVGhlIHRyYW5zbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgbGFzdCByb3cgb2YgdGhlIG1hdHJpeC4gXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBob2xkIHRoZSByZXN1bHQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHggLSBUcmFuc2xhdGlvbiBpbiBYIGF4aXMuICBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAtIFRyYW5zbGF0aW9uIGluIFkgYXhpcy5cclxuICAgICAqIEBzZWUgaHR0cDovL3BvbHltYXRocHJvZ3JhbW1lci5jb20vaW1hZ2VzL2Jsb2cvMjAwODA5L3RyYW5zbGF0aW9ubWF0cml4LnBuZ1xyXG4gICAgICogQHNlZSBodHRwOi8vcHJudHNjci5jb20vZW9ub25iXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4LCB0eCwgdHkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcclxuICAgICAgICAgICAgbWF0cml4W2kgKyAxMl0gKz0gKG1hdHJpeFtpXSAqIHR4KSArIChtYXRyaXhbaSArIDRdICogdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgQUJTVFJBQ1QgTUVUSE9EUyAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIC8qKlxyXG4gICAgICogTTIxKSBEcmF3IG1hcCBmdW5jdGlvbi4gTXVzdCBiZSBvdmVycmlkZW4gYnkgc3ViY2xhc3Nlcy5cclxuICAgICAqIEBhYnN0cmFjdCBcclxuICAgICAqL1xyXG4gICAgZHJhdygpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEcmF3IG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTEwKSBEZWZhdWx0cyBmb3IgZWFjaCBtYXAuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHthbnl9IGRlZmF1bHRJZCBcclxuICAgICAqIEBhYnN0cmFjdCBcclxuICAgICAqIEBtZW1iZXJPZiBNYXBcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHMoZGVmYXVsdElkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtYXAgaGFzIG5vIGRlZmF1bHRzIGRlZmluZWQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgYW55IHN1YmNsYXNzIHRoYXQgd2FudHMgdG8gdXNlIGFub3RoZXIgd2F5IG9mIHByb2Nlc3NpbmcgZGF0YS5cclxuICAgICAqIEJ5IGRlZmF1bHQgaXQgbG9hZHMgR2VvSlNPTiBidXQgaWYgdGhlIHVzZXIgd2FudHMgdG8gbG9hZCBhbm90aGVyIHR5cGUgb2YgZGF0YSBpdCBzaG91bGQgZG8gc28gYnkgaW1wbGVtZW50aW5nIHRoaXMgbWV0aG9kLlxyXG4gICAgICogQSBmdW5jdGlvbiBzaW1pbGFyIHRvIGxvYWRHZW9KU09OIHNob3VsZCBhbHNvIGJlIGltcGxlbWVudGVkXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdHxKU09OfSBkYXRhIC0gRGF0YXNldCB0byBiZSB1c2VkLiBcclxuICAgICAqIFRPRE86IEFkZCBzdGF0aWMgdG8gdGhpcyBtZXRob2QuXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc0RhdGEoZGF0YSkge1xyXG4gICAgICAgIHRoaXMubG9hZEdlb0pTT04oZ2VvanNvbik7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9NYXAuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQVlBO0FBQUE7QUFDQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFVQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBOzs7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFvQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQW9CQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBO0FBNUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE2QkE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUF1QkE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQS9CQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0NBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWtCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBZEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXFCQTtBQXZDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBd0NBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQVRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFhQTtBQWZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/Gisplay/Maps/BGMapWrapper.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class represents a background map wrapper. Used to be a \"middle-man\" between the \r\n * background map provider and the Gisplay API.\r\n * @see https://www.mapbox.com/mapbox-gl-js/api/ \r\n * @see https://developers.google.com/maps/documentation/javascript/3.exp/reference\r\n * @see https://developer.here.com/develop/javascript-api \r\n * @see Diogo's thesis Page 70-72 + 59\r\n */\nvar BGMapWrapper = exports.BGMapWrapper = function () {\n\n    /**\r\n     * Creates an instance of BGMapWrapper.\r\n     * @param {Object} bgmap - The background map object that came from the provider (e.g., Mapbox, Google Maps). \r\n     */\n    function BGMapWrapper(bgmap) {\n        _classCallCheck(this, BGMapWrapper);\n\n        /**\r\n         * This is the background map object that comes from the background map provider(e.g., MapBox). \r\n         * @type {Object}\r\n         */\n        this.bgMapObject = bgmap;\n    }\n\n    /**\r\n     * Returns the map's containing HTML element.\r\n     * @return {HTMLElement} - The map's HTML element container.\r\n     */\n\n\n    _createClass(BGMapWrapper, [{\n        key: 'getContainer',\n        value: function getContainer() {\n            return this.bgMapObject.getContainer();\n        }\n\n        /**\r\n         * Returns the width of the canvas elment.\r\n         * @returns {number} the width of the canvas elment.\r\n         * @memberOf BGMapWrapper\r\n         */\n\n    }, {\n        key: 'getWidth',\n        value: function getWidth() {\n            return this.getContainer().offsetWidth;\n        }\n\n        /**\r\n         * Returns the height of the canvas element.\r\n         * @returns {number} the height of the canvas elment.\r\n         * @memberOf BGMapWrapper\r\n         */\n\n    }, {\n        key: 'getHeight',\n        value: function getHeight() {\n            return this.getContainer().offsetHeight;\n        }\n\n        /**\r\n         * Given one id it creates a canvas object.\r\n         * @todo Understand case mapbox comment bellow.\r\n         * @param {number} id - The id of the canvas to be created.\r\n         * @return {HTMLElement} Canvas object where everything will be drawn.\r\n         */\n\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas(id) {\n            var mapCanvas = document.createElement('canvas');\n            mapCanvas.id = 'mapCanvas' + id;\n            mapCanvas.style.position = 'absolute';\n\n            var mapDiv = this.bgMapObject.getContainer();\n            mapCanvas.height = mapDiv.offsetHeight;\n            mapCanvas.width = mapDiv.offsetWidth;\n            //case mapbox\n            mapDiv.insertBefore(mapCanvas, mapDiv.firstChild.nextSibling);\n\n            var canvas = document.getElementById('mapCanvas' + id);\n            return canvas;\n        }\n\n        /**\r\n         * Returns the map's current zoom level.\r\n         * @return {number} - The map's current zoom level.\r\n         */\n\n    }, {\n        key: 'getZoom',\n        value: function getZoom() {\n            return this.bgMapObject.getZoom();\n        }\n\n        /**\r\n         * Returns the longitude of the bounding box northwest corner.\r\n         * @return {number} - Longitude of northwest corner, measured in degrees.\r\n         */\n\n    }, {\n        key: 'getCenterLng',\n        value: function getCenterLng() {\n            return ((180 + this.bgMapObject.getCenter().lng) % 360 + 360) % 360 - 180;\n        }\n\n        /**\r\n         * Returns the latitude of the bounding box northwest corner.\r\n         * @return {number} - Latitude of northwest corner, measured in degrees.\r\n         */\n\n    }, {\n        key: 'getCenterLat',\n        value: function getCenterLat() {\n            return this.bgMapObject.getCenter().lat;\n        }\n\n        /**\r\n         * Returns all the corner bounds(NW, SW, NE, SE) of the background map.\r\n         * @returns {{NW: {lng: number, lat: number}, SW: {lng: number, lat: number}, NE: {lng: number, lat: number}, SE: {lng: number, lat: number}}} description\r\n         * @deprecated Not used atm.\r\n         * @memberOf BGMapWrapper\r\n         */\n\n    }, {\n        key: 'getMapBounds',\n        value: function getMapBounds() {\n            var map = this.bgMapObject;\n            return {\n                NW: {\n                    lng: map.getBounds().getNorthWest().lng,\n                    lat: map.getBounds().getNorthWest().lat\n                },\n                SW: {\n                    lng: map.getBounds().getSouthWest().lng,\n                    lat: map.getBounds().getSouthWest().lat\n                },\n                NE: {\n                    lng: map.getBounds().getNorthEast().lng,\n                    lat: map.getBounds().getNorthEast().lat\n                },\n                SE: {\n                    lng: map.getBounds().getSouthEast().lng,\n                    lat: map.getBounds().getSouthEast().lat\n                }\n            };\n        }\n\n        /**\r\n         * Verifies if the background map being shown is in two different meridians.\r\n         * @param {{lng: number, lat: number}} NW - North west corner coordinates\r\n         * @param {{lng: number, lat: number}} NE - North East corner coordinates\r\n         * @deprecated Not used atm.\r\n         * @memberOf BGMapWrapper\r\n         */\n\n    }, {\n        key: 'isInMultipleMeridians',\n        value: function isInMultipleMeridians(NW, NE) {\n            return false;\n        }\n\n        /**\r\n         * Adds a listener to a specified event type.\r\n         * @param {string} eventstr - The event type to add a listen for.\r\n         * @param {Function} eventfunction - The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties.\r\n         * @return {void} \r\n         */\n\n    }, {\n        key: 'addEventListener',\n        value: function addEventListener(eventstr, eventfunction) {\n            this.bgMapObject.on(eventstr, eventfunction);\n        }\n\n        /**\r\n         * Shows loader at the beginning when the API is loading the data.\r\n         * @return {void} \r\n         * @see Page 72 Diogo's thesis.\r\n         */\n\n    }, {\n        key: 'showLoader',\n        value: function showLoader() {\n            if (this.loaderDiv === undefined) //@TODO: REMOVE If (See M1 + M8) \n                this.createLoader();else {\n                if (this.loaderDiv.style.display === 'none') this.loaderDiv.style.display = 'flex';else this.loaderDiv.style.display = 'none';\n\n                if (this.loaderDiv.className.includes('_gisplayhidden')) this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayhidden(?!\\S)/g, '_gisplayLoaderOuterDiv');else this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayLoaderOuterDiv(?!\\S)/g, '_gisplayhidden');\n            }\n        }\n\n        /**\r\n         * Auxiliar method to be called when there is no loader  and we want to create one.\r\n         * @return {void} \r\n         */\n\n    }, {\n        key: 'createLoader',\n        value: function createLoader() {\n            var outerDiv = document.createElement('div');\n            var innerDiv = document.createElement('div');\n            innerDiv.className = '_gisplayloader';\n\n            var mapDiv = this.getContainer();\n            outerDiv.className = '_gisplayLoaderOuterDiv';\n            outerDiv.style.height = mapDiv.offsetHeight;\n            outerDiv.style.width = mapDiv.offsetWidth;\n            outerDiv.appendChild(innerDiv);\n            /**\r\n             * The div that contains the loader.\r\n             * @type {HTMLDivElement}\r\n             */\n            this.loaderDiv = outerDiv;\n            mapDiv.parentElement.insertBefore(outerDiv, mapDiv);\n        }\n\n        /**\r\n         * Returns the background map object. This is the Background provider object (e.g., Mapbox, GMaps, HereMaps, Bing Maps).\r\n         * @returns {BGMapWrapper#bgMapObject} the background map object.\r\n         * @memberOf BGMapWrapper\r\n         */\n\n    }, {\n        key: 'getBackgroundMapProviderObject',\n        value: function getBackgroundMapProviderObject() {\n            return this.bgMapObject;\n        }\n    }]);\n\n    return BGMapWrapper;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcz9lMjZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBiYWNrZ3JvdW5kIG1hcCB3cmFwcGVyLiBVc2VkIHRvIGJlIGEgXCJtaWRkbGUtbWFuXCIgYmV0d2VlbiB0aGUgXHJcbiAqIGJhY2tncm91bmQgbWFwIHByb3ZpZGVyIGFuZCB0aGUgR2lzcGxheSBBUEkuXHJcbiAqIEBzZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyBcclxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC8zLmV4cC9yZWZlcmVuY2VcclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5oZXJlLmNvbS9kZXZlbG9wL2phdmFzY3JpcHQtYXBpIFxyXG4gKiBAc2VlIERpb2dvJ3MgdGhlc2lzIFBhZ2UgNzAtNzIgKyA1OVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJHTWFwV3JhcHBlciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJHTWFwV3JhcHBlci5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIFRoZSBiYWNrZ3JvdW5kIG1hcCBvYmplY3QgdGhhdCBjYW1lIGZyb20gdGhlIHByb3ZpZGVyIChlLmcuLCBNYXBib3gsIEdvb2dsZSBNYXBzKS4gXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYmFja2dyb3VuZCBtYXAgb2JqZWN0IHRoYXQgY29tZXMgZnJvbSB0aGUgYmFja2dyb3VuZCBtYXAgcHJvdmlkZXIoZS5nLiwgTWFwQm94KS4gXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJnTWFwT2JqZWN0ID0gYmdtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBjb250YWluaW5nIEhUTUwgZWxlbWVudC5cclxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAtIFRoZSBtYXAncyBIVE1MIGVsZW1lbnQgY29udGFpbmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRDb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmdNYXBPYmplY3QuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsbWVudC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsbWVudC5cclxuICAgICAqIEBtZW1iZXJPZiBCR01hcFdyYXBwZXJcclxuICAgICAqL1xyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGFpbmVyKCkub2Zmc2V0V2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIGVsbWVudC5cclxuICAgICAqIEBtZW1iZXJPZiBCR01hcFdyYXBwZXJcclxuICAgICAqL1xyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lcigpLm9mZnNldEhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIG9uZSBpZCBpdCBjcmVhdGVzIGEgY2FudmFzIG9iamVjdC5cclxuICAgICAqIEB0b2RvIFVuZGVyc3RhbmQgY2FzZSBtYXBib3ggY29tbWVudCBiZWxsb3cuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgaWQgb2YgdGhlIGNhbnZhcyB0byBiZSBjcmVhdGVkLlxyXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IENhbnZhcyBvYmplY3Qgd2hlcmUgZXZlcnl0aGluZyB3aWxsIGJlIGRyYXduLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVDYW52YXMoaWQpIHtcclxuICAgICAgICBjb25zdCBtYXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBtYXBDYW52YXMuaWQgPSBgbWFwQ2FudmFzJHtpZH1gO1xyXG4gICAgICAgIG1hcENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcERpdiA9IHRoaXMuYmdNYXBPYmplY3QuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgbWFwQ2FudmFzLmhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgbWFwQ2FudmFzLndpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIC8vY2FzZSBtYXBib3hcclxuICAgICAgICBtYXBEaXYuaW5zZXJ0QmVmb3JlKG1hcENhbnZhcywgbWFwRGl2LmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcpO1xyXG5cclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgbWFwQ2FudmFzJHtpZH1gKTtcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsLlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIGdldFpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmdNYXBPYmplY3QuZ2V0Wm9vbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZGluZyBib3ggbm9ydGh3ZXN0IGNvcm5lci5cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBMb25naXR1ZGUgb2Ygbm9ydGh3ZXN0IGNvcm5lciwgbWVhc3VyZWQgaW4gZGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2VudGVyTG5nKCkge1xyXG4gICAgICAgIHJldHVybiAoKCgoMTgwICsgdGhpcy5iZ01hcE9iamVjdC5nZXRDZW50ZXIoKS5sbmcpICUgMzYwKSArIDM2MCkgJSAzNjApIC0gMTgwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGF0aXR1ZGUgb2YgdGhlIGJvdW5kaW5nIGJveCBub3J0aHdlc3QgY29ybmVyLlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIExhdGl0dWRlIG9mIG5vcnRod2VzdCBjb3JuZXIsIG1lYXN1cmVkIGluIGRlZ3JlZXMuXHJcbiAgICAgKi9cclxuICAgIGdldENlbnRlckxhdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iZ01hcE9iamVjdC5nZXRDZW50ZXIoKS5sYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgY29ybmVyIGJvdW5kcyhOVywgU1csIE5FLCBTRSkgb2YgdGhlIGJhY2tncm91bmQgbWFwLlxyXG4gICAgICogQHJldHVybnMge3tOVzoge2xuZzogbnVtYmVyLCBsYXQ6IG51bWJlcn0sIFNXOiB7bG5nOiBudW1iZXIsIGxhdDogbnVtYmVyfSwgTkU6IHtsbmc6IG51bWJlciwgbGF0OiBudW1iZXJ9LCBTRToge2xuZzogbnVtYmVyLCBsYXQ6IG51bWJlcn19fSBkZXNjcmlwdGlvblxyXG4gICAgICogQGRlcHJlY2F0ZWQgTm90IHVzZWQgYXRtLlxyXG4gICAgICogQG1lbWJlck9mIEJHTWFwV3JhcHBlclxyXG4gICAgICovXHJcbiAgICBnZXRNYXBCb3VuZHMoKSB7XHJcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuYmdNYXBPYmplY3Q7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgTlc6IHtcclxuICAgICAgICAgICAgICAgIGxuZzogbWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLmxuZyxcclxuICAgICAgICAgICAgICAgIGxhdDogbWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLmxhdFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBTVzoge1xyXG4gICAgICAgICAgICAgICAgbG5nOiBtYXAuZ2V0Qm91bmRzKCkuZ2V0U291dGhXZXN0KCkubG5nLFxyXG4gICAgICAgICAgICAgICAgbGF0OiBtYXAuZ2V0Qm91bmRzKCkuZ2V0U291dGhXZXN0KCkubGF0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIE5FOiB7XHJcbiAgICAgICAgICAgICAgICBsbmc6IG1hcC5nZXRCb3VuZHMoKS5nZXROb3J0aEVhc3QoKS5sbmcsXHJcbiAgICAgICAgICAgICAgICBsYXQ6IG1hcC5nZXRCb3VuZHMoKS5nZXROb3J0aEVhc3QoKS5sYXRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgU0U6IHtcclxuICAgICAgICAgICAgICAgIGxuZzogbWFwLmdldEJvdW5kcygpLmdldFNvdXRoRWFzdCgpLmxuZyxcclxuICAgICAgICAgICAgICAgIGxhdDogbWFwLmdldEJvdW5kcygpLmdldFNvdXRoRWFzdCgpLmxhdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmaWVzIGlmIHRoZSBiYWNrZ3JvdW5kIG1hcCBiZWluZyBzaG93biBpcyBpbiB0d28gZGlmZmVyZW50IG1lcmlkaWFucy5cclxuICAgICAqIEBwYXJhbSB7e2xuZzogbnVtYmVyLCBsYXQ6IG51bWJlcn19IE5XIC0gTm9ydGggd2VzdCBjb3JuZXIgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSB7e2xuZzogbnVtYmVyLCBsYXQ6IG51bWJlcn19IE5FIC0gTm9ydGggRWFzdCBjb3JuZXIgY29vcmRpbmF0ZXNcclxuICAgICAqIEBkZXByZWNhdGVkIE5vdCB1c2VkIGF0bS5cclxuICAgICAqIEBtZW1iZXJPZiBCR01hcFdyYXBwZXJcclxuICAgICAqL1xyXG4gICAgaXNJbk11bHRpcGxlTWVyaWRpYW5zKE5XLCBORSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byBhIHNwZWNpZmllZCBldmVudCB0eXBlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50c3RyIC0gVGhlIGV2ZW50IHR5cGUgdG8gYWRkIGEgbGlzdGVuIGZvci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50ZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIGRhdGEgb2JqZWN0IHBhc3NlZCB0byAgZmlyZSAsIGV4dGVuZGVkIHdpdGggIHRhcmdldCBhbmQgIHR5cGUgcHJvcGVydGllcy5cclxuICAgICAqIEByZXR1cm4ge3ZvaWR9IFxyXG4gICAgICovXHJcbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50c3RyLCBldmVudGZ1bmN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5iZ01hcE9iamVjdC5vbihldmVudHN0ciwgZXZlbnRmdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBsb2FkZXIgYXQgdGhlIGJlZ2lubmluZyB3aGVuIHRoZSBBUEkgaXMgbG9hZGluZyB0aGUgZGF0YS5cclxuICAgICAqIEByZXR1cm4ge3ZvaWR9IFxyXG4gICAgICogQHNlZSBQYWdlIDcyIERpb2dvJ3MgdGhlc2lzLlxyXG4gICAgICovXHJcbiAgICBzaG93TG9hZGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxvYWRlckRpdiA9PT0gdW5kZWZpbmVkKSAvL0BUT0RPOiBSRU1PVkUgSWYgKFNlZSBNMSArIE04KSBcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVMb2FkZXIoKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJylcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lLmluY2x1ZGVzKCdfZ2lzcGxheWhpZGRlbicpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lID0gdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5aGlkZGVuKD8hXFxTKS9nLCAnX2dpc3BsYXlMb2FkZXJPdXRlckRpdicpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUgPSB0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUucmVwbGFjZSgvKD86XnxcXHMpX2dpc3BsYXlMb2FkZXJPdXRlckRpdig/IVxcUykvZywgJ19naXNwbGF5aGlkZGVuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXV4aWxpYXIgbWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGxvYWRlciAgYW5kIHdlIHdhbnQgdG8gY3JlYXRlIG9uZS5cclxuICAgICAqIEByZXR1cm4ge3ZvaWR9IFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVMb2FkZXIoKSB7XHJcbiAgICAgICAgY29uc3Qgb3V0ZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb25zdCBpbm5lckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGlubmVyRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheWxvYWRlcic7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcERpdiA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgb3V0ZXJEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5TG9hZGVyT3V0ZXJEaXYnO1xyXG4gICAgICAgIG91dGVyRGl2LnN0eWxlLmhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgb3V0ZXJEaXYuc3R5bGUud2lkdGggPSBtYXBEaXYub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgb3V0ZXJEaXYuYXBwZW5kQ2hpbGQoaW5uZXJEaXYpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkaXYgdGhhdCBjb250YWlucyB0aGUgbG9hZGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvYWRlckRpdiA9IG91dGVyRGl2O1xyXG4gICAgICAgIG1hcERpdi5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShvdXRlckRpdiwgbWFwRGl2KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJhY2tncm91bmQgbWFwIG9iamVjdC4gVGhpcyBpcyB0aGUgQmFja2dyb3VuZCBwcm92aWRlciBvYmplY3QgKGUuZy4sIE1hcGJveCwgR01hcHMsIEhlcmVNYXBzLCBCaW5nIE1hcHMpLlxyXG4gICAgICogQHJldHVybnMge0JHTWFwV3JhcHBlciNiZ01hcE9iamVjdH0gdGhlIGJhY2tncm91bmQgbWFwIG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJPZiBCR01hcFdyYXBwZXJcclxuICAgICAqL1xyXG4gICAgZ2V0QmFja2dyb3VuZE1hcFByb3ZpZGVyT2JqZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJnTWFwT2JqZWN0O1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQWJBO0FBa0JBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./src/Gisplay/Maps/Aesthetic.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Aesthetic = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Feature = __webpack_require__(/*! ./Feature */ 8);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Class that represents an aesthetic element. There will be one Aesthetic class for each class on the Legend.\r\n * @export\r\n * @class Aesthetic\r\n */\nvar Aesthetic = exports.Aesthetic = function () {\n\n    /**\r\n     * Creates an instance of Aesthetic. \r\n     * There will be as many Aesthetic objects as the number of classes on the Legend. \r\n     * @example 1-> {\"id\":0,\"attr\":\"f3\",\"fcolor\":[255,255,255,0.8],\r\n     *         \"stroke\":[0,0,0,1],\"pointsize\":null,\"range\":[1,37]}\r\n     * @example 2-> {\"id\":1,\"attr\":\"f3\",\"fcolor\":[255,255,0,0.8],\r\n     *         \"stroke\":[0,0,0,1],\"pointsize\":null,\"range\":[37,78]}\r\n     * @param {number} id - The unique id of the Aesthetic object.\r\n     * @param {string} attr - The attribute being mapped on this Aesthetic.\r\n     * @param {number[]|Function} fcolor - The color to fill the Aesthetic element(RGBA).\r\n     * @param {number[]} stroke - Stroke color values(RGBA).\r\n     * @param {number|null} pointsize - Size of the Aesthetic point to be drawn (Used only in maps that require dots to be drawn).\r\n     * @param {number[]} range - The range for this particular Aesthetic element.\r\n     * \r\n     * @memberOf Aesthetic\r\n     */\n    function Aesthetic(id, attr, fcolor, stroke, pointsize, range) {\n        _classCallCheck(this, Aesthetic);\n\n        /**\r\n         * The unique id of the Aesthetic object. \r\n         * @type {number}\r\n         */\n        this.id = id;\n        /**\r\n         * The attribute being mapped on the Aesthetic.\r\n         * @type {string}\r\n         */\n        this._attr = attr;\n        /**\r\n         * The color to fill the Aesthetic element(RGBA) OR a function to create this color.\r\n         * @type {number[4]|Function}\r\n         */\n        this.fillColor = fcolor;\n        /**\r\n         * Stroke color values(RGBA).\r\n         * @type {number[4]}\r\n         */\n        this.strokeColor = stroke;\n        /**\r\n         * The size of the Aesthetic point to be drawn (Used only in maps that require dots to be drawn).\r\n         * @type {number|null}\r\n         */\n        this.pointSize = pointsize === null ? 1.0 : parseFloat(pointsize);\n        /**\r\n         * The range for this particular Aesthetic element.\r\n         * @type {number[2]}\r\n         */\n        this.range = range;\n        /**\r\n         * This Array will keep track of all Features associated with this Aesthetic object.\r\n         * @type {Array<Feature>}\r\n         */\n        this._features = new Array();\n        /**\r\n         * This Array is used for? \r\n         * @todo\r\n         * @type {Array<Feature>}\r\n         */\n        this._allFeatures = new Array();\n        /**\r\n         * This particular element will be active or not in the Legend.\r\n         * @type {boolean}\r\n         */\n        this.enabled = true; //Elemento da legenda ativo ou desativo\n        /**\r\n         * Outer is used for the last element of the Legend. Example [500, 1000]<\r\n         * @type {boolean}\r\n         */\n        this.outer = false;\n    }\n\n    /**\r\n     * Adds a new feature to this Aesthetic object.\r\n     * @param {number} id - The Feature id. Each feature will have a different id inside this Aesthetic object.\r\n     * @param {{fx: string, _gisplayid:number}} properties - Properties associated with the Feature.\r\n     * @param {{itemSize: number, numItems: number}} triangles - Number of triangles associated with the Feature.\r\n     * @param {{itemSize: number, numItems: number}} borders - Number of borders associated with the Feature.\r\n     * @param {{itemSize: number, numItems: number}} points - The points that belong to the Feature.\r\n     * \r\n     * @memberOf Aesthetic\r\n     */\n\n\n    _createClass(Aesthetic, [{\n        key: 'addFeature',\n        value: function addFeature(id, properties, triangles, borders, points) {\n            this._features.push(new _Feature.Feature(id, properties, triangles, borders, points));\n        }\n\n        /**\r\n         * Gets this Aesthetic attribute.\r\n         * @returns {Aesthetic._attr} - The string representing the attr of this Aesthetic.\r\n         * \r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'getAttr',\n        value: function getAttr() {\n            return this._attr;\n        }\n\n        /**\r\n         * Verifies the existence or not of the property Aesthethic._attr and if it fits inside this Aesthetic range.\r\n         * @param {string} value - The attribute ?.\r\n         * @returns {boolean} - True if there's no range or it is inside the range or ?, otherwise, false.\r\n         * \r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'checkProperty',\n        value: function checkProperty(value) {\n            if (this.range === null) return true;else {\n                if (typeof value === 'number') return (this.range[0] === null || value >= this.range[0]) && (this.range[1] === null || value < this.range[1] || value <= this.range[1] && this.isOuter());else return value === this.range[0];\n            }\n        }\n\n        /**\r\n         * Add new grouped feature. Only used for Maps with points. \r\n         * @todo Finish document of this method.\r\n         * @param {number} id - The id of the Feature.\r\n         * @param {{buffer: WebGLBuffer, itemSize: number, numItems: number}} triangles - Triangles that belong to the Feature.\r\n         * @param {{buffer: WebGLBuffer, itemSize: number, numItems: number}} borders - Borders that belong to the Feature.\r\n         * @param {{buffer: WebGLBuffer, itemSize: number, numItems: number}} points - Points that belong to the Feature.\r\n         * @see Diogo's thesis page 57/58\r\n         */\n\n    }, {\n        key: 'addGroupedFeature',\n        value: function addGroupedFeature(id, triangles, borders, points) {\n            this._allFeatures.push(new _Feature.Feature(id, null, triangles, borders, points));\n        }\n\n        /**\r\n         * Inverts this Aesthetic element state in the Legend object.\r\n         * If it was enabled it will be disabled or vice-versa.\r\n         * @returns {boolean} Inverse of current enabled value.\r\n         */\n\n    }, {\n        key: 'enableDisable',\n        value: function enableDisable() {\n            this.enabled = !this.enabled;\n            return this.enabled;\n        }\n\n        /**\r\n         * Returns all Features that belong to this Aesthetic object.\r\n         * @returns {Array<Feature>} - All the Features of this Aeshtetic.\r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'getFeatures',\n        value: function getFeatures() {\n            return this._features;\n        }\n\n        /**\r\n         * Returns all Features as one?\r\n         * @returns {Array<Feature>} - All features grouped together?\r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'getAllFeatures',\n        value: function getAllFeatures() {\n            return this._allFeatures;\n        }\n\n        /**\r\n         * Returns the stroke color for this Aesthetic object.\r\n         * @returns {Aesthetic#strokeColor}\r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'getStrokeColor',\n        value: function getStrokeColor() {\n            return this.strokeColor;\n        }\n\n        /**\r\n         * Returns the fill color for this Aesthetic object.\r\n         * @returns {Aesthetic#fillColor}\r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'getFillColor',\n        value: function getFillColor() {\n            return this.fillColor;\n        }\n\n        /**\r\n         * Returns the size of this Aesthetic points.\r\n         * @returns {number} - The size of the point. \r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'getPointSize',\n        value: function getPointSize() {\n            return this.pointSize;\n        }\n\n        /**\r\n         * Returns if this Aesthetic is outer or not.\r\n         * @returns {boolean} - true if it is outer, false, otherwise.\r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'isOuter',\n        value: function isOuter() {\n            return this.outer;\n        }\n\n        /**\r\n         * Verifies if this Aeshtetic element is enable on the Legend or not.\r\n         * @returns {boolean} - True if it's enabled, false, otherwise.\r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'isEnabled',\n        value: function isEnabled() {\n            return this.enabled;\n        }\n    }]);\n\n    return Aesthetic;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0Flc3RoZXRpYy5qcz8wZTVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICcuL0ZlYXR1cmUnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhbiBhZXN0aGV0aWMgZWxlbWVudC4gVGhlcmUgd2lsbCBiZSBvbmUgQWVzdGhldGljIGNsYXNzIGZvciBlYWNoIGNsYXNzIG9uIHRoZSBMZWdlbmQuXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIEFlc3RoZXRpY1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFlc3RoZXRpYyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEFlc3RoZXRpYy4gXHJcbiAgICAgKiBUaGVyZSB3aWxsIGJlIGFzIG1hbnkgQWVzdGhldGljIG9iamVjdHMgYXMgdGhlIG51bWJlciBvZiBjbGFzc2VzIG9uIHRoZSBMZWdlbmQuIFxyXG4gICAgICogQGV4YW1wbGUgMS0+IHtcImlkXCI6MCxcImF0dHJcIjpcImYzXCIsXCJmY29sb3JcIjpbMjU1LDI1NSwyNTUsMC44XSxcclxuICAgICAqICAgICAgICAgXCJzdHJva2VcIjpbMCwwLDAsMV0sXCJwb2ludHNpemVcIjpudWxsLFwicmFuZ2VcIjpbMSwzN119XHJcbiAgICAgKiBAZXhhbXBsZSAyLT4ge1wiaWRcIjoxLFwiYXR0clwiOlwiZjNcIixcImZjb2xvclwiOlsyNTUsMjU1LDAsMC44XSxcclxuICAgICAqICAgICAgICAgXCJzdHJva2VcIjpbMCwwLDAsMV0sXCJwb2ludHNpemVcIjpudWxsLFwicmFuZ2VcIjpbMzcsNzhdfVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gVGhlIHVuaXF1ZSBpZCBvZiB0aGUgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIC0gVGhlIGF0dHJpYnV0ZSBiZWluZyBtYXBwZWQgb24gdGhpcyBBZXN0aGV0aWMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfEZ1bmN0aW9ufSBmY29sb3IgLSBUaGUgY29sb3IgdG8gZmlsbCB0aGUgQWVzdGhldGljIGVsZW1lbnQoUkdCQSkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBzdHJva2UgLSBTdHJva2UgY29sb3IgdmFsdWVzKFJHQkEpLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gcG9pbnRzaXplIC0gU2l6ZSBvZiB0aGUgQWVzdGhldGljIHBvaW50IHRvIGJlIGRyYXduIChVc2VkIG9ubHkgaW4gbWFwcyB0aGF0IHJlcXVpcmUgZG90cyB0byBiZSBkcmF3bikuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSByYW5nZSAtIFRoZSByYW5nZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIEFlc3RoZXRpYyBlbGVtZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgQWVzdGhldGljXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlkLCBhdHRyLCBmY29sb3IsIHN0cm9rZSwgcG9pbnRzaXplLCByYW5nZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmlxdWUgaWQgb2YgdGhlIEFlc3RoZXRpYyBvYmplY3QuIFxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhdHRyaWJ1dGUgYmVpbmcgbWFwcGVkIG9uIHRoZSBBZXN0aGV0aWMuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hdHRyID0gYXR0cjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sb3IgdG8gZmlsbCB0aGUgQWVzdGhldGljIGVsZW1lbnQoUkdCQSkgT1IgYSBmdW5jdGlvbiB0byBjcmVhdGUgdGhpcyBjb2xvci5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyWzRdfEZ1bmN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gZmNvbG9yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0cm9rZSBjb2xvciB2YWx1ZXMoUkdCQSkuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcls0XX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gc3Ryb2tlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBBZXN0aGV0aWMgcG9pbnQgdG8gYmUgZHJhd24gKFVzZWQgb25seSBpbiBtYXBzIHRoYXQgcmVxdWlyZSBkb3RzIHRvIGJlIGRyYXduKS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb2ludFNpemUgPSBwb2ludHNpemUgPT09IG51bGwgPyAxLjAgOiBwYXJzZUZsb2F0KHBvaW50c2l6ZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJhbmdlIGZvciB0aGlzIHBhcnRpY3VsYXIgQWVzdGhldGljIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlclsyXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBBcnJheSB3aWxsIGtlZXAgdHJhY2sgb2YgYWxsIEZlYXR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEFlc3RoZXRpYyBvYmplY3QuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEZlYXR1cmU+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBBcnJheSBpcyB1c2VkIGZvcj8gXHJcbiAgICAgICAgICogQHRvZG9cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RmVhdHVyZT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYWxsRmVhdHVyZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHBhcnRpY3VsYXIgZWxlbWVudCB3aWxsIGJlIGFjdGl2ZSBvciBub3QgaW4gdGhlIExlZ2VuZC5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlOy8vRWxlbWVudG8gZGEgbGVnZW5kYSBhdGl2byBvdSBkZXNhdGl2b1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE91dGVyIGlzIHVzZWQgZm9yIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIExlZ2VuZC4gRXhhbXBsZSBbNTAwLCAxMDAwXTxcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm91dGVyID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGZlYXR1cmUgdG8gdGhpcyBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gVGhlIEZlYXR1cmUgaWQuIEVhY2ggZmVhdHVyZSB3aWxsIGhhdmUgYSBkaWZmZXJlbnQgaWQgaW5zaWRlIHRoaXMgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7e2Z4OiBzdHJpbmcsIF9naXNwbGF5aWQ6bnVtYmVyfX0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlLlxyXG4gICAgICogQHBhcmFtIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IHRyaWFuZ2xlcyAtIE51bWJlciBvZiB0cmlhbmdsZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlLlxyXG4gICAgICogQHBhcmFtIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IGJvcmRlcnMgLSBOdW1iZXIgb2YgYm9yZGVycyBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gcG9pbnRzIC0gVGhlIHBvaW50cyB0aGF0IGJlbG9uZyB0byB0aGUgRmVhdHVyZS5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEFlc3RoZXRpY1xyXG4gICAgICovXHJcbiAgICBhZGRGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzLnB1c2gobmV3IEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoaXMgQWVzdGhldGljIGF0dHJpYnV0ZS5cclxuICAgICAqIEByZXR1cm5zIHtBZXN0aGV0aWMuX2F0dHJ9IC0gVGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGF0dHIgb2YgdGhpcyBBZXN0aGV0aWMuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgZ2V0QXR0cigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXR0cjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmaWVzIHRoZSBleGlzdGVuY2Ugb3Igbm90IG9mIHRoZSBwcm9wZXJ0eSBBZXN0aGV0aGljLl9hdHRyIGFuZCBpZiBpdCBmaXRzIGluc2lkZSB0aGlzIEFlc3RoZXRpYyByYW5nZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBhdHRyaWJ1dGUgPy5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlcmUncyBubyByYW5nZSBvciBpdCBpcyBpbnNpZGUgdGhlIHJhbmdlIG9yID8sIG90aGVyd2lzZSwgZmFsc2UuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgY2hlY2tQcm9wZXJ0eSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJhbmdlID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh0aGlzLnJhbmdlWzBdID09PSBudWxsIHx8IHZhbHVlID49IHRoaXMucmFuZ2VbMF0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucmFuZ2VbMV0gPT09IG51bGwgfHwgKHZhbHVlIDwgdGhpcy5yYW5nZVsxXSB8fCAodmFsdWUgPD0gdGhpcy5yYW5nZVsxXSAmJiB0aGlzLmlzT3V0ZXIoKSkpKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IHRoaXMucmFuZ2VbMF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBuZXcgZ3JvdXBlZCBmZWF0dXJlLiBPbmx5IHVzZWQgZm9yIE1hcHMgd2l0aCBwb2ludHMuIFxyXG4gICAgICogQHRvZG8gRmluaXNoIGRvY3VtZW50IG9mIHRoaXMgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gVGhlIGlkIG9mIHRoZSBGZWF0dXJlLlxyXG4gICAgICogQHBhcmFtIHt7YnVmZmVyOiBXZWJHTEJ1ZmZlciwgaXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IHRyaWFuZ2xlcyAtIFRyaWFuZ2xlcyB0aGF0IGJlbG9uZyB0byB0aGUgRmVhdHVyZS5cclxuICAgICAqIEBwYXJhbSB7e2J1ZmZlcjogV2ViR0xCdWZmZXIsIGl0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fSBib3JkZXJzIC0gQm9yZGVycyB0aGF0IGJlbG9uZyB0byB0aGUgRmVhdHVyZS5cclxuICAgICAqIEBwYXJhbSB7e2J1ZmZlcjogV2ViR0xCdWZmZXIsIGl0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fSBwb2ludHMgLSBQb2ludHMgdGhhdCBiZWxvbmcgdG8gdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBAc2VlIERpb2dvJ3MgdGhlc2lzIHBhZ2UgNTcvNThcclxuICAgICAqL1xyXG4gICAgYWRkR3JvdXBlZEZlYXR1cmUoaWQsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsRmVhdHVyZXMucHVzaChuZXcgRmVhdHVyZShpZCwgbnVsbCwgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludmVydHMgdGhpcyBBZXN0aGV0aWMgZWxlbWVudCBzdGF0ZSBpbiB0aGUgTGVnZW5kIG9iamVjdC5cclxuICAgICAqIElmIGl0IHdhcyBlbmFibGVkIGl0IHdpbGwgYmUgZGlzYWJsZWQgb3IgdmljZS12ZXJzYS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJbnZlcnNlIG9mIGN1cnJlbnQgZW5hYmxlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlRGlzYWJsZSgpIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSAhdGhpcy5lbmFibGVkO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBGZWF0dXJlcyB0aGF0IGJlbG9uZyB0byB0aGlzIEFlc3RoZXRpYyBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8RmVhdHVyZT59IC0gQWxsIHRoZSBGZWF0dXJlcyBvZiB0aGlzIEFlc2h0ZXRpYy5cclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgZ2V0RmVhdHVyZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgRmVhdHVyZXMgYXMgb25lP1xyXG4gICAgICogQHJldHVybnMge0FycmF5PEZlYXR1cmU+fSAtIEFsbCBmZWF0dXJlcyBncm91cGVkIHRvZ2V0aGVyP1xyXG4gICAgICogQG1lbWJlck9mIEFlc3RoZXRpY1xyXG4gICAgICovXHJcbiAgICBnZXRBbGxGZWF0dXJlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsRmVhdHVyZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJva2UgY29sb3IgZm9yIHRoaXMgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtBZXN0aGV0aWMjc3Ryb2tlQ29sb3J9XHJcbiAgICAgKiBAbWVtYmVyT2YgQWVzdGhldGljXHJcbiAgICAgKi9cclxuICAgIGdldFN0cm9rZUNvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlsbCBjb2xvciBmb3IgdGhpcyBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge0Flc3RoZXRpYyNmaWxsQ29sb3J9XHJcbiAgICAgKiBAbWVtYmVyT2YgQWVzdGhldGljXHJcbiAgICAgKi9cclxuICAgIGdldEZpbGxDb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxsQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoaXMgQWVzdGhldGljIHBvaW50cy5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIHBvaW50LiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgZ2V0UG9pbnRTaXplKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpZiB0aGlzIEFlc3RoZXRpYyBpcyBvdXRlciBvciBub3QuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGl0IGlzIG91dGVyLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlck9mIEFlc3RoZXRpY1xyXG4gICAgICovXHJcbiAgICBpc091dGVyKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZmllcyBpZiB0aGlzIEFlc2h0ZXRpYyBlbGVtZW50IGlzIGVuYWJsZSBvbiB0aGUgTGVnZW5kIG9yIG5vdC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgaXQncyBlbmFibGVkLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlck9mIEFlc3RoZXRpY1xyXG4gICAgICovXHJcbiAgICBpc0VuYWJsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0Flc3RoZXRpYy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/Gisplay/Maps/Types/DotMap.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DotMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ../Map */ 2);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * DotMap implemenetation\r\n */\nvar DotMap = exports.DotMap = function (_Map) {\n    _inherits(DotMap, _Map);\n\n    /**\r\n     * Creates an instance of DotMap.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} options - User options to be used.\r\n     * @memberOf DotMap\r\n     */\n    function DotMap(bgmap, geometry, options) {\n        _classCallCheck(this, DotMap);\n\n        var _this = _possibleConstructorReturn(this, (DotMap.__proto__ || Object.getPrototypeOf(DotMap)).call(this, bgmap, geometry, options));\n\n        _this.loadOptions(options, bgmap);\n        _this.initializeCanvasAndEvents();\n        return _this;\n    }\n\n    /**\r\n     * Draw Dot map, at the beginning and when the map is moved.\r\n     * @see initialize() and makeMap() methods.\r\n     * @override\r\n     * @memberOf DotMap\r\n     */\n\n\n    _createClass(DotMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var aes = _step.value;\n\n                    if (aes.isEnabled()) this.drawPoints(aes);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Method called to build the Map Legend.\r\n         * For all Aesthethics that exist crate one point row and then insert the Legend to the map\r\n         * @override \r\n         * @memberOf DotMap\r\n         */\n\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            /**\r\n             * The Legend to be used through the life of the map.\r\n             * @type {Legend} \r\n             */\n            this.legend = new _Legend.Legend(this.id, this.gisplayOptions.legendTitle);\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.aesthetics[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var aes = _step2.value;\n\n                    this.legend.insertPointRow(aes, this);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.legend.insertLegend(this.bGMap);\n        }\n\n        /**\r\n         * Returns the color scheme and number of classes associated with the id given.\r\n         * @param {number} defaultColorSchemeId \r\n         * @returns {{colorScheme: string[], numberOfClasses: number}}\r\n         * @override \r\n         * @memberOf DotMap\r\n         */\n\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultColorSchemeId) {\n            var options = {};\n            switch (defaultColorSchemeId) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    break;\n            }\n            options.numberOfClasses = 1;\n            return options;\n        }\n    }]);\n\n    return DotMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL1R5cGVzL0RvdE1hcC5qcz8xODEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcCB9IGZyb20gJy4uL01hcCc7XHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZCc7XHJcblxyXG4vKipcclxuICogRG90TWFwIGltcGxlbWVuZXRhdGlvblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERvdE1hcCBleHRlbmRzIE1hcCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIERvdE1hcC5cclxuICAgICAqIEBwYXJhbSB7QkdNYXBXcmFwcGVyfSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBKU09OIG9iamVjdCB3aXRoIHRoZSBnZW9tZXRyeSB0aGF0IHdhcyByZWFkIGZyb20gdGhlIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFVzZXIgb3B0aW9ucyB0byBiZSB1c2VkLlxyXG4gICAgICogQG1lbWJlck9mIERvdE1hcFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNhbnZhc0FuZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBEb3QgbWFwLCBhdCB0aGUgYmVnaW5uaW5nIGFuZCB3aGVuIHRoZSBtYXAgaXMgbW92ZWQuXHJcbiAgICAgKiBAc2VlIGluaXRpYWxpemUoKSBhbmQgbWFrZU1hcCgpIG1ldGhvZHMuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBtZW1iZXJPZiBEb3RNYXBcclxuICAgICAqL1xyXG4gICAgZHJhdygpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhZXMgb2YgdGhpcy5hZXN0aGV0aWNzKVxyXG4gICAgICAgICAgICBpZiAoYWVzLmlzRW5hYmxlZCgpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UG9pbnRzKGFlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRob2QgY2FsbGVkIHRvIGJ1aWxkIHRoZSBNYXAgTGVnZW5kLlxyXG4gICAgICogRm9yIGFsbCBBZXN0aGV0aGljcyB0aGF0IGV4aXN0IGNyYXRlIG9uZSBwb2ludCByb3cgYW5kIHRoZW4gaW5zZXJ0IHRoZSBMZWdlbmQgdG8gdGhlIG1hcFxyXG4gICAgICogQG92ZXJyaWRlIFxyXG4gICAgICogQG1lbWJlck9mIERvdE1hcFxyXG4gICAgICovXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgTGVnZW5kIHRvIGJlIHVzZWQgdGhyb3VnaCB0aGUgbGlmZSBvZiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEB0eXBlIHtMZWdlbmR9IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmlkLCB0aGlzLmdpc3BsYXlPcHRpb25zLmxlZ2VuZFRpdGxlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGFlcyBvZiB0aGlzLmFlc3RoZXRpY3MpXHJcbiAgICAgICAgICAgIHRoaXMubGVnZW5kLmluc2VydFBvaW50Um93KGFlcywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0TGVnZW5kKHRoaXMuYkdNYXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29sb3Igc2NoZW1lIGFuZCBudW1iZXIgb2YgY2xhc3NlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGlkIGdpdmVuLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRDb2xvclNjaGVtZUlkIFxyXG4gICAgICogQHJldHVybnMge3tjb2xvclNjaGVtZTogc3RyaW5nW10sIG51bWJlck9mQ2xhc3NlczogbnVtYmVyfX1cclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBEb3RNYXBcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHMoZGVmYXVsdENvbG9yU2NoZW1lSWQpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XHJcbiAgICAgICAgc3dpdGNoIChkZWZhdWx0Q29sb3JTY2hlbWVJZCkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gW1wiIzQ0MDE1NFwiLCBcIiM0NDAyNTZcIiwgXCIjNDUwNDU3XCIsIFwiIzQ1MDU1OVwiLCBcIiM0NjA3NWFcIiwgXCIjNDYwODVjXCIsIFwiIzQ2MGE1ZFwiLCBcIiM0NjBiNWVcIiwgXCIjNDcwZDYwXCIsIFwiIzQ3MGU2MVwiLCBcIiM0NzEwNjNcIiwgXCIjNDcxMTY0XCIsIFwiIzQ3MTM2NVwiLCBcIiM0ODE0NjdcIiwgXCIjNDgxNjY4XCIsIFwiIzQ4MTc2OVwiLCBcIiM0ODE4NmFcIiwgXCIjNDgxYTZjXCIsIFwiIzQ4MWI2ZFwiLCBcIiM0ODFjNmVcIiwgXCIjNDgxZDZmXCIsIFwiIzQ4MWY3MFwiLCBcIiM0ODIwNzFcIiwgXCIjNDgyMTczXCIsIFwiIzQ4MjM3NFwiLCBcIiM0ODI0NzVcIiwgXCIjNDgyNTc2XCIsIFwiIzQ4MjY3N1wiLCBcIiM0ODI4NzhcIiwgXCIjNDgyOTc5XCIsIFwiIzQ3MmE3YVwiLCBcIiM0NzJjN2FcIiwgXCIjNDcyZDdiXCIsIFwiIzQ3MmU3Y1wiLCBcIiM0NzJmN2RcIiwgXCIjNDYzMDdlXCIsIFwiIzQ2MzI3ZVwiLCBcIiM0NjMzN2ZcIiwgXCIjNDYzNDgwXCIsIFwiIzQ1MzU4MVwiLCBcIiM0NTM3ODFcIiwgXCIjNDUzODgyXCIsIFwiIzQ0Mzk4M1wiLCBcIiM0NDNhODNcIiwgXCIjNDQzYjg0XCIsIFwiIzQzM2Q4NFwiLCBcIiM0MzNlODVcIiwgXCIjNDIzZjg1XCIsIFwiIzQyNDA4NlwiLCBcIiM0MjQxODZcIiwgXCIjNDE0Mjg3XCIsIFwiIzQxNDQ4N1wiLCBcIiM0MDQ1ODhcIiwgXCIjNDA0Njg4XCIsIFwiIzNmNDc4OFwiLCBcIiMzZjQ4ODlcIiwgXCIjM2U0OTg5XCIsIFwiIzNlNGE4OVwiLCBcIiMzZTRjOGFcIiwgXCIjM2Q0ZDhhXCIsIFwiIzNkNGU4YVwiLCBcIiMzYzRmOGFcIiwgXCIjM2M1MDhiXCIsIFwiIzNiNTE4YlwiLCBcIiMzYjUyOGJcIiwgXCIjM2E1MzhiXCIsIFwiIzNhNTQ4Y1wiLCBcIiMzOTU1OGNcIiwgXCIjMzk1NjhjXCIsIFwiIzM4NTg4Y1wiLCBcIiMzODU5OGNcIiwgXCIjMzc1YThjXCIsIFwiIzM3NWI4ZFwiLCBcIiMzNjVjOGRcIiwgXCIjMzY1ZDhkXCIsIFwiIzM1NWU4ZFwiLCBcIiMzNTVmOGRcIiwgXCIjMzQ2MDhkXCIsIFwiIzM0NjE4ZFwiLCBcIiMzMzYyOGRcIiwgXCIjMzM2MzhkXCIsIFwiIzMyNjQ4ZVwiLCBcIiMzMjY1OGVcIiwgXCIjMzE2NjhlXCIsIFwiIzMxNjc4ZVwiLCBcIiMzMTY4OGVcIiwgXCIjMzA2OThlXCIsIFwiIzMwNmE4ZVwiLCBcIiMyZjZiOGVcIiwgXCIjMmY2YzhlXCIsIFwiIzJlNmQ4ZVwiLCBcIiMyZTZlOGVcIiwgXCIjMmU2ZjhlXCIsIFwiIzJkNzA4ZVwiLCBcIiMyZDcxOGVcIiwgXCIjMmM3MThlXCIsIFwiIzJjNzI4ZVwiLCBcIiMyYzczOGVcIiwgXCIjMmI3NDhlXCIsIFwiIzJiNzU4ZVwiLCBcIiMyYTc2OGVcIiwgXCIjMmE3NzhlXCIsIFwiIzJhNzg4ZVwiLCBcIiMyOTc5OGVcIiwgXCIjMjk3YThlXCIsIFwiIzI5N2I4ZVwiLCBcIiMyODdjOGVcIiwgXCIjMjg3ZDhlXCIsIFwiIzI3N2U4ZVwiLCBcIiMyNzdmOGVcIiwgXCIjMjc4MDhlXCIsIFwiIzI2ODE4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjY4MjhlXCIsIFwiIzI1ODM4ZVwiLCBcIiMyNTg0OGVcIiwgXCIjMjU4NThlXCIsIFwiIzI0ODY4ZVwiLCBcIiMyNDg3OGVcIiwgXCIjMjM4ODhlXCIsIFwiIzIzODk4ZVwiLCBcIiMyMzhhOGRcIiwgXCIjMjI4YjhkXCIsIFwiIzIyOGM4ZFwiLCBcIiMyMjhkOGRcIiwgXCIjMjE4ZThkXCIsIFwiIzIxOGY4ZFwiLCBcIiMyMTkwOGRcIiwgXCIjMjE5MThjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkyOGNcIiwgXCIjMjA5MzhjXCIsIFwiIzFmOTQ4Y1wiLCBcIiMxZjk1OGJcIiwgXCIjMWY5NjhiXCIsIFwiIzFmOTc4YlwiLCBcIiMxZjk4OGJcIiwgXCIjMWY5OThhXCIsIFwiIzFmOWE4YVwiLCBcIiMxZTliOGFcIiwgXCIjMWU5Yzg5XCIsIFwiIzFlOWQ4OVwiLCBcIiMxZjllODlcIiwgXCIjMWY5Zjg4XCIsIFwiIzFmYTA4OFwiLCBcIiMxZmExODhcIiwgXCIjMWZhMTg3XCIsIFwiIzFmYTI4N1wiLCBcIiMyMGEzODZcIiwgXCIjMjBhNDg2XCIsIFwiIzIxYTU4NVwiLCBcIiMyMWE2ODVcIiwgXCIjMjJhNzg1XCIsIFwiIzIyYTg4NFwiLCBcIiMyM2E5ODNcIiwgXCIjMjRhYTgzXCIsIFwiIzI1YWI4MlwiLCBcIiMyNWFjODJcIiwgXCIjMjZhZDgxXCIsIFwiIzI3YWQ4MVwiLCBcIiMyOGFlODBcIiwgXCIjMjlhZjdmXCIsIFwiIzJhYjA3ZlwiLCBcIiMyY2IxN2VcIiwgXCIjMmRiMjdkXCIsIFwiIzJlYjM3Y1wiLCBcIiMyZmI0N2NcIiwgXCIjMzFiNTdiXCIsIFwiIzMyYjY3YVwiLCBcIiMzNGI2NzlcIiwgXCIjMzViNzc5XCIsIFwiIzM3Yjg3OFwiLCBcIiMzOGI5NzdcIiwgXCIjM2FiYTc2XCIsIFwiIzNiYmI3NVwiLCBcIiMzZGJjNzRcIiwgXCIjM2ZiYzczXCIsIFwiIzQwYmQ3MlwiLCBcIiM0MmJlNzFcIiwgXCIjNDRiZjcwXCIsIFwiIzQ2YzA2ZlwiLCBcIiM0OGMxNmVcIiwgXCIjNGFjMTZkXCIsIFwiIzRjYzI2Y1wiLCBcIiM0ZWMzNmJcIiwgXCIjNTBjNDZhXCIsIFwiIzUyYzU2OVwiLCBcIiM1NGM1NjhcIiwgXCIjNTZjNjY3XCIsIFwiIzU4Yzc2NVwiLCBcIiM1YWM4NjRcIiwgXCIjNWNjODYzXCIsIFwiIzVlYzk2MlwiLCBcIiM2MGNhNjBcIiwgXCIjNjNjYjVmXCIsIFwiIzY1Y2I1ZVwiLCBcIiM2N2NjNWNcIiwgXCIjNjljZDViXCIsIFwiIzZjY2Q1YVwiLCBcIiM2ZWNlNThcIiwgXCIjNzBjZjU3XCIsIFwiIzczZDA1NlwiLCBcIiM3NWQwNTRcIiwgXCIjNzdkMTUzXCIsIFwiIzdhZDE1MVwiLCBcIiM3Y2QyNTBcIiwgXCIjN2ZkMzRlXCIsIFwiIzgxZDM0ZFwiLCBcIiM4NGQ0NGJcIiwgXCIjODZkNTQ5XCIsIFwiIzg5ZDU0OFwiLCBcIiM4YmQ2NDZcIiwgXCIjOGVkNjQ1XCIsIFwiIzkwZDc0M1wiLCBcIiM5M2Q3NDFcIiwgXCIjOTVkODQwXCIsIFwiIzk4ZDgzZVwiLCBcIiM5YmQ5M2NcIiwgXCIjOWRkOTNiXCIsIFwiI2EwZGEzOVwiLCBcIiNhMmRhMzdcIiwgXCIjYTVkYjM2XCIsIFwiI2E4ZGIzNFwiLCBcIiNhYWRjMzJcIiwgXCIjYWRkYzMwXCIsIFwiI2IwZGQyZlwiLCBcIiNiMmRkMmRcIiwgXCIjYjVkZTJiXCIsIFwiI2I4ZGUyOVwiLCBcIiNiYWRlMjhcIiwgXCIjYmRkZjI2XCIsIFwiI2MwZGYyNVwiLCBcIiNjMmRmMjNcIiwgXCIjYzVlMDIxXCIsIFwiI2M4ZTAyMFwiLCBcIiNjYWUxMWZcIiwgXCIjY2RlMTFkXCIsIFwiI2QwZTExY1wiLCBcIiNkMmUyMWJcIiwgXCIjZDVlMjFhXCIsIFwiI2Q4ZTIxOVwiLCBcIiNkYWUzMTlcIiwgXCIjZGRlMzE4XCIsIFwiI2RmZTMxOFwiLCBcIiNlMmU0MThcIiwgXCIjZTVlNDE5XCIsIFwiI2U3ZTQxOVwiLCBcIiNlYWU1MWFcIiwgXCIjZWNlNTFiXCIsIFwiI2VmZTUxY1wiLCBcIiNmMWU1MWRcIiwgXCIjZjRlNjFlXCIsIFwiI2Y2ZTYyMFwiLCBcIiNmOGU2MjFcIiwgXCIjZmJlNzIzXCIsIFwiI2ZkZTcyNVwiXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gWydwdXJwbGUnLCAnb3JhbmdlJywgJ2JsdWUnLCAneWVsbG93JywgJ3BpbmsnLCAnZ3JlZW4nLCAncmVkJywgJ25hdnknXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMubnVtYmVyT2ZDbGFzc2VzID0gMTtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL1R5cGVzL0RvdE1hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUxBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Gisplay.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Gisplay = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth = __webpack_require__(/*! ./Maps/Types/Choropleth */ 0);\n\nvar _DotMap = __webpack_require__(/*! ./Maps/Types/DotMap */ 5);\n\nvar _ChangeMap = __webpack_require__(/*! ./Maps/Types/ChangeMap */ 9);\n\nvar _ProportionalSymbolsMap = __webpack_require__(/*! ./Maps/Types/ProportionalSymbolsMap */ 11);\n\nvar _ChorochromaticMap = __webpack_require__(/*! ./Maps/Types/ChorochromaticMap */ 10);\n\nvar _ChoroplethGoogleMaps = __webpack_require__(/*! ./Maps/v11/1_BackgroundMaps/ChoroplethGoogleMaps */ 14);\n\nvar _ChoroplethHereMaps = __webpack_require__(/*! ./Maps/v11/1_BackgroundMaps/ChoroplethHereMaps */ 15);\n\nvar _ChoroplethBingMaps = __webpack_require__(/*! ./Maps/v11/1_BackgroundMaps/ChoroplethBingMaps */ 13);\n\nvar _DotMapGoogleMaps = __webpack_require__(/*! ./Maps/v11/1_BackgroundMaps/DotMapGoogleMaps */ 16);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Gisplay API entry point with one method for each map available.\r\n */\nvar Gisplay = exports.Gisplay = function () {\n\n    /**\r\n     * Creates an instance of the Gisplay API.\r\n     * @memberOf Gisplay\r\n     */\n    function Gisplay() {\n        _classCallCheck(this, Gisplay);\n\n        // console.log(\"Gisplay Class constructor\");\n        /**\r\n         * TimeStamp at the beginning.\r\n         * @type {number} \r\n         * @deprecated\r\n         */\n        this.startTimeStamp = 0;\n\n        /**\r\n         * Whether or not it  should profile the API.\r\n         * @type {string} - Whether or not it  should profile the API.\r\n         */\n        window.profiling = true;\n        /**\r\n         * @type {Array} - Array of maps. @WHY?\r\n         */\n        window.maps = new Array();\n        /**\r\n         * @type {number} - The number of maps. Used to mark each one with a different id.\r\n         */\n        window.mapcount = 0;\n\n        //WebGL API\n        /**\r\n         * @type {number} - The number of vertices produced. @WHY?\r\n         * @deprecated\r\n         */\n        window._vertexcount = 0;\n        /**\r\n         * @type {number} - The number of ???. @WHY?\r\n         * @deprecated\r\n         */\n        window._tricount = 0;\n    }\n\n    /**\r\n     * Creates a map of type Choropleth.\r\n     * @param {Object} bgmap - Background map object be used(atm only MapBox being used).- Background map object be used(atm only MapBox being used).\r\n     * @param {JSON} geometry - The object that contains the data.\r\n     * @param {Object} options - Object that contains user personalization options.\r\n     * @memberOf Gisplay\r\n     */\n\n\n    _createClass(Gisplay, [{\n        key: 'makeChoropleth',\n        value: function makeChoropleth(bgmap, geometry, options) {\n            var gismap = new _Choropleth.Choropleth(bgmap, geometry, options);\n            gismap.makeMap(); //this.makeMap(gismap, options);\n        }\n\n        /**\r\n         * Creates a Dot Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeDotMap',\n        value: function makeDotMap(bgmap, geometry, options) {\n            var gismap = new _DotMap.DotMap(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n\n        /**\r\n         * Creates a Change Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChangeMap',\n        value: function makeChangeMap(bgmap, geometry, options) {\n            var gismap = new _ChangeMap.ChangeMap(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n\n        /**\r\n         * Creates a Proportional Symbols Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeProportionalSymbolsMap',\n        value: function makeProportionalSymbolsMap(bgmap, geometry, options) {\n            var gismap = new _ProportionalSymbolsMap.ProportionalSymbolsMap(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n\n        /**\r\n         * Creates a Chorocromatic Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChorochromaticMap',\n        value: function makeChorochromaticMap(bgmap, geometry, options) {\n            var gismap = new _ChorochromaticMap.ChorochromaticMap(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n\n        /* ######################     Background Map Providers      ############### */\n        /**\r\n         * Creates a map of type Choropleth with background map being from Google Maps.\r\n         * @param {Object} bgmap - Background map object be used, in this case Google Maps.\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChoroplethGoogleMaps',\n        value: function makeChoroplethGoogleMaps(bgmap, geometry, options) {\n            var gismap = new _ChoroplethGoogleMaps.ChoroplethGoogleMaps(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n\n        /**\r\n         * Creates a map of type Choropleth with background map being from Here Maps.\r\n         * @param {Object} bgmap - Background map object be used, in this case Here Maps.\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChoroplethHereMaps',\n        value: function makeChoroplethHereMaps(bgmap, geometry, options) {\n            var gismap = new _ChoroplethHereMaps.ChoroplethHereMaps(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n\n        /**\r\n         * Creates a map of type Choropleth with background map being from Bing Maps.\r\n         * @param {Object} bgmap - Background map object be used, in this case Bing Maps.\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChoroplethBingMaps',\n        value: function makeChoroplethBingMaps(bgmap, geometry, options) {\n            var gismap = new _ChoroplethBingMaps.ChoroplethBingMaps(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n\n        /**\r\n         * Creates a map of type Dot Map with background map being from Google Maps.\r\n         * @param {Object} bgmap - Background map object be used, in this case Google Maps.\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeDotMapGoogleMaps',\n        value: function makeDotMapGoogleMaps(bgmap, geometry, options) {\n            var gismap = new _DotMapGoogleMaps.DotMapGoogleMaps(bgmap, geometry, options);\n            gismap.makeMap();\n        }\n    }]);\n\n    return Gisplay;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5LmpzPzA1YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hvcm9wbGV0aCB9IGZyb20gJy4vTWFwcy9UeXBlcy9DaG9yb3BsZXRoJztcclxuaW1wb3J0IHsgRG90TWFwIH0gZnJvbSAnLi9NYXBzL1R5cGVzL0RvdE1hcCc7XHJcbmltcG9ydCB7IENoYW5nZU1hcCB9IGZyb20gJy4vTWFwcy9UeXBlcy9DaGFuZ2VNYXAnO1xyXG5pbXBvcnQgeyBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwIH0gZnJvbSAnLi9NYXBzL1R5cGVzL1Byb3BvcnRpb25hbFN5bWJvbHNNYXAnO1xyXG5pbXBvcnQgeyBDaG9yb2Nocm9tYXRpY01hcCB9IGZyb20gJy4vTWFwcy9UeXBlcy9DaG9yb2Nocm9tYXRpY01hcCc7XHJcbmltcG9ydCB7IENob3JvcGxldGhHb29nbGVNYXBzIH0gZnJvbSAnLi9NYXBzL3YxMS8xX0JhY2tncm91bmRNYXBzL0Nob3JvcGxldGhHb29nbGVNYXBzJztcclxuaW1wb3J0IHsgQ2hvcm9wbGV0aEhlcmVNYXBzIH0gZnJvbSAnLi9NYXBzL3YxMS8xX0JhY2tncm91bmRNYXBzL0Nob3JvcGxldGhIZXJlTWFwcyc7XHJcbmltcG9ydCB7IENob3JvcGxldGhCaW5nTWFwcyB9IGZyb20gJy4vTWFwcy92MTEvMV9CYWNrZ3JvdW5kTWFwcy9DaG9yb3BsZXRoQmluZ01hcHMnO1xyXG5pbXBvcnQgeyBEb3RNYXBHb29nbGVNYXBzIH0gZnJvbSAnLi9NYXBzL3YxMS8xX0JhY2tncm91bmRNYXBzL0RvdE1hcEdvb2dsZU1hcHMnO1xyXG5cclxuLyoqXHJcbiAqIEdpc3BsYXkgQVBJIGVudHJ5IHBvaW50IHdpdGggb25lIG1ldGhvZCBmb3IgZWFjaCBtYXAgYXZhaWxhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdpc3BsYXkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgR2lzcGxheSBBUEkuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkdpc3BsYXkgQ2xhc3MgY29uc3RydWN0b3JcIik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGltZVN0YW1wIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgaXQgIHNob3VsZCBwcm9maWxlIHRoZSBBUEkuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gLSBXaGV0aGVyIG9yIG5vdCBpdCAgc2hvdWxkIHByb2ZpbGUgdGhlIEFQSS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aW5kb3cucHJvZmlsaW5nID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9IC0gQXJyYXkgb2YgbWFwcy4gQFdIWT9cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aW5kb3cubWFwcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IC0gVGhlIG51bWJlciBvZiBtYXBzLiBVc2VkIHRvIG1hcmsgZWFjaCBvbmUgd2l0aCBhIGRpZmZlcmVudCBpZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aW5kb3cubWFwY291bnQgPSAwO1xyXG5cclxuICAgICAgICAvL1dlYkdMIEFQSVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBwcm9kdWNlZC4gQFdIWT9cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpbmRvdy5fdmVydGV4Y291bnQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IC0gVGhlIG51bWJlciBvZiA/Pz8uIEBXSFk/XHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB3aW5kb3cuX3RyaWNvdW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgb2YgdHlwZSBDaG9yb3BsZXRoLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQoYXRtIG9ubHkgTWFwQm94IGJlaW5nIHVzZWQpLi0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQoYXRtIG9ubHkgTWFwQm94IGJlaW5nIHVzZWQpLlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHRoYXQgY29udGFpbnMgdXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5XHJcbiAgICAgKi9cclxuICAgIG1ha2VDaG9yb3BsZXRoKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb3BsZXRoKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgZ2lzbWFwLm1ha2VNYXAoKTsgLy90aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBEb3QgTWFwLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQoYXRtIG9ubHkgTWFwQm94IGJlaW5nIHVzZWQpLlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHRoYXQgY29udGFpbnMgdXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5XHJcbiAgICAgKi9cclxuICAgIG1ha2VEb3RNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgZ2lzbWFwID0gbmV3IERvdE1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIGdpc21hcC5tYWtlTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgQ2hhbmdlIE1hcC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHVzZXIgcGVyc29uYWxpemF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlQ2hhbmdlTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaGFuZ2VNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICBnaXNtYXAubWFrZU1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFByb3BvcnRpb25hbCBTeW1ib2xzIE1hcC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHVzZXIgcGVyc29uYWxpemF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlUHJvcG9ydGlvbmFsU3ltYm9sc01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgUHJvcG9ydGlvbmFsU3ltYm9sc01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIGdpc21hcC5tYWtlTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgQ2hvcm9jcm9tYXRpYyBNYXAuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYmdtYXAgLSBCYWNrZ3JvdW5kIG1hcCBvYmplY3QgYmUgdXNlZChhdG0gb25seSBNYXBCb3ggYmVpbmcgdXNlZCkuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPYmplY3QgdGhhdCBjb250YWlucyB1c2VyIHBlcnNvbmFsaXphdGlvbiBvcHRpb25zLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZUNob3JvY2hyb21hdGljTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb2Nocm9tYXRpY01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIGdpc21hcC5tYWtlTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgQmFja2dyb3VuZCBNYXAgUHJvdmlkZXJzICAgICAgIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgb2YgdHlwZSBDaG9yb3BsZXRoIHdpdGggYmFja2dyb3VuZCBtYXAgYmVpbmcgZnJvbSBHb29nbGUgTWFwcy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkLCBpbiB0aGlzIGNhc2UgR29vZ2xlIE1hcHMuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPYmplY3QgdGhhdCBjb250YWlucyB1c2VyIHBlcnNvbmFsaXphdGlvbiBvcHRpb25zLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZUNob3JvcGxldGhHb29nbGVNYXBzKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb3BsZXRoR29vZ2xlTWFwcyhiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIGdpc21hcC5tYWtlTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIG9mIHR5cGUgQ2hvcm9wbGV0aCB3aXRoIGJhY2tncm91bmQgbWFwIGJlaW5nIGZyb20gSGVyZSBNYXBzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQsIGluIHRoaXMgY2FzZSBIZXJlIE1hcHMuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPYmplY3QgdGhhdCBjb250YWlucyB1c2VyIHBlcnNvbmFsaXphdGlvbiBvcHRpb25zLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZUNob3JvcGxldGhIZXJlTWFwcyhiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hvcm9wbGV0aEhlcmVNYXBzKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgZ2lzbWFwLm1ha2VNYXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgb2YgdHlwZSBDaG9yb3BsZXRoIHdpdGggYmFja2dyb3VuZCBtYXAgYmVpbmcgZnJvbSBCaW5nIE1hcHMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYmdtYXAgLSBCYWNrZ3JvdW5kIG1hcCBvYmplY3QgYmUgdXNlZCwgaW4gdGhpcyBjYXNlIEJpbmcgTWFwcy5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHVzZXIgcGVyc29uYWxpemF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlQ2hvcm9wbGV0aEJpbmdNYXBzKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb3BsZXRoQmluZ01hcHMoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICBnaXNtYXAubWFrZU1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1hcCBvZiB0eXBlIERvdCBNYXAgd2l0aCBiYWNrZ3JvdW5kIG1hcCBiZWluZyBmcm9tIEdvb2dsZSBNYXBzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQsIGluIHRoaXMgY2FzZSBHb29nbGUgTWFwcy5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHVzZXIgcGVyc29uYWxpemF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlRG90TWFwR29vZ2xlTWFwcyhiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgRG90TWFwR29vZ2xlTWFwcyhiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIGdpc21hcC5tYWtlTWFwKCk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvR2lzcGxheS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./src/Gisplay/GisplayOptions.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class will contain all the options available on the Gisplay API.\r\n * @see Diogo's thesis page 50-52\r\n */\nvar GisplayOptions = exports.GisplayOptions = function () {\n\n  /**\r\n   * Creates a new Options object. User options take precedence over default options.\r\n   * @param {Object} userOptions - The user defined options.\r\n   * @param {string} userOptions.attr -  The attribute to be mapped.\r\n   * @param {string[]} [userOptions.colorScheme] -  The color scheme to be used.\r\n   * @param {number} [userOptions.numberOfClasses] -  Number of classes to be used on the map Legend.\r\n   * @param {string} [userOptions.classBreaksMethod=quantile] -  Algorithm to be used by the API to calculate classes intervals. \r\n   * @param {number[]} [userOptions.classBreaks=undefined] - Class intervals.\r\n   * @param {boolean} [userOptions.interactive=true] - Show pop-up when the user clicks on a Feature.\r\n   * @param {boolean} [userOptions.showPropertiesOnClick=null] - Show pop-up when the user clicks on a Feature.\r\n   * @param {boolean} [userOptions.showLegend=true] - Show map Legend.\r\n   * @param {string} [userOptions.minuend=undefined] - The minimum property of the GeoJSON feature object.\r\n   * @param {string} [userOptions.subtrahend=undefined] - The property to subtract from minuend.\r\n   * @param {string} [userOptions.legendTitle=this.attr] - Legend title for the Legend.\r\n   * @param {boolean} [userOptions.showLoader=true] - Show loader when loading data.\r\n   * @param {boolean} [userOptions.useCustomMapService=false] - Use custom map service.\r\n   * @param {number} [userOptions.minPointSize=1.0] - Minimum point size.\r\n   * @param {number} [userOptions.maxPointSize=10.0] - Maximum point size.\r\n   * @param {boolean} [userOptions.sizeByClass=false] - Specify the size of the dots on a PSymbols Map using classes.\r\n   * @param {boolean} [userOptions.memorySaver=false] - Save memory on Dot Maps.\r\n   * @param {boolean} [userOptions.colorSchemeId=1] - The color scheme id to use.\r\n   * @param {Function} [userOptions.legendOnClickFunction] - Function to be called when the user clicks on a Legend class.\r\n   * @param {Function} [userOptions.mapOnClickFunction] - Function to be called when the user clicks on the Map (on a Feature).\r\n   * @param {number} [userOptions.alpha=0.8] - Alpha to be used in WebGL.\r\n   * @param {number} [userOptions.maxFeatures=Number.MAX_VALUE] - The max number of features to be displayed.\r\n   * @param {number} [userOptions.numberOfLegendItems=2] - The number of Legend items (Used on PSymbols Map).\r\n   * @param {number} [userOptions.intensity=1] - Intensity for Heat Map.\r\n   * @param {string} [userOptions.legendPosition=br] - The Legend position(br=bottom right).\r\n   * @param {number} [userOptions.legendNumberFormat=0] - Number of decimal numbers to show on the numerical values of the Legend.\r\n   * @param {number} [userOptions.tileSize=256] - Size of each background map tile.\r\n   */\n  function GisplayOptions(userOptions) {\n    _classCallCheck(this, GisplayOptions);\n\n    /**\r\n     * The attribute to be mapped.\r\n     * @see Chapter 4 Page 50 of Diogo's thesis.\r\n     * @type {string} \r\n     */\n    this.attr = userOptions.attr;\n    //TODO: Uncoment next line\n    //if(!this.attr) throw new Error(\"Attribute not defined in userOptions, please define one attribute to be mapped\");\n    /**\r\n     * Array of colors to be used by the API. \r\n     * @see Chapter 4 Page 50 of Diogo's thesis.\r\n     * @type {string[]}\r\n     */\n    this.colorScheme = userOptions.colorScheme;\n    /**\r\n     * Number of classes to be used on the map Legend. This option should be used when the user wants the API\r\n     * to calculate the classes (aka ranges) using the given number. Otherwise the API will calculate the appropriate number of classes to use.\r\n     * @type{number}\r\n     */\n    this.numberOfClasses = userOptions.numberOfClasses;\n    /**\r\n     * Algorithm to be used by the API to calculate classes intervals. \r\n     * Defaults to quantile if the user does not provide any or if it provides one that isn't on the list of available algorithms.\r\n     * Available options are 'quantile', 'equidistant', 'k-means'.\r\n     * @type {string}\r\n     */\n    this.classBreaksMethod = this.getAvailableClassBreaksMethods().indexOf(userOptions.classBreaksMethod) > 0 ? userOptions.classBreaksMethod : 'quantile';\n    /**\r\n     * Class intervals. If this is defined then numberOfClasses and classBreakMethod are ignored.\r\n     * @type {number[]}\r\n     */\n    this.classBreaks = userOptions.classBreaks; //undefined n era preciso\n    /**\r\n     * When we click on a feature that is on the map, show properties of said Feature or not.\r\n     * @type {boolean}\r\n     */\n    this.interactive = userOptions.interactive !== undefined ? userOptions.interactive : true;\n    /**\r\n     * Properties and description to be shown when the user clicks on a Feature.\r\n     * @todo NOT USED? \r\n     * @type {string[]}\r\n     */\n    this.showPropertiesOnClick = userOptions.showPropertiesOnClick || null;\n    /**\r\n     * Whether or not to show the map Legend.\r\n     * @type {boolean}\r\n     */\n    this.showLegend = userOptions.showLegend !== undefined ? userOptions.showLegend : true;\n    /**\r\n     * The minimum property of the GeoJSON feature object. Used on Change Map.\r\n     * @type {string}\r\n     */\n    this.minuend = userOptions.minuend;\n    /**\r\n     * The property of the GeoJSON feature object to subtract from the minimum. Used on Change Map.\r\n     * @type {string}\r\n     */\n    this.subtrahend = userOptions.subtrahend;\n    /**\r\n     * The title to be used on the Legend. Third option is used for Change Map.\r\n     * @type {string}\r\n     */\n    this.legendTitle = userOptions.legendTitle || this.attr || this.minuend + ' - ' + this.subtrahend;\n    /**\r\n     * Whether to show or not the loader when we the API is loading the needed data.\r\n     * @type {boolean}\r\n     */\n    this.showLoader = userOptions.showLoader || true;\n    /**\r\n     * True when the user wants to use another background map service than those who are supported by default by the API.\r\n     * If this is true then the user should send the custom map service when creating the new Map. \r\n     * @type {boolean} \r\n     */\n    this.useCustomMapService = userOptions.useCustomMapService || false;\n    /**\r\n     * The minimum size of the points to be drawn on the Map. Will be used on PSymbols and maybe on Dot Map/Heat Map.\r\n     * @type {number}\r\n     */\n    this.minPointSize = userOptions.minPointSize === undefined ? 1.0 : parseFloat(userOptions.minPointSize); //N preciso do if no PSymbols?\n    /**\r\n     * The maximum size of the points to be drawn on the Map. Will be used on PSymbols. The dot with highest value \r\n     * on the features will have the size given by the user.\r\n     * @type {number}\r\n     */\n    this.maxPointSize = userOptions.maxPointSize === undefined ? 10.0 : parseFloat(userOptions.maxPointSize); //N preciso do if no PSymbols?\n    /**\r\n     * If the user wants to specify the size of the dots on a PSymbols Map using classes, this attribute should be true.\r\n     * @type {boolean}\r\n     */\n    this.sizeByClass = userOptions.sizeByClass || false;\n    /**\r\n     * If false each feature will have it's own WebGLBuffer, otherwise the geometry will be grouped creating one WebGLBuffer by\r\n     * Aesthetic class. As the name implies allows memory saving and with this improves performance in lower end devices. \r\n     * Only Available/Relevant to Dot Maps.\r\n     * @type {boolean}\r\n     */\n    this.memorySaver = userOptions.memorySaver || true;\n    /**\r\n     * Allows the user to choose the color scheme id to be used to choose from the list of defaults color shemes availabe on the Map to be created.\r\n     * @type {number}\r\n     */\n    this.colorSchemeId = userOptions.colorSchemeId || 1;\n    /**\r\n     * Function to be called when the user clicks on a Legend class. This function should receive an object of type Aesthetic.\r\n     * @type {Function}\r\n     */\n    this.legendOnClickFunction = userOptions.legendOnClickFunction;\n    /**\r\n     * Function to be called when the user clicks on the Map (on a Feature). This function should receive an array, which are the Feature properties.\r\n     * @type {Function}\r\n     */\n    this.mapOnClickFunction = userOptions.mapOnClickFunction;\n\n    /** #####################       OTHER OPTIONS(Non Described on the Thesis draft)      ############################## */\n    /**\r\n     * Alpha to be used in WebGL.\r\n     * 0 means fully transparent <-> 1 fully opaque.\r\n     * @type {number}\r\n     */\n    this.alpha = userOptions.alpha || 0.8;\n    /**\r\n     * The max number of features to be displayed. If not given by the user then it is the maximum numnber allowed.\r\n     * Number.MAX_VALUE = 1.79E+308\r\n     * @type {number}\r\n     */\n    this.maxFeatures = userOptions.maxFeatures || Number.MAX_VALUE;\n    /**\r\n     * The number of legend items. Used for PSymbols Map.\r\n     * @type {number}\r\n     */\n    this.numberOfLegendItems = userOptions.numberOfLegendItems || 2;\n    /**\r\n     * The size of each background map tile. Used by most background map providers is 256.\r\n     * @type {number}\r\n     */\n    this.tileSize = userOptions.tileSize || 256;\n\n    /** #####################       OTHER NON-USER DEFINED OPTIONS      ############################## */\n    /**\r\n     * If it is dynamic or not. When dynamic is set to true it will join all Features on one Aesthetic class in the same Feature and this way it can draw all elements at once.\r\n     * It's the inverse of the memorySaver value.\r\n     * @type {boolean}\r\n     */\n    this.isDynamic = !this.memorySaver;\n\n    /**\r\n     * Enable/Disable Legend toggle.\r\n     * @type {boolean} \r\n     */\n    this.legendToggle = true;\n\n    /** #####################       DEPRECATED ############################## */\n    /**\r\n     * Intensity of a heat map. Higher values of intensity means more red in the end color. Otherwise more green.\r\n     * @deprecated Not used ATM, should probably be used for Heat Maps.\r\n     * @type {number}\r\n     */\n    this.intensity = userOptions.intensity || 1.0;\n    /**\r\n     * The user defined position of the Legend over the map. Allowed positions tl, tr, bl, br.\r\n     * @type {string}\r\n     * @deprecated Currently not in use. Maybe implement later.\r\n     */\n    this.legendPosition = userOptions.legendPosition || 'br';\n    /**\r\n     * Number of decimal numbers to show on the numerical values of the Legend.\r\n     * @deprecated Currently not in use. Maybe implement later.\r\n     * @type {number}\r\n     */\n    this.legendNumberFormat = userOptions.legendNumberFormat || 0;\n\n    /** #####################      OTHER GLOBAL OPTIONS     ############################## */\n    this.profiling = userOptions.profiling || true;\n  }\n\n  /**\r\n   * Returns the available class break methods.\r\n   * @returns {string[]} - All available class break methods under Gisplay API.\r\n   * @memberOf GisplayOptions\r\n   */\n\n\n  _createClass(GisplayOptions, [{\n    key: 'getAvailableClassBreaksMethods',\n    value: function getAvailableClassBreaksMethods() {\n      return [\"quantile\", \"k-means\", \"equidistant\"];\n    }\n  }]);\n\n  return GisplayOptions;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5T3B0aW9ucy5qcz8yMTY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGNsYXNzIHdpbGwgY29udGFpbiBhbGwgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIG9uIHRoZSBHaXNwbGF5IEFQSS5cclxuICogQHNlZSBEaW9nbydzIHRoZXNpcyBwYWdlIDUwLTUyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2lzcGxheU9wdGlvbnMge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25zIG9iamVjdC4gVXNlciBvcHRpb25zIHRha2UgcHJlY2VkZW5jZSBvdmVyIGRlZmF1bHQgb3B0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9ucyAtIFRoZSB1c2VyIGRlZmluZWQgb3B0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyT3B0aW9ucy5hdHRyIC0gIFRoZSBhdHRyaWJ1dGUgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3VzZXJPcHRpb25zLmNvbG9yU2NoZW1lXSAtICBUaGUgY29sb3Igc2NoZW1lIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPcHRpb25zLm51bWJlck9mQ2xhc3Nlc10gLSAgTnVtYmVyIG9mIGNsYXNzZXMgdG8gYmUgdXNlZCBvbiB0aGUgbWFwIExlZ2VuZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlck9wdGlvbnMuY2xhc3NCcmVha3NNZXRob2Q9cXVhbnRpbGVdIC0gIEFsZ29yaXRobSB0byBiZSB1c2VkIGJ5IHRoZSBBUEkgdG8gY2FsY3VsYXRlIGNsYXNzZXMgaW50ZXJ2YWxzLiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IFt1c2VyT3B0aW9ucy5jbGFzc0JyZWFrcz11bmRlZmluZWRdIC0gQ2xhc3MgaW50ZXJ2YWxzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXNlck9wdGlvbnMuaW50ZXJhY3RpdmU9dHJ1ZV0gLSBTaG93IHBvcC11cCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VyT3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2s9bnVsbF0gLSBTaG93IHBvcC11cCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VyT3B0aW9ucy5zaG93TGVnZW5kPXRydWVdIC0gU2hvdyBtYXAgTGVnZW5kLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VyT3B0aW9ucy5taW51ZW5kPXVuZGVmaW5lZF0gLSBUaGUgbWluaW11bSBwcm9wZXJ0eSBvZiB0aGUgR2VvSlNPTiBmZWF0dXJlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlck9wdGlvbnMuc3VidHJhaGVuZD11bmRlZmluZWRdIC0gVGhlIHByb3BlcnR5IHRvIHN1YnRyYWN0IGZyb20gbWludWVuZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlck9wdGlvbnMubGVnZW5kVGl0bGU9dGhpcy5hdHRyXSAtIExlZ2VuZCB0aXRsZSBmb3IgdGhlIExlZ2VuZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZXJPcHRpb25zLnNob3dMb2FkZXI9dHJ1ZV0gLSBTaG93IGxvYWRlciB3aGVuIGxvYWRpbmcgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZXJPcHRpb25zLnVzZUN1c3RvbU1hcFNlcnZpY2U9ZmFsc2VdIC0gVXNlIGN1c3RvbSBtYXAgc2VydmljZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXNlck9wdGlvbnMubWluUG9pbnRTaXplPTEuMF0gLSBNaW5pbXVtIHBvaW50IHNpemUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPcHRpb25zLm1heFBvaW50U2l6ZT0xMC4wXSAtIE1heGltdW0gcG9pbnQgc2l6ZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZXJPcHRpb25zLnNpemVCeUNsYXNzPWZhbHNlXSAtIFNwZWNpZnkgdGhlIHNpemUgb2YgdGhlIGRvdHMgb24gYSBQU3ltYm9scyBNYXAgdXNpbmcgY2xhc3Nlcy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZXJPcHRpb25zLm1lbW9yeVNhdmVyPWZhbHNlXSAtIFNhdmUgbWVtb3J5IG9uIERvdCBNYXBzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXNlck9wdGlvbnMuY29sb3JTY2hlbWVJZD0xXSAtIFRoZSBjb2xvciBzY2hlbWUgaWQgdG8gdXNlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3VzZXJPcHRpb25zLmxlZ2VuZE9uQ2xpY2tGdW5jdGlvbl0gLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYSBMZWdlbmQgY2xhc3MuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdXNlck9wdGlvbnMubWFwT25DbGlja0Z1bmN0aW9uXSAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgTWFwIChvbiBhIEZlYXR1cmUpLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy5hbHBoYT0wLjhdIC0gQWxwaGEgdG8gYmUgdXNlZCBpbiBXZWJHTC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXNlck9wdGlvbnMubWF4RmVhdHVyZXM9TnVtYmVyLk1BWF9WQUxVRV0gLSBUaGUgbWF4IG51bWJlciBvZiBmZWF0dXJlcyB0byBiZSBkaXNwbGF5ZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPcHRpb25zLm51bWJlck9mTGVnZW5kSXRlbXM9Ml0gLSBUaGUgbnVtYmVyIG9mIExlZ2VuZCBpdGVtcyAoVXNlZCBvbiBQU3ltYm9scyBNYXApLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy5pbnRlbnNpdHk9MV0gLSBJbnRlbnNpdHkgZm9yIEhlYXQgTWFwLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VyT3B0aW9ucy5sZWdlbmRQb3NpdGlvbj1icl0gLSBUaGUgTGVnZW5kIHBvc2l0aW9uKGJyPWJvdHRvbSByaWdodCkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPcHRpb25zLmxlZ2VuZE51bWJlckZvcm1hdD0wXSAtIE51bWJlciBvZiBkZWNpbWFsIG51bWJlcnMgdG8gc2hvdyBvbiB0aGUgbnVtZXJpY2FsIHZhbHVlcyBvZiB0aGUgTGVnZW5kLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy50aWxlU2l6ZT0yNTZdIC0gU2l6ZSBvZiBlYWNoIGJhY2tncm91bmQgbWFwIHRpbGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVzZXJPcHRpb25zKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZSB0byBiZSBtYXBwZWQuXHJcbiAgICAgICAgICogQHNlZSBDaGFwdGVyIDQgUGFnZSA1MCBvZiBEaW9nbydzIHRoZXNpcy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF0dHIgPSB1c2VyT3B0aW9ucy5hdHRyO1xyXG4gICAgICAgIC8vVE9ETzogVW5jb21lbnQgbmV4dCBsaW5lXHJcbiAgICAgICAgLy9pZighdGhpcy5hdHRyKSB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyaWJ1dGUgbm90IGRlZmluZWQgaW4gdXNlck9wdGlvbnMsIHBsZWFzZSBkZWZpbmUgb25lIGF0dHJpYnV0ZSB0byBiZSBtYXBwZWRcIik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJyYXkgb2YgY29sb3JzIHRvIGJlIHVzZWQgYnkgdGhlIEFQSS4gXHJcbiAgICAgICAgICogQHNlZSBDaGFwdGVyIDQgUGFnZSA1MCBvZiBEaW9nbydzIHRoZXNpcy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xvclNjaGVtZSA9IHVzZXJPcHRpb25zLmNvbG9yU2NoZW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiBjbGFzc2VzIHRvIGJlIHVzZWQgb24gdGhlIG1hcCBMZWdlbmQuIFRoaXMgb3B0aW9uIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdGhlIEFQSVxyXG4gICAgICAgICAqIHRvIGNhbGN1bGF0ZSB0aGUgY2xhc3NlcyAoYWthIHJhbmdlcykgdXNpbmcgdGhlIGdpdmVuIG51bWJlci4gT3RoZXJ3aXNlIHRoZSBBUEkgd2lsbCBjYWxjdWxhdGUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjbGFzc2VzIHRvIHVzZS5cclxuICAgICAgICAgKiBAdHlwZXtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5udW1iZXJPZkNsYXNzZXMgPSB1c2VyT3B0aW9ucy5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxnb3JpdGhtIHRvIGJlIHVzZWQgYnkgdGhlIEFQSSB0byBjYWxjdWxhdGUgY2xhc3NlcyBpbnRlcnZhbHMuIFxyXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHF1YW50aWxlIGlmIHRoZSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYW55IG9yIGlmIGl0IHByb3ZpZGVzIG9uZSB0aGF0IGlzbid0IG9uIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBhbGdvcml0aG1zLlxyXG4gICAgICAgICAqIEF2YWlsYWJsZSBvcHRpb25zIGFyZSAncXVhbnRpbGUnLCAnZXF1aWRpc3RhbnQnLCAnay1tZWFucycuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsYXNzQnJlYWtzTWV0aG9kID0gdGhpcy5nZXRBdmFpbGFibGVDbGFzc0JyZWFrc01ldGhvZHMoKS5pbmRleE9mKHVzZXJPcHRpb25zLmNsYXNzQnJlYWtzTWV0aG9kKSA+IDAgPyB1c2VyT3B0aW9ucy5jbGFzc0JyZWFrc01ldGhvZCA6ICdxdWFudGlsZSc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xhc3MgaW50ZXJ2YWxzLiBJZiB0aGlzIGlzIGRlZmluZWQgdGhlbiBudW1iZXJPZkNsYXNzZXMgYW5kIGNsYXNzQnJlYWtNZXRob2QgYXJlIGlnbm9yZWQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xhc3NCcmVha3MgPSB1c2VyT3B0aW9ucy5jbGFzc0JyZWFrczsgLy91bmRlZmluZWQgbiBlcmEgcHJlY2lzb1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gd2UgY2xpY2sgb24gYSBmZWF0dXJlIHRoYXQgaXMgb24gdGhlIG1hcCwgc2hvdyBwcm9wZXJ0aWVzIG9mIHNhaWQgRmVhdHVyZSBvciBub3QuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9ICh1c2VyT3B0aW9ucy5pbnRlcmFjdGl2ZSAhPT0gdW5kZWZpbmVkKSA/IHVzZXJPcHRpb25zLmludGVyYWN0aXZlIDogdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIGFuZCBkZXNjcmlwdGlvbiB0byBiZSBzaG93biB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIEZlYXR1cmUuXHJcbiAgICAgICAgICogQHRvZG8gTk9UIFVTRUQ/IFxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNob3dQcm9wZXJ0aWVzT25DbGljayA9IHVzZXJPcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljayB8fCBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIG1hcCBMZWdlbmQuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaG93TGVnZW5kID0gKHVzZXJPcHRpb25zLnNob3dMZWdlbmQgIT09IHVuZGVmaW5lZCkgPyB1c2VyT3B0aW9ucy5zaG93TGVnZW5kIDogdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBwcm9wZXJ0eSBvZiB0aGUgR2VvSlNPTiBmZWF0dXJlIG9iamVjdC4gVXNlZCBvbiBDaGFuZ2UgTWFwLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5taW51ZW5kID0gdXNlck9wdGlvbnMubWludWVuZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcHJvcGVydHkgb2YgdGhlIEdlb0pTT04gZmVhdHVyZSBvYmplY3QgdG8gc3VidHJhY3QgZnJvbSB0aGUgbWluaW11bS4gVXNlZCBvbiBDaGFuZ2UgTWFwLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdWJ0cmFoZW5kID0gdXNlck9wdGlvbnMuc3VidHJhaGVuZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGl0bGUgdG8gYmUgdXNlZCBvbiB0aGUgTGVnZW5kLiBUaGlyZCBvcHRpb24gaXMgdXNlZCBmb3IgQ2hhbmdlIE1hcC5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGVnZW5kVGl0bGUgPSB1c2VyT3B0aW9ucy5sZWdlbmRUaXRsZSB8fCB0aGlzLmF0dHIgfHwgKGAke3RoaXMubWludWVuZH0gLSAke3RoaXMuc3VidHJhaGVuZH1gKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIHNob3cgb3Igbm90IHRoZSBsb2FkZXIgd2hlbiB3ZSB0aGUgQVBJIGlzIGxvYWRpbmcgdGhlIG5lZWRlZCBkYXRhLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hvd0xvYWRlciA9IHVzZXJPcHRpb25zLnNob3dMb2FkZXIgfHwgdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcnVlIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gdXNlIGFub3RoZXIgYmFja2dyb3VuZCBtYXAgc2VydmljZSB0aGFuIHRob3NlIHdobyBhcmUgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgdGhlIEFQSS5cclxuICAgICAgICAgKiBJZiB0aGlzIGlzIHRydWUgdGhlbiB0aGUgdXNlciBzaG91bGQgc2VuZCB0aGUgY3VzdG9tIG1hcCBzZXJ2aWNlIHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBNYXAuIFxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVzZUN1c3RvbU1hcFNlcnZpY2UgPSB1c2VyT3B0aW9ucy51c2VDdXN0b21NYXBTZXJ2aWNlIHx8IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgb2YgdGhlIHBvaW50cyB0byBiZSBkcmF3biBvbiB0aGUgTWFwLiBXaWxsIGJlIHVzZWQgb24gUFN5bWJvbHMgYW5kIG1heWJlIG9uIERvdCBNYXAvSGVhdCBNYXAuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1pblBvaW50U2l6ZSA9IHVzZXJPcHRpb25zLm1pblBvaW50U2l6ZSA9PT0gdW5kZWZpbmVkID8gMS4wIDogcGFyc2VGbG9hdCh1c2VyT3B0aW9ucy5taW5Qb2ludFNpemUpOyAvL04gcHJlY2lzbyBkbyBpZiBubyBQU3ltYm9scz9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBwb2ludHMgdG8gYmUgZHJhd24gb24gdGhlIE1hcC4gV2lsbCBiZSB1c2VkIG9uIFBTeW1ib2xzLiBUaGUgZG90IHdpdGggaGlnaGVzdCB2YWx1ZSBcclxuICAgICAgICAgKiBvbiB0aGUgZmVhdHVyZXMgd2lsbCBoYXZlIHRoZSBzaXplIGdpdmVuIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhQb2ludFNpemUgPSB1c2VyT3B0aW9ucy5tYXhQb2ludFNpemUgPT09IHVuZGVmaW5lZCA/IDEwLjAgOiBwYXJzZUZsb2F0KHVzZXJPcHRpb25zLm1heFBvaW50U2l6ZSk7IC8vTiBwcmVjaXNvIGRvIGlmIG5vIFBTeW1ib2xzP1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSB1c2VyIHdhbnRzIHRvIHNwZWNpZnkgdGhlIHNpemUgb2YgdGhlIGRvdHMgb24gYSBQU3ltYm9scyBNYXAgdXNpbmcgY2xhc3NlcywgdGhpcyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHRydWUuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaXplQnlDbGFzcyA9IHVzZXJPcHRpb25zLnNpemVCeUNsYXNzIHx8IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGZhbHNlIGVhY2ggZmVhdHVyZSB3aWxsIGhhdmUgaXQncyBvd24gV2ViR0xCdWZmZXIsIG90aGVyd2lzZSB0aGUgZ2VvbWV0cnkgd2lsbCBiZSBncm91cGVkIGNyZWF0aW5nIG9uZSBXZWJHTEJ1ZmZlciBieVxyXG4gICAgICAgICAqIEFlc3RoZXRpYyBjbGFzcy4gQXMgdGhlIG5hbWUgaW1wbGllcyBhbGxvd3MgbWVtb3J5IHNhdmluZyBhbmQgd2l0aCB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIGluIGxvd2VyIGVuZCBkZXZpY2VzLiBcclxuICAgICAgICAgKiBPbmx5IEF2YWlsYWJsZS9SZWxldmFudCB0byBEb3QgTWFwcy5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1lbW9yeVNhdmVyID0gdXNlck9wdGlvbnMubWVtb3J5U2F2ZXIgfHwgdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gY2hvb3NlIHRoZSBjb2xvciBzY2hlbWUgaWQgdG8gYmUgdXNlZCB0byBjaG9vc2UgZnJvbSB0aGUgbGlzdCBvZiBkZWZhdWx0cyBjb2xvciBzaGVtZXMgYXZhaWxhYmUgb24gdGhlIE1hcCB0byBiZSBjcmVhdGVkLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xvclNjaGVtZUlkID0gdXNlck9wdGlvbnMuY29sb3JTY2hlbWVJZCB8fCAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIExlZ2VuZCBjbGFzcy4gVGhpcyBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSBhbiBvYmplY3Qgb2YgdHlwZSBBZXN0aGV0aWMuXHJcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGVnZW5kT25DbGlja0Z1bmN0aW9uID0gdXNlck9wdGlvbnMubGVnZW5kT25DbGlja0Z1bmN0aW9uO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgTWFwIChvbiBhIEZlYXR1cmUpLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZWNlaXZlIGFuIGFycmF5LCB3aGljaCBhcmUgdGhlIEZlYXR1cmUgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXBPbkNsaWNrRnVuY3Rpb24gPSB1c2VyT3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb247XHJcblxyXG4gICAgICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgICAgT1RIRVIgT1BUSU9OUyhOb24gRGVzY3JpYmVkIG9uIHRoZSBUaGVzaXMgZHJhZnQpICAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxwaGEgdG8gYmUgdXNlZCBpbiBXZWJHTC5cclxuICAgICAgICAgKiAwIG1lYW5zIGZ1bGx5IHRyYW5zcGFyZW50IDwtPiAxIGZ1bGx5IG9wYXF1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSB1c2VyT3B0aW9ucy5hbHBoYSB8fCAwLjg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1heCBudW1iZXIgb2YgZmVhdHVyZXMgdG8gYmUgZGlzcGxheWVkLiBJZiBub3QgZ2l2ZW4gYnkgdGhlIHVzZXIgdGhlbiBpdCBpcyB0aGUgbWF4aW11bSBudW1uYmVyIGFsbG93ZWQuXHJcbiAgICAgICAgICogTnVtYmVyLk1BWF9WQUxVRSA9IDEuNzlFKzMwOFxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhGZWF0dXJlcyA9IHVzZXJPcHRpb25zLm1heEZlYXR1cmVzIHx8IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBsZWdlbmQgaXRlbXMuIFVzZWQgZm9yIFBTeW1ib2xzIE1hcC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubnVtYmVyT2ZMZWdlbmRJdGVtcyA9IHVzZXJPcHRpb25zLm51bWJlck9mTGVnZW5kSXRlbXMgfHwgMjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiBlYWNoIGJhY2tncm91bmQgbWFwIHRpbGUuIFVzZWQgYnkgbW9zdCBiYWNrZ3JvdW5kIG1hcCBwcm92aWRlcnMgaXMgMjU2LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IHVzZXJPcHRpb25zLnRpbGVTaXplIHx8IDI1NjtcclxuXHJcbiAgICAgICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgICBPVEhFUiBOT04tVVNFUiBERUZJTkVEIE9QVElPTlMgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBpdCBpcyBkeW5hbWljIG9yIG5vdC4gV2hlbiBkeW5hbWljIGlzIHNldCB0byB0cnVlIGl0IHdpbGwgam9pbiBhbGwgRmVhdHVyZXMgb24gb25lIEFlc3RoZXRpYyBjbGFzcyBpbiB0aGUgc2FtZSBGZWF0dXJlIGFuZCB0aGlzIHdheSBpdCBjYW4gZHJhdyBhbGwgZWxlbWVudHMgYXQgb25jZS5cclxuICAgICAgICAgKiBJdCdzIHRoZSBpbnZlcnNlIG9mIHRoZSBtZW1vcnlTYXZlciB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzRHluYW1pYyA9ICF0aGlzLm1lbW9yeVNhdmVyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGUvRGlzYWJsZSBMZWdlbmQgdG9nZ2xlLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxlZ2VuZFRvZ2dsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgICAgREVQUkVDQVRFRCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlbnNpdHkgb2YgYSBoZWF0IG1hcC4gSGlnaGVyIHZhbHVlcyBvZiBpbnRlbnNpdHkgbWVhbnMgbW9yZSByZWQgaW4gdGhlIGVuZCBjb2xvci4gT3RoZXJ3aXNlIG1vcmUgZ3JlZW4uXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgTm90IHVzZWQgQVRNLCBzaG91bGQgcHJvYmFibHkgYmUgdXNlZCBmb3IgSGVhdCBNYXBzLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbnRlbnNpdHkgPSB1c2VyT3B0aW9ucy5pbnRlbnNpdHkgfHwgMS4wO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1c2VyIGRlZmluZWQgcG9zaXRpb24gb2YgdGhlIExlZ2VuZCBvdmVyIHRoZSBtYXAuIEFsbG93ZWQgcG9zaXRpb25zIHRsLCB0ciwgYmwsIGJyLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgQ3VycmVudGx5IG5vdCBpbiB1c2UuIE1heWJlIGltcGxlbWVudCBsYXRlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxlZ2VuZFBvc2l0aW9uID0gdXNlck9wdGlvbnMubGVnZW5kUG9zaXRpb24gfHwgJ2JyJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgZGVjaW1hbCBudW1iZXJzIHRvIHNob3cgb24gdGhlIG51bWVyaWNhbCB2YWx1ZXMgb2YgdGhlIExlZ2VuZC5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBDdXJyZW50bHkgbm90IGluIHVzZS4gTWF5YmUgaW1wbGVtZW50IGxhdGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZWdlbmROdW1iZXJGb3JtYXQgPSB1c2VyT3B0aW9ucy5sZWdlbmROdW1iZXJGb3JtYXQgfHwgMDtcclxuXHJcbiAgICAgICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgIE9USEVSIEdMT0JBTCBPUFRJT05TICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgICAgICB0aGlzLnByb2ZpbGluZyA9IHVzZXJPcHRpb25zLnByb2ZpbGluZyB8fCB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYXZhaWxhYmxlIGNsYXNzIGJyZWFrIG1ldGhvZHMuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQWxsIGF2YWlsYWJsZSBjbGFzcyBicmVhayBtZXRob2RzIHVuZGVyIEdpc3BsYXkgQVBJLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlPcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGdldEF2YWlsYWJsZUNsYXNzQnJlYWtzTWV0aG9kcygpe1xyXG4gICAgICAgIHJldHVybiBbXCJxdWFudGlsZVwiLCBcImstbWVhbnNcIiwgXCJlcXVpZGlzdGFudFwiXTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9HaXNwbGF5T3B0aW9ucy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBO0FBQUE7QUFDQTtBQUFBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./src/Gisplay/Maps/Feature.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//Intermediate API\n\n/**\r\n * This class represents a Feature. Each feature belongs to one Aesthetic element.\r\n * @exports Feature\r\n * @class Feature\r\n */\nvar Feature = exports.Feature = function () {\n  /**\r\n   * Creates an instance of Feature.\r\n   * @example 1-> {\"id\":0,\"properties\":{\"f1\":\"Alabama\",\"f2\":\"Autauga\",\"f3\":150,\"_gisplayid\":0},\r\n                   \"triangles\":[{\"itemSize\":2,\"numItems\":417}],\"borders\":[{\"itemSize\":2,\"numItems\":141}],\"points\":[]}\r\n   * @param {number} id - This Feature id.\r\n   * @param {{fx: string, _gisplayid:number}} properties - Properties associated with this Feature.  \r\n   * @param {{itemSize: number, numItems: number}} triangles - Number of triangles associated with this Feature. \r\n   * @param {{itemSize: number, numItems: number}} borders - Number of borders associated with this Feature.\r\n   * @param {number[]} points - The points that belong to this Feature.\r\n   * \r\n   * @memberOf Feature\r\n   */\n  function Feature(id, properties, triangles, borders, points) {\n    _classCallCheck(this, Feature);\n\n    /**\r\n     * This Feature id.\r\n     * @type {number} \r\n     */\n    this._id = id;\n    /**\r\n     * Properties associated with this Feature.\r\n     * @type {{fx: string, _gisplayid:number}}  \r\n     */\n    this._properties = properties;\n    /**\r\n     * Number of triangles associated with this Feature. The Object that contains the itemSize and numItems is a WebGLBuffer.\r\n     * @type {{itemSize: number, numItems: number}}\r\n     */\n    this._triangles = triangles;\n    /**\r\n     * Number of borders associated with this Feature. The Object that contains the itemSize and numItems is a WebGLBuffer.\r\n     * @type {{itemSize: number, numItems: number}}\r\n     */\n    this._borders = borders;\n    /**\r\n     * The points that belong to this Feature.  The Object that contains the itemSize and numItems is a WebGLBuffer.\r\n     * @type {{itemSize: number, numItems: number}}\r\n     */\n    this._points = points;\n  }\n\n  /**\r\n   * Returns all triangles that belong to the Feature.\r\n   * @returns {Feature._triangles} - All triangles that belong to the Feature.\r\n   * @memberOf Feature\r\n   */\n\n\n  _createClass(Feature, [{\n    key: \"getTriangles\",\n    value: function getTriangles() {\n      return this._triangles;\n    }\n\n    /**\r\n     * Returns all borders that belong to the Feature.\r\n     * @returns {Feature._borders} - All borders that belong to the Feature.\r\n     * @memberOf Feature\r\n     */\n\n  }, {\n    key: \"getBorders\",\n    value: function getBorders() {\n      return this._borders;\n    }\n\n    /**\r\n     * Returns all points that belong to the Feature.\r\n     * @returns {Feature._points} - All points that belong to the Feature.\r\n     * @memberOf Feature\r\n     */\n\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      return this._points;\n    }\n\n    /**\r\n     * Returns all properties that belong to the Feature.\r\n     * @returns {Feature._properties}\r\n     * @memberOf Feature\r\n     */\n\n  }, {\n    key: \"getProperties\",\n    value: function getProperties() {\n      return this._properties;\n    }\n  }]);\n\n  return Feature;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0ZlYXR1cmUuanM/YTM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL0ludGVybWVkaWF0ZSBBUElcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBGZWF0dXJlLiBFYWNoIGZlYXR1cmUgYmVsb25ncyB0byBvbmUgQWVzdGhldGljIGVsZW1lbnQuXHJcbiAqIEBleHBvcnRzIEZlYXR1cmVcclxuICogQGNsYXNzIEZlYXR1cmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZWF0dXJlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBGZWF0dXJlLlxyXG4gICAgICogQGV4YW1wbGUgMS0+IHtcImlkXCI6MCxcInByb3BlcnRpZXNcIjp7XCJmMVwiOlwiQWxhYmFtYVwiLFwiZjJcIjpcIkF1dGF1Z2FcIixcImYzXCI6MTUwLFwiX2dpc3BsYXlpZFwiOjB9LFxyXG4gICAgICAgICAgICAgICAgICAgICBcInRyaWFuZ2xlc1wiOlt7XCJpdGVtU2l6ZVwiOjIsXCJudW1JdGVtc1wiOjQxN31dLFwiYm9yZGVyc1wiOlt7XCJpdGVtU2l6ZVwiOjIsXCJudW1JdGVtc1wiOjE0MX1dLFwicG9pbnRzXCI6W119XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGlzIEZlYXR1cmUgaWQuXHJcbiAgICAgKiBAcGFyYW0ge3tmeDogc3RyaW5nLCBfZ2lzcGxheWlkOm51bWJlcn19IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZlYXR1cmUuICBcclxuICAgICAqIEBwYXJhbSB7e2l0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fSB0cmlhbmdsZXMgLSBOdW1iZXIgb2YgdHJpYW5nbGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZlYXR1cmUuIFxyXG4gICAgICogQHBhcmFtIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IGJvcmRlcnMgLSBOdW1iZXIgb2YgYm9yZGVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBGZWF0dXJlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcG9pbnRzIC0gVGhlIHBvaW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIEZlYXR1cmUuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgRmVhdHVyZSBpZC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS5cclxuICAgICAgICAgKiBAdHlwZSB7e2Z4OiBzdHJpbmcsIF9naXNwbGF5aWQ6bnVtYmVyfX0gIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiB0cmlhbmdsZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS4gVGhlIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBpdGVtU2l6ZSBhbmQgbnVtSXRlbXMgaXMgYSBXZWJHTEJ1ZmZlci5cclxuICAgICAgICAgKiBAdHlwZSB7e2l0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgYm9yZGVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBGZWF0dXJlLiBUaGUgT2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGl0ZW1TaXplIGFuZCBudW1JdGVtcyBpcyBhIFdlYkdMQnVmZmVyLlxyXG4gICAgICAgICAqIEB0eXBlIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYm9yZGVycyA9IGJvcmRlcnM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHBvaW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIEZlYXR1cmUuICBUaGUgT2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGl0ZW1TaXplIGFuZCBudW1JdGVtcyBpcyBhIFdlYkdMQnVmZmVyLlxyXG4gICAgICAgICAqIEB0eXBlIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdHJpYW5nbGVzIHRoYXQgYmVsb25nIHRvIHRoZSBGZWF0dXJlLlxyXG4gICAgICogQHJldHVybnMge0ZlYXR1cmUuX3RyaWFuZ2xlc30gLSBBbGwgdHJpYW5nbGVzIHRoYXQgYmVsb25nIHRvIHRoZSBGZWF0dXJlLlxyXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmVcclxuICAgICAqL1xyXG4gICAgZ2V0VHJpYW5nbGVzKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWFuZ2xlcztcclxuICAgIH1cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgICogUmV0dXJucyBhbGwgYm9yZGVycyB0aGF0IGJlbG9uZyB0byB0aGUgRmVhdHVyZS5cclxuICAgICAgKiBAcmV0dXJucyB7RmVhdHVyZS5fYm9yZGVyc30gLSBBbGwgYm9yZGVycyB0aGF0IGJlbG9uZyB0byB0aGUgRmVhdHVyZS5cclxuICAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZVxyXG4gICAgICAqL1xyXG4gICAgZ2V0Qm9yZGVycygpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJzO1xyXG4gICAgfVxyXG5cclxuICAgICAvKipcclxuICAgICAgKiBSZXR1cm5zIGFsbCBwb2ludHMgdGhhdCBiZWxvbmcgdG8gdGhlIEZlYXR1cmUuXHJcbiAgICAgICogQHJldHVybnMge0ZlYXR1cmUuX3BvaW50c30gLSBBbGwgcG9pbnRzIHRoYXQgYmVsb25nIHRvIHRoZSBGZWF0dXJlLlxyXG4gICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlXHJcbiAgICAgICovXHJcbiAgICBnZXRQb2ludHMoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgcHJvcGVydGllcyB0aGF0IGJlbG9uZyB0byB0aGUgRmVhdHVyZS5cclxuICAgICAqIEByZXR1cm5zIHtGZWF0dXJlLl9wcm9wZXJ0aWVzfVxyXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmVcclxuICAgICAqL1xyXG4gICAgZ2V0UHJvcGVydGllcygpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0ZlYXR1cmUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFBQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** ./src/Gisplay/Maps/Types/ChangeMap.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChangeMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ../Map */ 2);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 1);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 4);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * ChangeMap implementation 07/03\r\n */\nvar ChangeMap = exports.ChangeMap = function (_Map) {\n    _inherits(ChangeMap, _Map);\n\n    /**\r\n     * Creates an instance of ChangeMap.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} options - User options to be used.\r\n     * @memberOf ChangeMap\r\n     */\n    function ChangeMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChangeMap);\n\n        var _this = _possibleConstructorReturn(this, (ChangeMap.__proto__ || Object.getPrototypeOf(ChangeMap)).call(this, bgmap, geometry, options));\n\n        options.attr = \"change\"; //this.gisplayOptions.attr = \"change\"; // this.type = 'CM'; //window.maps.push(this);\n        _this.loadOptions(options, bgmap);\n        _this.initializeCanvasAndEvents();\n        return _this;\n    }\n\n    /**\r\n     * Draw Change map, at the beginning and when the map is moved.\r\n     * @see initialize() and makeMap() methods.\r\n     * @override \r\n     * @memberOf ChangeMap\r\n     */\n\n\n    _createClass(ChangeMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var aes = _step.value;\n\n                    if (aes.isEnabled()) this.drawContinuousPolygons(aes);\n                    this.drawBorders(aes);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Process data loaded by the user. This mothed overrides the parent(Map class) default processData method.\r\n         * @param {JSON} geojson - GeoJSON object.\r\n         * @param {number} numberOfClasses - Number of classes that the Legend will contain.\r\n         * @param {string} classBreaksMethod - Algorithm to be used to calculate class breaks. Only used it class breaks are not given by the user.\r\n         * @param {string[]} colorscheme - Color scheme to be used by this map.\r\n         * @override \r\n         * @memberOf ChangeMap\r\n         */\n\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOfClasses, classBreaksMethod, colorscheme) {\n            var opts = this.gisplayOptions;\n            var gjonFeatures = geojson.features;\n            for (var i = 0; i < gjonFeatures.length && i < opts.maxFeatures; i++) {\n                var gjsonMinuend = gjonFeatures[i].properties[opts.minuend];\n                var gjsonSubtrahend = gjonFeatures[i].properties[opts.subtrahend];\n                if (typeof gjsonMinuend === 'number' && typeof gjsonSubtrahend === 'number') {\n                    //  && gjonminuend != null && gjonSubtrahend != null\n                    this.max = Math.max(this.max, gjsonMinuend - gjsonSubtrahend);\n                    this.min = Math.min(this.min, gjsonMinuend - gjsonSubtrahend);\n                }\n            }\n\n            var breaks = [this.min, this.max];\n            /**\r\n             * The color to fill the Aesthetic element(RGBA) OR a function to create this color.\r\n             * @type {number[]}\r\n             */\n            this.fcolor = chroma.scale(colorscheme);\n            var aes = new _Aesthetic.Aesthetic(0, opts.attr, this.fcolor, [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n            aes.outer = true;\n            /**\r\n             * Aesthetic object. In the case of a Change Map only one Aesthetic exists.\r\n             * @type {Array<Aesthetic>}\r\n             */\n            this.aesthetics = [aes];\n        }\n\n        /**\r\n         * Method called to build the Map Legend.\r\n         * Create a gradient and insert legend onto background map.\r\n         * @override \r\n         * @memberOf ChangeMap\r\n         */\n\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            /**\r\n             * The Legend to be used through the life of the map.\r\n             * @type {Legend} \r\n             */\n            this.legend = new _Legend.Legend(this.id, this.gisplayOptions.legendTitle);\n            this.legend.insertGradient(this, this.min, 0, this.max);\n            this.legend.insertLegend(this.bGMap);\n        }\n\n        /**\r\n         * Returns empty object.\r\n         * @param {number} defaultColorSchemeId - The id of the default color scheme to choose the colors.\r\n         * @override \r\n         * @memberOf ChangeMap\r\n         */\n\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultColorSchemeId) {\n            return {};\n        }\n    }]);\n\n    return ChangeMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL1R5cGVzL0NoYW5nZU1hcC5qcz8zMTAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcCB9IGZyb20gJy4uL01hcCc7XHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZCc7XHJcbmltcG9ydCB7IEFlc3RoZXRpYyB9IGZyb20gJy4uL0Flc3RoZXRpYyc7XHJcblxyXG4vKipcclxuICogQ2hhbmdlTWFwIGltcGxlbWVudGF0aW9uIDA3LzAzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hhbmdlTWFwIGV4dGVuZHMgTWFwIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2hhbmdlTWFwLlxyXG4gICAgICogQHBhcmFtIHtCR01hcFdyYXBwZXJ9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIEpTT04gb2JqZWN0IHdpdGggdGhlIGdlb21ldHJ5IHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVXNlciBvcHRpb25zIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgQ2hhbmdlTWFwXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgb3B0aW9ucy5hdHRyID0gXCJjaGFuZ2VcIjsgLy90aGlzLmdpc3BsYXlPcHRpb25zLmF0dHIgPSBcImNoYW5nZVwiOyAvLyB0aGlzLnR5cGUgPSAnQ00nOyAvL3dpbmRvdy5tYXBzLnB1c2godGhpcyk7XHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ2FudmFzQW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IENoYW5nZSBtYXAsIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHdoZW4gdGhlIG1hcCBpcyBtb3ZlZC5cclxuICAgICAqIEBzZWUgaW5pdGlhbGl6ZSgpIGFuZCBtYWtlTWFwKCkgbWV0aG9kcy5cclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBDaGFuZ2VNYXBcclxuICAgICAqL1xyXG4gICAgZHJhdygpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhZXMgb2YgdGhpcy5hZXN0aGV0aWNzKSB7XHJcbiAgICAgICAgICAgIGlmIChhZXMuaXNFbmFibGVkKCkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdDb250aW51b3VzUG9seWdvbnMoYWVzKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyhhZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgZGF0YSBsb2FkZWQgYnkgdGhlIHVzZXIuIFRoaXMgbW90aGVkIG92ZXJyaWRlcyB0aGUgcGFyZW50KE1hcCBjbGFzcykgZGVmYXVsdCBwcm9jZXNzRGF0YSBtZXRob2QuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb2pzb24gLSBHZW9KU09OIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkNsYXNzZXMgLSBOdW1iZXIgb2YgY2xhc3NlcyB0aGF0IHRoZSBMZWdlbmQgd2lsbCBjb250YWluLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzQnJlYWtzTWV0aG9kIC0gQWxnb3JpdGhtIHRvIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGNsYXNzIGJyZWFrcy4gT25seSB1c2VkIGl0IGNsYXNzIGJyZWFrcyBhcmUgbm90IGdpdmVuIGJ5IHRoZSB1c2VyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY29sb3JzY2hlbWUgLSBDb2xvciBzY2hlbWUgdG8gYmUgdXNlZCBieSB0aGlzIG1hcC5cclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBDaGFuZ2VNYXBcclxuICAgICAqL1xyXG4gICAgcHJlUHJvY2Vzc0RhdGEoZ2VvanNvbiwgbnVtYmVyT2ZDbGFzc2VzLCBjbGFzc0JyZWFrc01ldGhvZCwgY29sb3JzY2hlbWUpIHtcclxuICAgICAgICBsZXQgb3B0cyA9IHRoaXMuZ2lzcGxheU9wdGlvbnM7XHJcbiAgICAgICAgbGV0IGdqb25GZWF0dXJlcyA9IGdlb2pzb24uZmVhdHVyZXM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnam9uRmVhdHVyZXMubGVuZ3RoICYmIGkgPCBvcHRzLm1heEZlYXR1cmVzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGdqc29uTWludWVuZCA9IGdqb25GZWF0dXJlc1tpXS5wcm9wZXJ0aWVzW29wdHMubWludWVuZF07XHJcbiAgICAgICAgICAgIGxldCBnanNvblN1YnRyYWhlbmQgPSBnam9uRmVhdHVyZXNbaV0ucHJvcGVydGllc1tvcHRzLnN1YnRyYWhlbmRdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGdqc29uTWludWVuZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGdqc29uU3VidHJhaGVuZCA9PT0gJ251bWJlcicpIHsgLy8gICYmIGdqb25taW51ZW5kICE9IG51bGwgJiYgZ2pvblN1YnRyYWhlbmQgIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgZ2pzb25NaW51ZW5kIC0gZ2pzb25TdWJ0cmFoZW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIGdqc29uTWludWVuZCAtIGdqc29uU3VidHJhaGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBicmVha3MgPSBbdGhpcy5taW4sIHRoaXMubWF4XTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sb3IgdG8gZmlsbCB0aGUgQWVzdGhldGljIGVsZW1lbnQoUkdCQSkgT1IgYSBmdW5jdGlvbiB0byBjcmVhdGUgdGhpcyBjb2xvci5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mY29sb3IgPSBjaHJvbWEuc2NhbGUoY29sb3JzY2hlbWUpO1xyXG4gICAgICAgIGNvbnN0IGFlcyA9IG5ldyBBZXN0aGV0aWMoMCwgb3B0cy5hdHRyLCB0aGlzLmZjb2xvciwgWzAsIDAsIDAsIDFdLCBudWxsLCBbYnJlYWtzWzBdLCBicmVha3NbMV1dKTtcclxuICAgICAgICBhZXMub3V0ZXIgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFlc3RoZXRpYyBvYmplY3QuIEluIHRoZSBjYXNlIG9mIGEgQ2hhbmdlIE1hcCBvbmx5IG9uZSBBZXN0aGV0aWMgZXhpc3RzLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxBZXN0aGV0aWM+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IFthZXNdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0aG9kIGNhbGxlZCB0byBidWlsZCB0aGUgTWFwIExlZ2VuZC5cclxuICAgICAqIENyZWF0ZSBhIGdyYWRpZW50IGFuZCBpbnNlcnQgbGVnZW5kIG9udG8gYmFja2dyb3VuZCBtYXAuXHJcbiAgICAgKiBAb3ZlcnJpZGUgXHJcbiAgICAgKiBAbWVtYmVyT2YgQ2hhbmdlTWFwXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBMZWdlbmQgdG8gYmUgdXNlZCB0aHJvdWdoIHRoZSBsaWZlIG9mIHRoZSBtYXAuXHJcbiAgICAgICAgICogQHR5cGUge0xlZ2VuZH0gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZWdlbmQgPSBuZXcgTGVnZW5kKHRoaXMuaWQsIHRoaXMuZ2lzcGxheU9wdGlvbnMubGVnZW5kVGl0bGUpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydEdyYWRpZW50KHRoaXMsIHRoaXMubWluLCAwLCB0aGlzLm1heCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0TGVnZW5kKHRoaXMuYkdNYXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBlbXB0eSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdENvbG9yU2NoZW1lSWQgLSBUaGUgaWQgb2YgdGhlIGRlZmF1bHQgY29sb3Igc2NoZW1lIHRvIGNob29zZSB0aGUgY29sb3JzLlxyXG4gICAgICogQG92ZXJyaWRlIFxyXG4gICAgICogQG1lbWJlck9mIENoYW5nZU1hcFxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0cyhkZWZhdWx0Q29sb3JTY2hlbWVJZCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL1R5cGVzL0NoYW5nZU1hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUdBOzs7QUFFQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** ./src/Gisplay/Maps/Types/ChorochromaticMap.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChorochromaticMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth2 = __webpack_require__(/*! ./Choropleth */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Chorochormatic Map implemenetation.\r\n */\nvar ChorochromaticMap = exports.ChorochromaticMap = function (_Choropleth) {\n    _inherits(ChorochromaticMap, _Choropleth);\n\n    /**\r\n     * Creates an instance of ChorochromaticMap.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} options - User options to be used. \r\n     * @memberOf ChorochromaticMap\r\n     */\n    function ChorochromaticMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChorochromaticMap);\n\n        return _possibleConstructorReturn(this, (ChorochromaticMap.__proto__ || Object.getPrototypeOf(ChorochromaticMap)).call(this, bgmap, geometry, options));\n    }\n\n    /**\r\n     * Returns the color scheme associated with the id given.\r\n     * @param {number} defaultColorSchemeId - The id of the color scheme to choose the colors.\r\n     * @returns {colorScheme: string[]} - The color scheme.\r\n     * @override\r\n     * @memberOf ChorochromaticMap\r\n     */\n\n\n    _createClass(ChorochromaticMap, [{\n        key: \"defaults\",\n        value: function defaults(defaultColorSchemeId) {\n            var options = {};\n            switch (defaultColorSchemeId) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ChorochromaticMap;\n}(_Choropleth2.Choropleth);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9UeXBlcy9DaG9yb2Nocm9tYXRpY01hcC5qcz80ZGY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENob3JvcGxldGggfSBmcm9tICcuL0Nob3JvcGxldGgnO1xyXG5cclxuLyoqXHJcbiAqIENob3JvY2hvcm1hdGljIE1hcCBpbXBsZW1lbmV0YXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hvcm9jaHJvbWF0aWNNYXAgZXh0ZW5kcyBDaG9yb3BsZXRoIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2hvcm9jaHJvbWF0aWNNYXAuXHJcbiAgICAgKiBAcGFyYW0ge0JHTWFwV3JhcHBlcn0gYmdtYXAgLSBCYWNrZ3JvdW5kIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gSlNPTiBvYmplY3Qgd2l0aCB0aGUgZ2VvbWV0cnkgdGhhdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBVc2VyIG9wdGlvbnMgdG8gYmUgdXNlZC4gXHJcbiAgICAgKiBAbWVtYmVyT2YgQ2hvcm9jaHJvbWF0aWNNYXBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbG9yIHNjaGVtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGlkIGdpdmVuLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRDb2xvclNjaGVtZUlkIC0gVGhlIGlkIG9mIHRoZSBjb2xvciBzY2hlbWUgdG8gY2hvb3NlIHRoZSBjb2xvcnMuXHJcbiAgICAgKiBAcmV0dXJucyB7Y29sb3JTY2hlbWU6IHN0cmluZ1tdfSAtIFRoZSBjb2xvciBzY2hlbWUuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBtZW1iZXJPZiBDaG9yb2Nocm9tYXRpY01hcFxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0cyhkZWZhdWx0Q29sb3JTY2hlbWVJZCkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKGRlZmF1bHRDb2xvclNjaGVtZUlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbXCIjNDQwMTU0XCIsIFwiIzQ0MDI1NlwiLCBcIiM0NTA0NTdcIiwgXCIjNDUwNTU5XCIsIFwiIzQ2MDc1YVwiLCBcIiM0NjA4NWNcIiwgXCIjNDYwYTVkXCIsIFwiIzQ2MGI1ZVwiLCBcIiM0NzBkNjBcIiwgXCIjNDcwZTYxXCIsIFwiIzQ3MTA2M1wiLCBcIiM0NzExNjRcIiwgXCIjNDcxMzY1XCIsIFwiIzQ4MTQ2N1wiLCBcIiM0ODE2NjhcIiwgXCIjNDgxNzY5XCIsIFwiIzQ4MTg2YVwiLCBcIiM0ODFhNmNcIiwgXCIjNDgxYjZkXCIsIFwiIzQ4MWM2ZVwiLCBcIiM0ODFkNmZcIiwgXCIjNDgxZjcwXCIsIFwiIzQ4MjA3MVwiLCBcIiM0ODIxNzNcIiwgXCIjNDgyMzc0XCIsIFwiIzQ4MjQ3NVwiLCBcIiM0ODI1NzZcIiwgXCIjNDgyNjc3XCIsIFwiIzQ4Mjg3OFwiLCBcIiM0ODI5NzlcIiwgXCIjNDcyYTdhXCIsIFwiIzQ3MmM3YVwiLCBcIiM0NzJkN2JcIiwgXCIjNDcyZTdjXCIsIFwiIzQ3MmY3ZFwiLCBcIiM0NjMwN2VcIiwgXCIjNDYzMjdlXCIsIFwiIzQ2MzM3ZlwiLCBcIiM0NjM0ODBcIiwgXCIjNDUzNTgxXCIsIFwiIzQ1Mzc4MVwiLCBcIiM0NTM4ODJcIiwgXCIjNDQzOTgzXCIsIFwiIzQ0M2E4M1wiLCBcIiM0NDNiODRcIiwgXCIjNDMzZDg0XCIsIFwiIzQzM2U4NVwiLCBcIiM0MjNmODVcIiwgXCIjNDI0MDg2XCIsIFwiIzQyNDE4NlwiLCBcIiM0MTQyODdcIiwgXCIjNDE0NDg3XCIsIFwiIzQwNDU4OFwiLCBcIiM0MDQ2ODhcIiwgXCIjM2Y0Nzg4XCIsIFwiIzNmNDg4OVwiLCBcIiMzZTQ5ODlcIiwgXCIjM2U0YTg5XCIsIFwiIzNlNGM4YVwiLCBcIiMzZDRkOGFcIiwgXCIjM2Q0ZThhXCIsIFwiIzNjNGY4YVwiLCBcIiMzYzUwOGJcIiwgXCIjM2I1MThiXCIsIFwiIzNiNTI4YlwiLCBcIiMzYTUzOGJcIiwgXCIjM2E1NDhjXCIsIFwiIzM5NTU4Y1wiLCBcIiMzOTU2OGNcIiwgXCIjMzg1ODhjXCIsIFwiIzM4NTk4Y1wiLCBcIiMzNzVhOGNcIiwgXCIjMzc1YjhkXCIsIFwiIzM2NWM4ZFwiLCBcIiMzNjVkOGRcIiwgXCIjMzU1ZThkXCIsIFwiIzM1NWY4ZFwiLCBcIiMzNDYwOGRcIiwgXCIjMzQ2MThkXCIsIFwiIzMzNjI4ZFwiLCBcIiMzMzYzOGRcIiwgXCIjMzI2NDhlXCIsIFwiIzMyNjU4ZVwiLCBcIiMzMTY2OGVcIiwgXCIjMzE2NzhlXCIsIFwiIzMxNjg4ZVwiLCBcIiMzMDY5OGVcIiwgXCIjMzA2YThlXCIsIFwiIzJmNmI4ZVwiLCBcIiMyZjZjOGVcIiwgXCIjMmU2ZDhlXCIsIFwiIzJlNmU4ZVwiLCBcIiMyZTZmOGVcIiwgXCIjMmQ3MDhlXCIsIFwiIzJkNzE4ZVwiLCBcIiMyYzcxOGVcIiwgXCIjMmM3MjhlXCIsIFwiIzJjNzM4ZVwiLCBcIiMyYjc0OGVcIiwgXCIjMmI3NThlXCIsIFwiIzJhNzY4ZVwiLCBcIiMyYTc3OGVcIiwgXCIjMmE3ODhlXCIsIFwiIzI5Nzk4ZVwiLCBcIiMyOTdhOGVcIiwgXCIjMjk3YjhlXCIsIFwiIzI4N2M4ZVwiLCBcIiMyODdkOGVcIiwgXCIjMjc3ZThlXCIsIFwiIzI3N2Y4ZVwiLCBcIiMyNzgwOGVcIiwgXCIjMjY4MThlXCIsIFwiIzI2ODI4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjU4MzhlXCIsIFwiIzI1ODQ4ZVwiLCBcIiMyNTg1OGVcIiwgXCIjMjQ4NjhlXCIsIFwiIzI0ODc4ZVwiLCBcIiMyMzg4OGVcIiwgXCIjMjM4OThlXCIsIFwiIzIzOGE4ZFwiLCBcIiMyMjhiOGRcIiwgXCIjMjI4YzhkXCIsIFwiIzIyOGQ4ZFwiLCBcIiMyMThlOGRcIiwgXCIjMjE4ZjhkXCIsIFwiIzIxOTA4ZFwiLCBcIiMyMTkxOGNcIiwgXCIjMjA5MjhjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkzOGNcIiwgXCIjMWY5NDhjXCIsIFwiIzFmOTU4YlwiLCBcIiMxZjk2OGJcIiwgXCIjMWY5NzhiXCIsIFwiIzFmOTg4YlwiLCBcIiMxZjk5OGFcIiwgXCIjMWY5YThhXCIsIFwiIzFlOWI4YVwiLCBcIiMxZTljODlcIiwgXCIjMWU5ZDg5XCIsIFwiIzFmOWU4OVwiLCBcIiMxZjlmODhcIiwgXCIjMWZhMDg4XCIsIFwiIzFmYTE4OFwiLCBcIiMxZmExODdcIiwgXCIjMWZhMjg3XCIsIFwiIzIwYTM4NlwiLCBcIiMyMGE0ODZcIiwgXCIjMjFhNTg1XCIsIFwiIzIxYTY4NVwiLCBcIiMyMmE3ODVcIiwgXCIjMjJhODg0XCIsIFwiIzIzYTk4M1wiLCBcIiMyNGFhODNcIiwgXCIjMjVhYjgyXCIsIFwiIzI1YWM4MlwiLCBcIiMyNmFkODFcIiwgXCIjMjdhZDgxXCIsIFwiIzI4YWU4MFwiLCBcIiMyOWFmN2ZcIiwgXCIjMmFiMDdmXCIsIFwiIzJjYjE3ZVwiLCBcIiMyZGIyN2RcIiwgXCIjMmViMzdjXCIsIFwiIzJmYjQ3Y1wiLCBcIiMzMWI1N2JcIiwgXCIjMzJiNjdhXCIsIFwiIzM0YjY3OVwiLCBcIiMzNWI3NzlcIiwgXCIjMzdiODc4XCIsIFwiIzM4Yjk3N1wiLCBcIiMzYWJhNzZcIiwgXCIjM2JiYjc1XCIsIFwiIzNkYmM3NFwiLCBcIiMzZmJjNzNcIiwgXCIjNDBiZDcyXCIsIFwiIzQyYmU3MVwiLCBcIiM0NGJmNzBcIiwgXCIjNDZjMDZmXCIsIFwiIzQ4YzE2ZVwiLCBcIiM0YWMxNmRcIiwgXCIjNGNjMjZjXCIsIFwiIzRlYzM2YlwiLCBcIiM1MGM0NmFcIiwgXCIjNTJjNTY5XCIsIFwiIzU0YzU2OFwiLCBcIiM1NmM2NjdcIiwgXCIjNThjNzY1XCIsIFwiIzVhYzg2NFwiLCBcIiM1Y2M4NjNcIiwgXCIjNWVjOTYyXCIsIFwiIzYwY2E2MFwiLCBcIiM2M2NiNWZcIiwgXCIjNjVjYjVlXCIsIFwiIzY3Y2M1Y1wiLCBcIiM2OWNkNWJcIiwgXCIjNmNjZDVhXCIsIFwiIzZlY2U1OFwiLCBcIiM3MGNmNTdcIiwgXCIjNzNkMDU2XCIsIFwiIzc1ZDA1NFwiLCBcIiM3N2QxNTNcIiwgXCIjN2FkMTUxXCIsIFwiIzdjZDI1MFwiLCBcIiM3ZmQzNGVcIiwgXCIjODFkMzRkXCIsIFwiIzg0ZDQ0YlwiLCBcIiM4NmQ1NDlcIiwgXCIjODlkNTQ4XCIsIFwiIzhiZDY0NlwiLCBcIiM4ZWQ2NDVcIiwgXCIjOTBkNzQzXCIsIFwiIzkzZDc0MVwiLCBcIiM5NWQ4NDBcIiwgXCIjOThkODNlXCIsIFwiIzliZDkzY1wiLCBcIiM5ZGQ5M2JcIiwgXCIjYTBkYTM5XCIsIFwiI2EyZGEzN1wiLCBcIiNhNWRiMzZcIiwgXCIjYThkYjM0XCIsIFwiI2FhZGMzMlwiLCBcIiNhZGRjMzBcIiwgXCIjYjBkZDJmXCIsIFwiI2IyZGQyZFwiLCBcIiNiNWRlMmJcIiwgXCIjYjhkZTI5XCIsIFwiI2JhZGUyOFwiLCBcIiNiZGRmMjZcIiwgXCIjYzBkZjI1XCIsIFwiI2MyZGYyM1wiLCBcIiNjNWUwMjFcIiwgXCIjYzhlMDIwXCIsIFwiI2NhZTExZlwiLCBcIiNjZGUxMWRcIiwgXCIjZDBlMTFjXCIsIFwiI2QyZTIxYlwiLCBcIiNkNWUyMWFcIiwgXCIjZDhlMjE5XCIsIFwiI2RhZTMxOVwiLCBcIiNkZGUzMThcIiwgXCIjZGZlMzE4XCIsIFwiI2UyZTQxOFwiLCBcIiNlNWU0MTlcIiwgXCIjZTdlNDE5XCIsIFwiI2VhZTUxYVwiLCBcIiNlY2U1MWJcIiwgXCIjZWZlNTFjXCIsIFwiI2YxZTUxZFwiLCBcIiNmNGU2MWVcIiwgXCIjZjZlNjIwXCIsIFwiI2Y4ZTYyMVwiLCBcIiNmYmU3MjNcIiwgXCIjZmRlNzI1XCJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3B1cnBsZScsICdvcmFuZ2UnLCAnYmx1ZScsICd5ZWxsb3cnLCAncGluaycsICdncmVlbicsICdyZWQnLCAnbmF2eSddO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gW1wiIzQ0MDE1NFwiLCBcIiM0NDAyNTZcIiwgXCIjNDUwNDU3XCIsIFwiIzQ1MDU1OVwiLCBcIiM0NjA3NWFcIiwgXCIjNDYwODVjXCIsIFwiIzQ2MGE1ZFwiLCBcIiM0NjBiNWVcIiwgXCIjNDcwZDYwXCIsIFwiIzQ3MGU2MVwiLCBcIiM0NzEwNjNcIiwgXCIjNDcxMTY0XCIsIFwiIzQ3MTM2NVwiLCBcIiM0ODE0NjdcIiwgXCIjNDgxNjY4XCIsIFwiIzQ4MTc2OVwiLCBcIiM0ODE4NmFcIiwgXCIjNDgxYTZjXCIsIFwiIzQ4MWI2ZFwiLCBcIiM0ODFjNmVcIiwgXCIjNDgxZDZmXCIsIFwiIzQ4MWY3MFwiLCBcIiM0ODIwNzFcIiwgXCIjNDgyMTczXCIsIFwiIzQ4MjM3NFwiLCBcIiM0ODI0NzVcIiwgXCIjNDgyNTc2XCIsIFwiIzQ4MjY3N1wiLCBcIiM0ODI4NzhcIiwgXCIjNDgyOTc5XCIsIFwiIzQ3MmE3YVwiLCBcIiM0NzJjN2FcIiwgXCIjNDcyZDdiXCIsIFwiIzQ3MmU3Y1wiLCBcIiM0NzJmN2RcIiwgXCIjNDYzMDdlXCIsIFwiIzQ2MzI3ZVwiLCBcIiM0NjMzN2ZcIiwgXCIjNDYzNDgwXCIsIFwiIzQ1MzU4MVwiLCBcIiM0NTM3ODFcIiwgXCIjNDUzODgyXCIsIFwiIzQ0Mzk4M1wiLCBcIiM0NDNhODNcIiwgXCIjNDQzYjg0XCIsIFwiIzQzM2Q4NFwiLCBcIiM0MzNlODVcIiwgXCIjNDIzZjg1XCIsIFwiIzQyNDA4NlwiLCBcIiM0MjQxODZcIiwgXCIjNDE0Mjg3XCIsIFwiIzQxNDQ4N1wiLCBcIiM0MDQ1ODhcIiwgXCIjNDA0Njg4XCIsIFwiIzNmNDc4OFwiLCBcIiMzZjQ4ODlcIiwgXCIjM2U0OTg5XCIsIFwiIzNlNGE4OVwiLCBcIiMzZTRjOGFcIiwgXCIjM2Q0ZDhhXCIsIFwiIzNkNGU4YVwiLCBcIiMzYzRmOGFcIiwgXCIjM2M1MDhiXCIsIFwiIzNiNTE4YlwiLCBcIiMzYjUyOGJcIiwgXCIjM2E1MzhiXCIsIFwiIzNhNTQ4Y1wiLCBcIiMzOTU1OGNcIiwgXCIjMzk1NjhjXCIsIFwiIzM4NTg4Y1wiLCBcIiMzODU5OGNcIiwgXCIjMzc1YThjXCIsIFwiIzM3NWI4ZFwiLCBcIiMzNjVjOGRcIiwgXCIjMzY1ZDhkXCIsIFwiIzM1NWU4ZFwiLCBcIiMzNTVmOGRcIiwgXCIjMzQ2MDhkXCIsIFwiIzM0NjE4ZFwiLCBcIiMzMzYyOGRcIiwgXCIjMzM2MzhkXCIsIFwiIzMyNjQ4ZVwiLCBcIiMzMjY1OGVcIiwgXCIjMzE2NjhlXCIsIFwiIzMxNjc4ZVwiLCBcIiMzMTY4OGVcIiwgXCIjMzA2OThlXCIsIFwiIzMwNmE4ZVwiLCBcIiMyZjZiOGVcIiwgXCIjMmY2YzhlXCIsIFwiIzJlNmQ4ZVwiLCBcIiMyZTZlOGVcIiwgXCIjMmU2ZjhlXCIsIFwiIzJkNzA4ZVwiLCBcIiMyZDcxOGVcIiwgXCIjMmM3MThlXCIsIFwiIzJjNzI4ZVwiLCBcIiMyYzczOGVcIiwgXCIjMmI3NDhlXCIsIFwiIzJiNzU4ZVwiLCBcIiMyYTc2OGVcIiwgXCIjMmE3NzhlXCIsIFwiIzJhNzg4ZVwiLCBcIiMyOTc5OGVcIiwgXCIjMjk3YThlXCIsIFwiIzI5N2I4ZVwiLCBcIiMyODdjOGVcIiwgXCIjMjg3ZDhlXCIsIFwiIzI3N2U4ZVwiLCBcIiMyNzdmOGVcIiwgXCIjMjc4MDhlXCIsIFwiIzI2ODE4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjY4MjhlXCIsIFwiIzI1ODM4ZVwiLCBcIiMyNTg0OGVcIiwgXCIjMjU4NThlXCIsIFwiIzI0ODY4ZVwiLCBcIiMyNDg3OGVcIiwgXCIjMjM4ODhlXCIsIFwiIzIzODk4ZVwiLCBcIiMyMzhhOGRcIiwgXCIjMjI4YjhkXCIsIFwiIzIyOGM4ZFwiLCBcIiMyMjhkOGRcIiwgXCIjMjE4ZThkXCIsIFwiIzIxOGY4ZFwiLCBcIiMyMTkwOGRcIiwgXCIjMjE5MThjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkyOGNcIiwgXCIjMjA5MzhjXCIsIFwiIzFmOTQ4Y1wiLCBcIiMxZjk1OGJcIiwgXCIjMWY5NjhiXCIsIFwiIzFmOTc4YlwiLCBcIiMxZjk4OGJcIiwgXCIjMWY5OThhXCIsIFwiIzFmOWE4YVwiLCBcIiMxZTliOGFcIiwgXCIjMWU5Yzg5XCIsIFwiIzFlOWQ4OVwiLCBcIiMxZjllODlcIiwgXCIjMWY5Zjg4XCIsIFwiIzFmYTA4OFwiLCBcIiMxZmExODhcIiwgXCIjMWZhMTg3XCIsIFwiIzFmYTI4N1wiLCBcIiMyMGEzODZcIiwgXCIjMjBhNDg2XCIsIFwiIzIxYTU4NVwiLCBcIiMyMWE2ODVcIiwgXCIjMjJhNzg1XCIsIFwiIzIyYTg4NFwiLCBcIiMyM2E5ODNcIiwgXCIjMjRhYTgzXCIsIFwiIzI1YWI4MlwiLCBcIiMyNWFjODJcIiwgXCIjMjZhZDgxXCIsIFwiIzI3YWQ4MVwiLCBcIiMyOGFlODBcIiwgXCIjMjlhZjdmXCIsIFwiIzJhYjA3ZlwiLCBcIiMyY2IxN2VcIiwgXCIjMmRiMjdkXCIsIFwiIzJlYjM3Y1wiLCBcIiMyZmI0N2NcIiwgXCIjMzFiNTdiXCIsIFwiIzMyYjY3YVwiLCBcIiMzNGI2NzlcIiwgXCIjMzViNzc5XCIsIFwiIzM3Yjg3OFwiLCBcIiMzOGI5NzdcIiwgXCIjM2FiYTc2XCIsIFwiIzNiYmI3NVwiLCBcIiMzZGJjNzRcIiwgXCIjM2ZiYzczXCIsIFwiIzQwYmQ3MlwiLCBcIiM0MmJlNzFcIiwgXCIjNDRiZjcwXCIsIFwiIzQ2YzA2ZlwiLCBcIiM0OGMxNmVcIiwgXCIjNGFjMTZkXCIsIFwiIzRjYzI2Y1wiLCBcIiM0ZWMzNmJcIiwgXCIjNTBjNDZhXCIsIFwiIzUyYzU2OVwiLCBcIiM1NGM1NjhcIiwgXCIjNTZjNjY3XCIsIFwiIzU4Yzc2NVwiLCBcIiM1YWM4NjRcIiwgXCIjNWNjODYzXCIsIFwiIzVlYzk2MlwiLCBcIiM2MGNhNjBcIiwgXCIjNjNjYjVmXCIsIFwiIzY1Y2I1ZVwiLCBcIiM2N2NjNWNcIiwgXCIjNjljZDViXCIsIFwiIzZjY2Q1YVwiLCBcIiM2ZWNlNThcIiwgXCIjNzBjZjU3XCIsIFwiIzczZDA1NlwiLCBcIiM3NWQwNTRcIiwgXCIjNzdkMTUzXCIsIFwiIzdhZDE1MVwiLCBcIiM3Y2QyNTBcIiwgXCIjN2ZkMzRlXCIsIFwiIzgxZDM0ZFwiLCBcIiM4NGQ0NGJcIiwgXCIjODZkNTQ5XCIsIFwiIzg5ZDU0OFwiLCBcIiM4YmQ2NDZcIiwgXCIjOGVkNjQ1XCIsIFwiIzkwZDc0M1wiLCBcIiM5M2Q3NDFcIiwgXCIjOTVkODQwXCIsIFwiIzk4ZDgzZVwiLCBcIiM5YmQ5M2NcIiwgXCIjOWRkOTNiXCIsIFwiI2EwZGEzOVwiLCBcIiNhMmRhMzdcIiwgXCIjYTVkYjM2XCIsIFwiI2E4ZGIzNFwiLCBcIiNhYWRjMzJcIiwgXCIjYWRkYzMwXCIsIFwiI2IwZGQyZlwiLCBcIiNiMmRkMmRcIiwgXCIjYjVkZTJiXCIsIFwiI2I4ZGUyOVwiLCBcIiNiYWRlMjhcIiwgXCIjYmRkZjI2XCIsIFwiI2MwZGYyNVwiLCBcIiNjMmRmMjNcIiwgXCIjYzVlMDIxXCIsIFwiI2M4ZTAyMFwiLCBcIiNjYWUxMWZcIiwgXCIjY2RlMTFkXCIsIFwiI2QwZTExY1wiLCBcIiNkMmUyMWJcIiwgXCIjZDVlMjFhXCIsIFwiI2Q4ZTIxOVwiLCBcIiNkYWUzMTlcIiwgXCIjZGRlMzE4XCIsIFwiI2RmZTMxOFwiLCBcIiNlMmU0MThcIiwgXCIjZTVlNDE5XCIsIFwiI2U3ZTQxOVwiLCBcIiNlYWU1MWFcIiwgXCIjZWNlNTFiXCIsIFwiI2VmZTUxY1wiLCBcIiNmMWU1MWRcIiwgXCIjZjRlNjFlXCIsIFwiI2Y2ZTYyMFwiLCBcIiNmOGU2MjFcIiwgXCIjZmJlNzIzXCIsIFwiI2ZkZTcyNVwiXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9UeXBlcy9DaG9yb2Nocm9tYXRpY01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFHQTs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************************!*\
  !*** ./src/Gisplay/Maps/Types/ProportionalSymbolsMap.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ProportionalSymbolsMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ../Map */ 2);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Proportional Symbols Map implementation.\r\n */\nvar ProportionalSymbolsMap = exports.ProportionalSymbolsMap = function (_Map) {\n    _inherits(ProportionalSymbolsMap, _Map);\n\n    /**\r\n     * Creates an instance of ProportionalSymbolsMap.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} options - User options to be used.\r\n     * @memberOf ProportionalSymbolsMap\r\n     */\n    function ProportionalSymbolsMap(bgmap, geometry, options) {\n        _classCallCheck(this, ProportionalSymbolsMap);\n\n        var _this = _possibleConstructorReturn(this, (ProportionalSymbolsMap.__proto__ || Object.getPrototypeOf(ProportionalSymbolsMap)).call(this, bgmap, geometry, options));\n\n        _this.loadOptions(options, bgmap);\n        _this.gisplayOptions.isDynamic = !options.sizeByClass;\n        _this.initializeCanvasAndEvents();\n        return _this;\n    }\n\n    /**\r\n     * Draw ProportionalSymbols map, at the beginning and when the map is moved.\r\n     * @see initialize() and makeMap() methods.\r\n     * @override \r\n     * @memberOf ProportionalSymbolsMap\r\n     */\n\n\n    _createClass(ProportionalSymbolsMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            if (!this.gisplayOptions.isDynamic) {\n                for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                    if (this.aesthetics[i].isEnabled()) this.drawPoints(this.aesthetics[i]);\n                }\n            } else {\n                for (var _i = this.aesthetics.length - 1; _i >= 0; _i--) {\n                    if (this.aesthetics[_i].isEnabled()) this.drawProportionalPoints(this.aesthetics[_i]);\n                }\n            }\n        }\n\n        /**\r\n         * Method called to build the Map Legend.\r\n         * For all Aesthethics that exist crate one proportional symbol row and then insert the Legend to the map. \r\n         * @override \r\n         * @memberOf ProportionalSymbolsMap\r\n         */\n\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            /**\r\n             * The Legend to be used through the life of the map.\r\n             * @type {Legend} \r\n             */\n            this.legend = new _Legend.Legend(this.id, this.gisplayOptions.legendTitle);\n            if (this.aesthetics.length === 1) this.legend.insertProportionalSymbols(this.aesthetics[0], this, this.gisplayOptions.numberOfLegendItems);else for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                if (i === 0) this.legend.insertProportionalSymbols(this.aesthetics[i], this, 2);else this.legend.insertProportionalSymbols(this.aesthetics[i], this, 1);\n            }\n            // i == 0 ? this.legend.insertProportionalSymbols(this.aesthetics[i], this, 2) : this.legend.insertProportionalSymbols(this.aesthetics[i], this, 1);\n            this.legend.insertLegend(this.bGMap);\n        }\n\n        /**\r\n         * Returns the color scheme, number of classes, minimum point size and max point size associated with the id given.\r\n         * @param {number} defaultColorSchemeId - The id of the default color scheme to choose the colors.\r\n         * @returns {{maxPointSize: number, minPointSize: number, colorScheme: string[], numberOfClasses: number}}\r\n         * @override \r\n         * @memberOf ProportionalSymbolsMap\r\n         */\n\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultColorSchemeId) {\n            var options = {};\n            switch (defaultColorSchemeId) {\n                case 1:\n                    options.maxPointSize = 60;\n                    options.minPointSize = 5;\n                    options.colorScheme = ['green', 'red', 'blue'];\n                    options.numberOfClasses = 1;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ProportionalSymbolsMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9UeXBlcy9Qcm9wb3J0aW9uYWxTeW1ib2xzTWFwLmpzP2NjNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwIH0gZnJvbSAnLi4vTWFwJztcclxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kJztcclxuXHJcbi8qKlxyXG4gKiBQcm9wb3J0aW9uYWwgU3ltYm9scyBNYXAgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJvcG9ydGlvbmFsU3ltYm9sc01hcCBleHRlbmRzIE1hcCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFByb3BvcnRpb25hbFN5bWJvbHNNYXAuXHJcbiAgICAgKiBAcGFyYW0ge0JHTWFwV3JhcHBlcn0gYmdtYXAgLSBCYWNrZ3JvdW5kIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gSlNPTiBvYmplY3Qgd2l0aCB0aGUgZ2VvbWV0cnkgdGhhdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBVc2VyIG9wdGlvbnMgdG8gYmUgdXNlZC5cclxuICAgICAqIEBtZW1iZXJPZiBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCk7XHJcbiAgICAgICAgdGhpcy5naXNwbGF5T3B0aW9ucy5pc0R5bmFtaWMgPSAhb3B0aW9ucy5zaXplQnlDbGFzcztcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVDYW52YXNBbmRFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgUHJvcG9ydGlvbmFsU3ltYm9scyBtYXAsIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHdoZW4gdGhlIG1hcCBpcyBtb3ZlZC5cclxuICAgICAqIEBzZWUgaW5pdGlhbGl6ZSgpIGFuZCBtYWtlTWFwKCkgbWV0aG9kcy5cclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwXHJcbiAgICAgKi9cclxuICAgIGRyYXcoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGlmICghdGhpcy5naXNwbGF5T3B0aW9ucy5pc0R5bmFtaWMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWVzdGhldGljcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFlc3RoZXRpY3NbaV0uaXNFbmFibGVkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UG9pbnRzKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljc1tpXS5pc0VuYWJsZWQoKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdQcm9wb3J0aW9uYWxQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRob2QgY2FsbGVkIHRvIGJ1aWxkIHRoZSBNYXAgTGVnZW5kLlxyXG4gICAgICogRm9yIGFsbCBBZXN0aGV0aGljcyB0aGF0IGV4aXN0IGNyYXRlIG9uZSBwcm9wb3J0aW9uYWwgc3ltYm9sIHJvdyBhbmQgdGhlbiBpbnNlcnQgdGhlIExlZ2VuZCB0byB0aGUgbWFwLiBcclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBMZWdlbmQgdG8gYmUgdXNlZCB0aHJvdWdoIHRoZSBsaWZlIG9mIHRoZSBtYXAuXHJcbiAgICAgICAgICogQHR5cGUge0xlZ2VuZH0gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZWdlbmQgPSBuZXcgTGVnZW5kKHRoaXMuaWQsIHRoaXMuZ2lzcGxheU9wdGlvbnMubGVnZW5kVGl0bGUpO1xyXG4gICAgICAgIGlmICh0aGlzLmFlc3RoZXRpY3MubGVuZ3RoID09PSAxKVxyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKHRoaXMuYWVzdGhldGljc1swXSwgdGhpcywgdGhpcy5naXNwbGF5T3B0aW9ucy5udW1iZXJPZkxlZ2VuZEl0ZW1zKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVnZW5kLmluc2VydFByb3BvcnRpb25hbFN5bWJvbHModGhpcy5hZXN0aGV0aWNzW2ldLCB0aGlzLCAyKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKHRoaXMuYWVzdGhldGljc1tpXSwgdGhpcywgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAvLyBpID09IDAgPyB0aGlzLmxlZ2VuZC5pbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKHRoaXMuYWVzdGhldGljc1tpXSwgdGhpcywgMikgOiB0aGlzLmxlZ2VuZC5pbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKHRoaXMuYWVzdGhldGljc1tpXSwgdGhpcywgMSk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0TGVnZW5kKHRoaXMuYkdNYXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29sb3Igc2NoZW1lLCBudW1iZXIgb2YgY2xhc3NlcywgbWluaW11bSBwb2ludCBzaXplIGFuZCBtYXggcG9pbnQgc2l6ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGlkIGdpdmVuLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRDb2xvclNjaGVtZUlkIC0gVGhlIGlkIG9mIHRoZSBkZWZhdWx0IGNvbG9yIHNjaGVtZSB0byBjaG9vc2UgdGhlIGNvbG9ycy5cclxuICAgICAqIEByZXR1cm5zIHt7bWF4UG9pbnRTaXplOiBudW1iZXIsIG1pblBvaW50U2l6ZTogbnVtYmVyLCBjb2xvclNjaGVtZTogc3RyaW5nW10sIG51bWJlck9mQ2xhc3NlczogbnVtYmVyfX1cclxuICAgICAqIEBvdmVycmlkZSBcclxuICAgICAqIEBtZW1iZXJPZiBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzKGRlZmF1bHRDb2xvclNjaGVtZUlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdENvbG9yU2NoZW1lSWQpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhQb2ludFNpemUgPSA2MDtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWluUG9pbnRTaXplID0gNTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ2dyZWVuJywgJ3JlZCcsICdibHVlJ107XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm51bWJlck9mQ2xhc3NlcyA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9UeXBlcy9Qcm9wb3J0aW9uYWxTeW1ib2xzTWFwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFHQTs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/Maps/WebGLUtils.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Class with static methods that will help with WebGL related stuff(Matrices, web mercator projection and shaders).\r\n * Always remeber WebGL is column major when reading the matrix code.\r\n * @see http://ptgmedia.pearsoncmg.com/images/chap3_9780321902924/elementLinks/03fig27.jpg\r\n * @static \r\n * @class WebGLUtils\r\n */\nvar WebGLUtils = exports.WebGLUtils = function () {\n    function WebGLUtils() {\n        _classCallCheck(this, WebGLUtils);\n    }\n\n    _createClass(WebGLUtils, null, [{\n        key: \"webMercatorProjection\",\n\n\n        /**\r\n         * Calculates the scale and offset(X and Y) for the Web Mercator projection.\r\n         * @static\r\n         * @param {number} longitudeCenter - Longitude of the given position.\r\n         * @param {number} latitudeCenter - Latitude of the given position.\r\n         * @param {number} zoom - Current zoom level of the background map.\r\n         * @param {number} tileSize - The size of each tile in the background map. Usually is 256. If different should be given in the API options.\r\n         * @param {number} width - Width of the current canvas.\r\n         * @param {number} height - Height of the current canvas.\r\n         * @returns {{scale: number, offsetX: number, offsetY: number}} - Returns the scale, offsetX and offsetY of the point given using the Web Mercator projection.\r\n         * @see https://bl.ocks.org/enjalot/fb7f3d696167e9b83a72#viewport.js\r\n         * @see https://en.wikipedia.org/wiki/Web_Mercator\r\n         * @memberOf WebGLUtils\r\n         */\n        value: function webMercatorProjection(longitudeCenter, latitudeCenter, zoom, tileSize, width, height) {\n            // console.log(longitudeCenter, latitudeCenter, zoom, tileSize,  width, height);\n            var PI = Math.PI;\n            var scale = tileSize / 2 / PI * Math.pow(2, zoom);\n            var lambda = longitudeCenter * (PI / 180); // Convert longitude to radians\n            var phi = latitudeCenter * (PI / 180); // Convert latitude to radians\n\n            var xCenter = scale * (lambda + PI);\n            var yCenter = scale * (PI - Math.log(Math.tan(PI / 4 + phi / 2)));\n            var offsetX = width / 2 - xCenter;\n            var offsetY = height / 2 - yCenter;\n\n            return { scale: scale, offsetX: offsetX, offsetY: offsetY };\n        }\n\n        /**\r\n         * This is the result matrix from multiplication M1*M2*M3\r\n         * @static\r\n         * @param {number} scale - The scale calculated with WebMercator projection.\r\n         * @param {number} width - The width of the canvas.\r\n         * @param {number} height - The height of the canvas.\r\n         * @param {number} offsetX - The offsetX calculated with WebMercator projection.\r\n         * @param {number} offsetY - The offsetY calculated with WebMercator projection.\r\n         * @returns {Float32Array} The resulting matrix (M1*M2*M3) in a single matrix.\r\n         * @see Rui's thesis\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"finalMatrix\",\n        value: function finalMatrix(scale, width, height, offsetX, offsetY) {\n            var p0 = 2 * Math.PI * scale / (width * 180);\n            var p2 = 2 * Math.PI * scale / width + 2 * offsetX / width - 1;\n            var p4 = 2 * scale / height;\n            var p5 = 2 * offsetY / height - 1;\n            return new Float32Array([p0, 0, 0, 0, p4, 0, p2, p5, 1]);\n        }\n\n        /**\r\n         * Creates shaders(Vertex + Fragment) source code.\r\n         * @static\r\n         * @returns {{vertexCode: string, fragmentCode: string}} - The code for the vertex and fragment shaders.\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"generateShadersSourceCode\",\n        value: function generateShadersSourceCode() {\n            var vertexSourceCode = \"\\n            #define PI radians(180.0)\\n\\n            attribute vec2 coords;\\n            uniform mat3 M;\\n            \\n         \\tattribute float aPointSize; \\n         \\tattribute float a_opacity; \\n         \\tvarying float v_opacity; \\n\\n         \\tvoid main() {\\n                float phi = coords[1] * (PI / 180.0);\\n                float YValue = PI -log( tan((PI/4.0) + phi/2.0) );\\n                vec3 f = vec3(coords[0], YValue, 1.0);\\n                vec3 pixeis = M * f;\\n                float X = pixeis[0];\\n                float Y = -(pixeis[1]);\\n                gl_Position = vec4(X, Y , 0.0, 1.0);\\n         \\t\\t\\n         \\t\\tgl_PointSize = aPointSize; \\n                v_opacity = a_opacity; \\n            }\\n        \";\n\n            var fragmentSourceCode = \" \\n            precision mediump float;\\n         \\tuniform vec4 u_color;\\n         \\tvarying float v_opacity; \\n           \\tuniform float isPoint;\\n            void main() {\\n         \\t\\tfloat border = 0.5;\\n         \\t\\tfloat radius = 0.5;\\n         \\t\\tfloat centerDist = length(gl_PointCoord - 0.5);\\n         \\t\\tfloat alpha;\\n         \\t\\tif (u_color[3] == -1.0)    \\n         \\t\\t\\talpha =  v_opacity * step(centerDist, radius);\\n         \\t\\telse \\n         \\t\\t\\talpha =  u_color[3] * step(centerDist, radius);\\n\\n         \\t\\tif(isPoint == 1.0 ) {\\n         \\t\\t    if (alpha < 0.1) discard;\\n         \\t\\t\\t    gl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);\\n                }\\n           \\t\\telse\\n         \\t\\t\\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);\\n         \\t}\\n        \";\n            return { vertexCode: vertexSourceCode, fragmentCode: fragmentSourceCode };\n        }\n\n        /**\r\n         * Creates and compiles a shader.\r\n         * @static\r\n         * @param {string} type - Type of shader. Options are: VERTEX_SHADER or FRAGMENT_SHADER;\r\n         * @param {string} source_code - The shader source code.\r\n         * @param {Map#_webgl} webgl - Webgl object used by the Map class.\r\n         * @returns {WebGLShader} - The shader(vertex of fragment).\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"createAndCompileShader\",\n        value: function createAndCompileShader(type, source_code, webgl) {\n            var shader = webgl.gl.createShader(type);\n            webgl.gl.shaderSource(shader, source_code);\n            webgl.gl.compileShader(shader);\n            return shader;\n        }\n\n        /**\r\n         * Initializes:\r\n         * 1)WebGLProgram, 2) Generates shadders, 3) Attaches shaders to the program, 4) links program, 5) uses program.\r\n         * @static\r\n         * @param {{gl: WebGLRenderingContext, program: WebGLProgram}} webgl \r\n         * @returns {void}\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"createWebGLProgram\",\n        value: function createWebGLProgram(webgl) {\n            webgl.program = webgl.gl.createProgram();\n\n            var source_code = this.generateShadersSourceCode();\n            var vertex_shader = this.createAndCompileShader(webgl.gl.VERTEX_SHADER, source_code.vertexCode, webgl);\n            var fragment_shader = this.createAndCompileShader(webgl.gl.FRAGMENT_SHADER, source_code.fragmentCode, webgl);\n\n            webgl.gl.attachShader(webgl.program, vertex_shader);\n            webgl.gl.attachShader(webgl.program, fragment_shader);\n\n            webgl.gl.linkProgram(webgl.program);\n            webgl.gl.useProgram(webgl.program);\n        }\n\n        /** ########################    DEPRECATED ZONE ######################## */\n        /**\r\n         * Creates the M1 Matrix. \r\n         * This matrix is used to convert the result pixel to a position between 0 and 1(2/width and 2/height scaling) \r\n         * and after that convert to a position between -1 and 1(-1 translation).\r\n         * @static\r\n         * @param {number} width - Width of the canvas.\r\n         * @param {number} height - Height of the canvas.\r\n         * @returns {Float32Array} The matrix M1 to be used to calculate each point/vertex position.\r\n         * @see Documentation of Rui's thesis. \r\n         * @deprecated finalMatrix(..) method is used instead.\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"createM1\",\n        value: function createM1(width, height) {\n            var w = 2 / width;\n            var h = 2 / height;\n            return new Float32Array([w, 0, -1, 0, h, -1, 0, 0, 1]);\n        }\n\n        /**\r\n         * Creates the M2 Matrix.\r\n         * This matrix is used to calculate the positions of the pixel using the Web Mercator projection.\r\n         * @static \r\n         * @param {number} scale \r\n         * @param {number} offsetX \r\n         * @param {number} offsetY \r\n         * @returns {Float32Array} The matrix M2 to be used to calculate each point/vertex position.\r\n         * @see https://bl.ocks.org/enjalot/fb7f3d696167e9b83a72#viewport.js\r\n         * @see Documentation of Rui's thesis. \r\n         * @deprecated finalMatrix(..) method is used instead.\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"createM2\",\n        value: function createM2(scale, offsetX, offsetY) {\n            var s = scale;\n            var x = offsetX;\n            var y = offsetY;\n            return new Float32Array([s, 0, x, 0, s, y, 0, 0, 1]);\n        }\n\n        /**\r\n         * Creates the M3 Matrix.\r\n         * This matrix is used to calculate the positions of the pixel using the Web Mercator projection.\r\n         * @static\r\n         * @returns {Float32Array}  The matrix M3 to be used to calculate each point/vertex position.\r\n         * @see Documentation of Rui's thesis.\r\n         * @deprecated finalMatrix(..) method is used instead.\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"createM3\",\n        value: function createM3() {\n            var p = Math.PI;\n            var q = p / 180;\n            return new Float32Array([q, 0, p, 0, 1, 0, 0, 0, 1]);\n        }\n\n        /**\r\n         * Performs Matrix multiplication between two matrices.\r\n         * @static\r\n         * @param {Float32Array} M1 - The M1 matrix. \r\n         * @param {Float32Array} M2 - The M2 matrix.\r\n         * @returns {Float32Array} a matrix which is the result of multiplying M1 by M2.\r\n         * @deprecated finalMatrix(..) method is used instead.\r\n         * @memberOf WebGLUtils\r\n         */\n\n    }, {\n        key: \"matrixMultiplication\",\n        value: function matrixMultiplication(M1, M2) {\n            var res = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n            res[0] = M1[0] * M2[0] + M1[1] * M2[3] + M1[2] * M2[6];\n            res[1] = M1[0] * M2[1] + M1[1] * M2[4] + M1[2] * M2[7];\n            res[2] = M1[0] * M2[2] + M1[1] * M2[5] + M1[2] * M2[8];\n\n            res[3] = M1[3] * M2[0] + M1[4] * M2[3] + M1[5] * M2[6];\n            res[4] = M1[3] * M2[1] + M1[4] * M2[4] + M1[5] * M2[7];\n            res[5] = M1[3] * M2[2] + M1[4] * M2[5] + M1[5] * M2[8];\n\n            res[6] = M1[6] * M2[0] + M1[7] * M2[3] + M1[8] * M2[6];\n            res[7] = M1[6] * M2[1] + M1[7] * M2[4] + M1[8] * M2[7];\n            res[8] = M1[6] * M2[2] + M1[7] * M2[5] + M1[8] * M2[8];\n            return res;\n        }\n    }]);\n\n    return WebGLUtils;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9XZWJHTFV0aWxzLmpzPzdjZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENsYXNzIHdpdGggc3RhdGljIG1ldGhvZHMgdGhhdCB3aWxsIGhlbHAgd2l0aCBXZWJHTCByZWxhdGVkIHN0dWZmKE1hdHJpY2VzLCB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBhbmQgc2hhZGVycykuXHJcbiAqIEFsd2F5cyByZW1lYmVyIFdlYkdMIGlzIGNvbHVtbiBtYWpvciB3aGVuIHJlYWRpbmcgdGhlIG1hdHJpeCBjb2RlLlxyXG4gKiBAc2VlIGh0dHA6Ly9wdGdtZWRpYS5wZWFyc29uY21nLmNvbS9pbWFnZXMvY2hhcDNfOTc4MDMyMTkwMjkyNC9lbGVtZW50TGlua3MvMDNmaWcyNy5qcGdcclxuICogQHN0YXRpYyBcclxuICogQGNsYXNzIFdlYkdMVXRpbHNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJHTFV0aWxzIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjYWxlIGFuZCBvZmZzZXQoWCBhbmQgWSkgZm9yIHRoZSBXZWIgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb25naXR1ZGVDZW50ZXIgLSBMb25naXR1ZGUgb2YgdGhlIGdpdmVuIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdGl0dWRlQ2VudGVyIC0gTGF0aXR1ZGUgb2YgdGhlIGdpdmVuIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBDdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIGJhY2tncm91bmQgbWFwLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGVTaXplIC0gVGhlIHNpemUgb2YgZWFjaCB0aWxlIGluIHRoZSBiYWNrZ3JvdW5kIG1hcC4gVXN1YWxseSBpcyAyNTYuIElmIGRpZmZlcmVudCBzaG91bGQgYmUgZ2l2ZW4gaW4gdGhlIEFQSSBvcHRpb25zLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIGN1cnJlbnQgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgY3VycmVudCBjYW52YXMuXHJcbiAgICAgKiBAcmV0dXJucyB7e3NjYWxlOiBudW1iZXIsIG9mZnNldFg6IG51bWJlciwgb2Zmc2V0WTogbnVtYmVyfX0gLSBSZXR1cm5zIHRoZSBzY2FsZSwgb2Zmc2V0WCBhbmQgb2Zmc2V0WSBvZiB0aGUgcG9pbnQgZ2l2ZW4gdXNpbmcgdGhlIFdlYiBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gICAgICogQHNlZSBodHRwczovL2JsLm9ja3Mub3JnL2VuamFsb3QvZmI3ZjNkNjk2MTY3ZTliODNhNzIjdmlld3BvcnQuanNcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01lcmNhdG9yXHJcbiAgICAgKiBAbWVtYmVyT2YgV2ViR0xVdGlsc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgd2ViTWVyY2F0b3JQcm9qZWN0aW9uKGxvbmdpdHVkZUNlbnRlciwgbGF0aXR1ZGVDZW50ZXIsIHpvb20sIHRpbGVTaXplLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2cobG9uZ2l0dWRlQ2VudGVyLCBsYXRpdHVkZUNlbnRlciwgem9vbSwgdGlsZVNpemUsICB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBsZXQgUEkgPSBNYXRoLlBJO1xyXG4gICAgICAgIGxldCBzY2FsZSA9ICgodGlsZVNpemUgLyAyKSAvIFBJKSAqIE1hdGgucG93KDIsIHpvb20pO1xyXG4gICAgICAgIGxldCBsYW1iZGEgPSBsb25naXR1ZGVDZW50ZXIgKiAoUEkgLyAxODApOyAvLyBDb252ZXJ0IGxvbmdpdHVkZSB0byByYWRpYW5zXHJcbiAgICAgICAgbGV0IHBoaSA9IGxhdGl0dWRlQ2VudGVyICogKFBJIC8gMTgwKTsgLy8gQ29udmVydCBsYXRpdHVkZSB0byByYWRpYW5zXHJcblxyXG4gICAgICAgIGxldCB4Q2VudGVyID0gc2NhbGUgKiAobGFtYmRhICsgUEkpO1xyXG4gICAgICAgIGxldCB5Q2VudGVyID0gc2NhbGUgKiAoUEkgLSBNYXRoLmxvZyhNYXRoLnRhbigoUEkgLyA0KSArIChwaGkgLyAyKSkpKTtcclxuICAgICAgICBsZXQgb2Zmc2V0WCA9ICh3aWR0aCAvIDIpIC0geENlbnRlcjtcclxuICAgICAgICBsZXQgb2Zmc2V0WSA9IChoZWlnaHQgLyAyKSAtIHlDZW50ZXI7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4geyBzY2FsZTogc2NhbGUsIG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgdGhlIHJlc3VsdCBtYXRyaXggZnJvbSBtdWx0aXBsaWNhdGlvbiBNMSpNMipNM1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxlIGNhbGN1bGF0ZWQgd2l0aCBXZWJNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgb2Zmc2V0WCBjYWxjdWxhdGVkIHdpdGggV2ViTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gVGhlIG9mZnNldFkgY2FsY3VsYXRlZCB3aXRoIFdlYk1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBUaGUgcmVzdWx0aW5nIG1hdHJpeCAoTTEqTTIqTTMpIGluIGEgc2luZ2xlIG1hdHJpeC5cclxuICAgICAqIEBzZWUgUnVpJ3MgdGhlc2lzXHJcbiAgICAgKiBAbWVtYmVyT2YgV2ViR0xVdGlsc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZmluYWxNYXRyaXgoc2NhbGUsIHdpZHRoLCBoZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpIHtcclxuICAgICAgICBsZXQgcDAgPSAoMiAqIE1hdGguUEkgKiBzY2FsZSkgLyAod2lkdGggKiAxODApO1xyXG4gICAgICAgIGxldCBwMiA9ICgoMiAqIE1hdGguUEkgKiBzY2FsZSkgLyB3aWR0aCkgKyAoKDIgKiBvZmZzZXRYKSAvIHdpZHRoKSAtIDE7XHJcbiAgICAgICAgbGV0IHA0ID0gKDIgKiBzY2FsZSkgLyBoZWlnaHQ7XHJcbiAgICAgICAgbGV0IHA1ID0gKCgyICogb2Zmc2V0WSAvIGhlaWdodCkgLSAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgIHAwLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCBwNCwgMCxcclxuICAgICAgICAgICAgcDIsIHA1LCAxXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHNoYWRlcnMoVmVydGV4ICsgRnJhZ21lbnQpIHNvdXJjZSBjb2RlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3t2ZXJ0ZXhDb2RlOiBzdHJpbmcsIGZyYWdtZW50Q29kZTogc3RyaW5nfX0gLSBUaGUgY29kZSBmb3IgdGhlIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cclxuICAgICAqIEBtZW1iZXJPZiBXZWJHTFV0aWxzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZW5lcmF0ZVNoYWRlcnNTb3VyY2VDb2RlKCkge1xyXG4gICAgICAgIGxldCB2ZXJ0ZXhTb3VyY2VDb2RlID1cclxuICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAjZGVmaW5lIFBJIHJhZGlhbnMoMTgwLjApXHJcblxyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBjb29yZHM7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBNO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgXHRhdHRyaWJ1dGUgZmxvYXQgYVBvaW50U2l6ZTsgXHJcbiAgICAgICAgIFx0YXR0cmlidXRlIGZsb2F0IGFfb3BhY2l0eTsgXHJcbiAgICAgICAgIFx0dmFyeWluZyBmbG9hdCB2X29wYWNpdHk7IFxyXG5cclxuICAgICAgICAgXHR2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBwaGkgPSBjb29yZHNbMV0gKiAoUEkgLyAxODAuMCk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBZVmFsdWUgPSBQSSAtbG9nKCB0YW4oKFBJLzQuMCkgKyBwaGkvMi4wKSApO1xyXG4gICAgICAgICAgICAgICAgdmVjMyBmID0gdmVjMyhjb29yZHNbMF0sIFlWYWx1ZSwgMS4wKTtcclxuICAgICAgICAgICAgICAgIHZlYzMgcGl4ZWlzID0gTSAqIGY7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBYID0gcGl4ZWlzWzBdO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgWSA9IC0ocGl4ZWlzWzFdKTtcclxuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChYLCBZICwgMC4wLCAxLjApO1xyXG4gICAgICAgICBcdFx0XHJcbiAgICAgICAgIFx0XHRnbF9Qb2ludFNpemUgPSBhUG9pbnRTaXplOyBcclxuICAgICAgICAgICAgICAgIHZfb3BhY2l0eSA9IGFfb3BhY2l0eTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBgO1xyXG5cclxuICAgICAgICBsZXQgZnJhZ21lbnRTb3VyY2VDb2RlID1cclxuICAgICAgICAgICAgYCBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgIFx0dW5pZm9ybSB2ZWM0IHVfY29sb3I7XHJcbiAgICAgICAgIFx0dmFyeWluZyBmbG9hdCB2X29wYWNpdHk7IFxyXG4gICAgICAgICAgIFx0dW5pZm9ybSBmbG9hdCBpc1BvaW50O1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgIFx0XHRmbG9hdCBib3JkZXIgPSAwLjU7XHJcbiAgICAgICAgIFx0XHRmbG9hdCByYWRpdXMgPSAwLjU7XHJcbiAgICAgICAgIFx0XHRmbG9hdCBjZW50ZXJEaXN0ID0gbGVuZ3RoKGdsX1BvaW50Q29vcmQgLSAwLjUpO1xyXG4gICAgICAgICBcdFx0ZmxvYXQgYWxwaGE7XHJcbiAgICAgICAgIFx0XHRpZiAodV9jb2xvclszXSA9PSAtMS4wKSAgICBcclxuICAgICAgICAgXHRcdFx0YWxwaGEgPSAgdl9vcGFjaXR5ICogc3RlcChjZW50ZXJEaXN0LCByYWRpdXMpO1xyXG4gICAgICAgICBcdFx0ZWxzZSBcclxuICAgICAgICAgXHRcdFx0YWxwaGEgPSAgdV9jb2xvclszXSAqIHN0ZXAoY2VudGVyRGlzdCwgcmFkaXVzKTtcclxuXHJcbiAgICAgICAgIFx0XHRpZihpc1BvaW50ID09IDEuMCApIHtcclxuICAgICAgICAgXHRcdCAgICBpZiAoYWxwaGEgPCAwLjEpIGRpc2NhcmQ7XHJcbiAgICAgICAgIFx0XHRcdCAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfY29sb3JbMF0sIHVfY29sb3JbMV0sIHVfY29sb3JbMl0sIGFscGhhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICBcdFx0ZWxzZVxyXG4gICAgICAgICBcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfY29sb3JbMF0sIHVfY29sb3JbMV0sIHVfY29sb3JbMl0sIHVfY29sb3JbM10pO1xyXG4gICAgICAgICBcdH1cclxuICAgICAgICBgO1xyXG4gICAgICAgIHJldHVybiB7IHZlcnRleENvZGU6IHZlcnRleFNvdXJjZUNvZGUsIGZyYWdtZW50Q29kZTogZnJhZ21lbnRTb3VyY2VDb2RlIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCBjb21waWxlcyBhIHNoYWRlci5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBzaGFkZXIuIE9wdGlvbnMgYXJlOiBWRVJURVhfU0hBREVSIG9yIEZSQUdNRU5UX1NIQURFUjtcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VfY29kZSAtIFRoZSBzaGFkZXIgc291cmNlIGNvZGUuXHJcbiAgICAgKiBAcGFyYW0ge01hcCNfd2ViZ2x9IHdlYmdsIC0gV2ViZ2wgb2JqZWN0IHVzZWQgYnkgdGhlIE1hcCBjbGFzcy5cclxuICAgICAqIEByZXR1cm5zIHtXZWJHTFNoYWRlcn0gLSBUaGUgc2hhZGVyKHZlcnRleCBvZiBmcmFnbWVudCkuXHJcbiAgICAgKiBAbWVtYmVyT2YgV2ViR0xVdGlsc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlQW5kQ29tcGlsZVNoYWRlcih0eXBlLCBzb3VyY2VfY29kZSwgd2ViZ2wpIHtcclxuICAgICAgICBsZXQgc2hhZGVyID0gd2ViZ2wuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgICAgIHdlYmdsLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZV9jb2RlKTtcclxuICAgICAgICB3ZWJnbC5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzOlxyXG4gICAgICogMSlXZWJHTFByb2dyYW0sIDIpIEdlbmVyYXRlcyBzaGFkZGVycywgMykgQXR0YWNoZXMgc2hhZGVycyB0byB0aGUgcHJvZ3JhbSwgNCkgbGlua3MgcHJvZ3JhbSwgNSkgdXNlcyBwcm9ncmFtLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHt7Z2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtfX0gd2ViZ2wgXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqIEBtZW1iZXJPZiBXZWJHTFV0aWxzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVXZWJHTFByb2dyYW0od2ViZ2wpIHtcclxuICAgICAgICB3ZWJnbC5wcm9ncmFtID0gd2ViZ2wuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBzb3VyY2VfY29kZSA9IHRoaXMuZ2VuZXJhdGVTaGFkZXJzU291cmNlQ29kZSgpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleF9zaGFkZXIgPSB0aGlzLmNyZWF0ZUFuZENvbXBpbGVTaGFkZXIod2ViZ2wuZ2wuVkVSVEVYX1NIQURFUiwgc291cmNlX2NvZGUudmVydGV4Q29kZSwgd2ViZ2wpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50X3NoYWRlciA9IHRoaXMuY3JlYXRlQW5kQ29tcGlsZVNoYWRlcih3ZWJnbC5nbC5GUkFHTUVOVF9TSEFERVIsIHNvdXJjZV9jb2RlLmZyYWdtZW50Q29kZSwgd2ViZ2wpO1xyXG5cclxuICAgICAgICB3ZWJnbC5nbC5hdHRhY2hTaGFkZXIod2ViZ2wucHJvZ3JhbSwgdmVydGV4X3NoYWRlcik7XHJcbiAgICAgICAgd2ViZ2wuZ2wuYXR0YWNoU2hhZGVyKHdlYmdsLnByb2dyYW0sIGZyYWdtZW50X3NoYWRlcik7XHJcblxyXG4gICAgICAgIHdlYmdsLmdsLmxpbmtQcm9ncmFtKHdlYmdsLnByb2dyYW0pO1xyXG4gICAgICAgIHdlYmdsLmdsLnVzZVByb2dyYW0od2ViZ2wucHJvZ3JhbSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgREVQUkVDQVRFRCBaT05FICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBNMSBNYXRyaXguIFxyXG4gICAgICogVGhpcyBtYXRyaXggaXMgdXNlZCB0byBjb252ZXJ0IHRoZSByZXN1bHQgcGl4ZWwgdG8gYSBwb3NpdGlvbiBiZXR3ZWVuIDAgYW5kIDEoMi93aWR0aCBhbmQgMi9oZWlnaHQgc2NhbGluZykgXHJcbiAgICAgKiBhbmQgYWZ0ZXIgdGhhdCBjb252ZXJ0IHRvIGEgcG9zaXRpb24gYmV0d2VlbiAtMSBhbmQgMSgtMSB0cmFuc2xhdGlvbikuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIG1hdHJpeCBNMSB0byBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBlYWNoIHBvaW50L3ZlcnRleCBwb3NpdGlvbi5cclxuICAgICAqIEBzZWUgRG9jdW1lbnRhdGlvbiBvZiBSdWkncyB0aGVzaXMuIFxyXG4gICAgICogQGRlcHJlY2F0ZWQgZmluYWxNYXRyaXgoLi4pIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgV2ViR0xVdGlsc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlTTEod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGxldCB3ID0gMiAvIHdpZHRoO1xyXG4gICAgICAgIGxldCBoID0gMiAvIGhlaWdodDtcclxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgdywgMCwgLTEsXHJcbiAgICAgICAgICAgICAgICAwLCBoLCAtMSxcclxuICAgICAgICAgICAgICAgIDAsIDAsIDFcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBNMiBNYXRyaXguXHJcbiAgICAgKiBUaGlzIG1hdHJpeCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBwaXhlbCB1c2luZyB0aGUgV2ViIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAgICAgKiBAc3RhdGljIFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBcclxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBtYXRyaXggTTIgdG8gYmUgdXNlZCB0byBjYWxjdWxhdGUgZWFjaCBwb2ludC92ZXJ0ZXggcG9zaXRpb24uXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vYmwub2Nrcy5vcmcvZW5qYWxvdC9mYjdmM2Q2OTYxNjdlOWI4M2E3MiN2aWV3cG9ydC5qc1xyXG4gICAgICogQHNlZSBEb2N1bWVudGF0aW9uIG9mIFJ1aSdzIHRoZXNpcy4gXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBmaW5hbE1hdHJpeCguLikgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZC5cclxuICAgICAqIEBtZW1iZXJPZiBXZWJHTFV0aWxzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVNMihzY2FsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xyXG4gICAgICAgIGxldCBzID0gc2NhbGU7XHJcbiAgICAgICAgbGV0IHggPSBvZmZzZXRYO1xyXG4gICAgICAgIGxldCB5ID0gb2Zmc2V0WTtcclxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgcywgMCwgeCxcclxuICAgICAgICAgICAgICAgIDAsIHMsIHksXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgTTMgTWF0cml4LlxyXG4gICAgICogVGhpcyBtYXRyaXggaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9ucyBvZiB0aGUgcGl4ZWwgdXNpbmcgdGhlIFdlYiBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gIFRoZSBtYXRyaXggTTMgdG8gYmUgdXNlZCB0byBjYWxjdWxhdGUgZWFjaCBwb2ludC92ZXJ0ZXggcG9zaXRpb24uXHJcbiAgICAgKiBAc2VlIERvY3VtZW50YXRpb24gb2YgUnVpJ3MgdGhlc2lzLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgZmluYWxNYXRyaXgoLi4pIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgV2ViR0xVdGlsc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlTTMoKSB7XHJcbiAgICAgICAgbGV0IHAgPSBNYXRoLlBJO1xyXG4gICAgICAgIGxldCBxID0gcCAvIDE4MDtcclxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgcSwgMCwgcCxcclxuICAgICAgICAgICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgTWF0cml4IG11bHRpcGxpY2F0aW9uIGJldHdlZW4gdHdvIG1hdHJpY2VzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IE0xIC0gVGhlIE0xIG1hdHJpeC4gXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gTTIgLSBUaGUgTTIgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gYSBtYXRyaXggd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBtdWx0aXBseWluZyBNMSBieSBNMi5cclxuICAgICAqIEBkZXByZWNhdGVkIGZpbmFsTWF0cml4KC4uKSBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICogQG1lbWJlck9mIFdlYkdMVXRpbHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG1hdHJpeE11bHRpcGxpY2F0aW9uKE0xLCBNMikge1xyXG4gICAgICAgIGxldCByZXMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgcmVzWzBdID0gTTFbMF0gKiBNMlswXSArIE0xWzFdICogTTJbM10gKyBNMVsyXSAqIE0yWzZdO1xyXG4gICAgICAgIHJlc1sxXSA9IE0xWzBdICogTTJbMV0gKyBNMVsxXSAqIE0yWzRdICsgTTFbMl0gKiBNMls3XTtcclxuICAgICAgICByZXNbMl0gPSBNMVswXSAqIE0yWzJdICsgTTFbMV0gKiBNMls1XSArIE0xWzJdICogTTJbOF07XHJcblxyXG4gICAgICAgIHJlc1szXSA9IE0xWzNdICogTTJbMF0gKyBNMVs0XSAqIE0yWzNdICsgTTFbNV0gKiBNMls2XTtcclxuICAgICAgICByZXNbNF0gPSBNMVszXSAqIE0yWzFdICsgTTFbNF0gKiBNMls0XSArIE0xWzVdICogTTJbN107XHJcbiAgICAgICAgcmVzWzVdID0gTTFbM10gKiBNMlsyXSArIE0xWzRdICogTTJbNV0gKyBNMVs1XSAqIE0yWzhdO1xyXG5cclxuICAgICAgICByZXNbNl0gPSBNMVs2XSAqIE0yWzBdICsgTTFbN10gKiBNMlszXSArIE0xWzhdICogTTJbNl07XHJcbiAgICAgICAgcmVzWzddID0gTTFbNl0gKiBNMlsxXSArIE0xWzddICogTTJbNF0gKyBNMVs4XSAqIE0yWzddO1xyXG4gICAgICAgIHJlc1s4XSA9IE0xWzZdICogTTJbMl0gKyBNMVs3XSAqIE0yWzVdICsgTTFbOF0gKiBNMls4XTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvV2ViR0xVdGlscy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7O0FBT0E7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQXdCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************************************!*\
  !*** ./src/Gisplay/Maps/v11/1_BackgroundMaps/ChoroplethBingMaps.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChoroplethBingMaps = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth2 = __webpack_require__(/*! ../../Types/Choropleth */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03 - 23/03\r\n */\nvar ChoroplethBingMaps = exports.ChoroplethBingMaps = function (_Choropleth) {\n    _inherits(ChoroplethBingMaps, _Choropleth);\n\n    /**\r\n     * Creates an instance of Choropleth.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} userOptions - User options to be used.\r\n     * @memberOf Choropleth\r\n     */\n    function ChoroplethBingMaps(bgmap, geometry, userOptions) {\n        _classCallCheck(this, ChoroplethBingMaps);\n\n        return _possibleConstructorReturn(this, (ChoroplethBingMaps.__proto__ || Object.getPrototypeOf(ChoroplethBingMaps)).call(this, bgmap, geometry, userOptions));\n    }\n\n    /**\r\n     * M8) Setup all events used by the API. Right now the API uses: drag, zoom and click events.\r\n     * Pan = viewchange,  Zoom = mousewheel, click = click\r\n     * @param {number} mappos - This map id. \r\n     * @return {void}\r\n     * @see http://www.bing.com/api/maps/sdkrelease/mapcontrol/isdk#addEventHandler+JS \r\n     * @see http://stackoverflow.com/a/8591192/5869289\r\n     * @see http://stackoverflow.com/a/18675579/5869289\r\n     */\n\n\n    _createClass(ChoroplethBingMaps, [{\n        key: 'setupEvents',\n        value: function setupEvents(mappos) {\n            var _this2 = this;\n\n            Microsoft.Maps.Events.addHandler(this.bGMap.getBackgroundMapProviderObject(), 'mousewheel', function () {\n                _this2.draw();\n            });\n            Microsoft.Maps.Events.addHandler(this.bGMap.getBackgroundMapProviderObject(), 'viewchange', function () {\n                _this2.draw();\n            });\n            Microsoft.Maps.Events.addHandler(this.bGMap.getBackgroundMapProviderObject(), 'click', function (e) {\n                var point = new Microsoft.Maps.Point(e.getX(), e.getY());\n                var loc = e.target.tryPixelToLocation(point);\n                var lon = loc.longitude;\n                var lat = loc.latitude;\n\n                if (_this2.rtree !== undefined) _this2.searchRTree(lon, lat);\n                if (_this2.kdtree !== undefined) _this2.searchKdTree(lon, lat);\n            });\n        }\n    }]);\n\n    return ChoroplethBingMaps;\n}(_Choropleth2.Choropleth);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy92MTEvMV9CYWNrZ3JvdW5kTWFwcy9DaG9yb3BsZXRoQmluZ01hcHMuanM/M2U0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaG9yb3BsZXRoIH0gZnJvbSAnLi4vLi4vVHlwZXMvQ2hvcm9wbGV0aCc7XHJcblxyXG4vKipcclxuICogQ2hvcm9wbGV0aCBpbXBsZW1lbnRhdGlvbiAwNi8wMyAtIDIzLzAzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hvcm9wbGV0aEJpbmdNYXBzIGV4dGVuZHMgQ2hvcm9wbGV0aCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENob3JvcGxldGguXHJcbiAgICAgKiBAcGFyYW0ge0JHTWFwV3JhcHBlcn0gYmdtYXAgLSBCYWNrZ3JvdW5kIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gSlNPTiBvYmplY3Qgd2l0aCB0aGUgZ2VvbWV0cnkgdGhhdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zIC0gVXNlciBvcHRpb25zIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgQ2hvcm9wbGV0aFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIHVzZXJPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoYmdtYXAsIGdlb21ldHJ5LCB1c2VyT3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNOCkgU2V0dXAgYWxsIGV2ZW50cyB1c2VkIGJ5IHRoZSBBUEkuIFJpZ2h0IG5vdyB0aGUgQVBJIHVzZXM6IGRyYWcsIHpvb20gYW5kIGNsaWNrIGV2ZW50cy5cclxuICAgICAqIFBhbiA9IHZpZXdjaGFuZ2UsICBab29tID0gbW91c2V3aGVlbCwgY2xpY2sgPSBjbGlja1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcHBvcyAtIFRoaXMgbWFwIGlkLiBcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cuYmluZy5jb20vYXBpL21hcHMvc2RrcmVsZWFzZS9tYXBjb250cm9sL2lzZGsjYWRkRXZlbnRIYW5kbGVyK0pTIFxyXG4gICAgICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NTkxMTkyLzU4NjkyODlcclxuICAgICAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTg2NzU1NzkvNTg2OTI4OVxyXG4gICAgICovXHJcbiAgICBzZXR1cEV2ZW50cyhtYXBwb3MpIHtcclxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLmJHTWFwLmdldEJhY2tncm91bmRNYXBQcm92aWRlck9iamVjdCgpLCAnbW91c2V3aGVlbCcsICgpID0+IHsgdGhpcy5kcmF3KCk7IH0pO1xyXG4gICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuYkdNYXAuZ2V0QmFja2dyb3VuZE1hcFByb3ZpZGVyT2JqZWN0KCksICd2aWV3Y2hhbmdlJywgKCkgPT4geyB0aGlzLmRyYXcoKTsgfSk7XHJcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5iR01hcC5nZXRCYWNrZ3JvdW5kTWFwUHJvdmlkZXJPYmplY3QoKSwgJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IHBvaW50ID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KGUuZ2V0WCgpLCBlLmdldFkoKSk7XHJcbiAgICAgICAgICAgIGxldCBsb2MgPSBlLnRhcmdldC50cnlQaXhlbFRvTG9jYXRpb24ocG9pbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBsb24gPSBsb2MubG9uZ2l0dWRlO1xyXG4gICAgICAgICAgICBjb25zdCBsYXQgPSBsb2MubGF0aXR1ZGU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpcy5ydHJlZSAhPT0gdW5kZWZpbmVkKSBcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUlRyZWUobG9uLCBsYXQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5rZHRyZWUgIT09IHVuZGVmaW5lZCkgXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaEtkVHJlZShsb24sIGxhdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy92MTEvMV9CYWNrZ3JvdW5kTWFwcy9DaG9yb3BsZXRoQmluZ01hcHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFTQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************************************!*\
  !*** ./src/Gisplay/Maps/v11/1_BackgroundMaps/ChoroplethGoogleMaps.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChoroplethGoogleMaps = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth2 = __webpack_require__(/*! ../../Types/Choropleth */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03 - 23/03\r\n */\nvar ChoroplethGoogleMaps = exports.ChoroplethGoogleMaps = function (_Choropleth) {\n    _inherits(ChoroplethGoogleMaps, _Choropleth);\n\n    /**\r\n     * Creates an instance of Choropleth.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} userOptions - User options to be used.\r\n     * @memberOf Choropleth\r\n     */\n    function ChoroplethGoogleMaps(bgmap, geometry, userOptions) {\n        _classCallCheck(this, ChoroplethGoogleMaps);\n\n        return _possibleConstructorReturn(this, (ChoroplethGoogleMaps.__proto__ || Object.getPrototypeOf(ChoroplethGoogleMaps)).call(this, bgmap, geometry, userOptions));\n    }\n\n    /**\r\n     * M8) Setup all events used by the API. Right now the API uses: drag, zoom and click events.\r\n     * Pan = drag, Zoom = zoom_changed, click = click\r\n     * @param {number} mappos - This map id. \r\n     * @return {void}\r\n     * @see https://developers.google.com/maps/documentation/javascript/events\r\n     */\n\n\n    _createClass(ChoroplethGoogleMaps, [{\n        key: 'setupEvents',\n        value: function setupEvents(mappos) {\n            var _this2 = this;\n\n            /*if(!this.gisplayOptions.interactive && this.gisplayOptions.mapOnClickFunction === undefined)\r\n                return;*/\n            this.bGMap.addEventListener('zoom_changed', function () {\n                _this2.draw();\n            });\n            //this.bGMap.addEventListener('center_changed', () => { this.draw(); });\n            this.bGMap.addEventListener('drag', function () {\n                _this2.draw();\n            });\n            this.bGMap.addEventListener('click', function (e) {\n                var lat = e.latLng.lat();\n                var lon = e.latLng.lng();\n\n                if (_this2.rtree !== undefined) _this2.searchRTree(lon, lat);\n                if (_this2.kdtree !== undefined) _this2.searchKdTree(lon, lat);\n            });\n        }\n    }]);\n\n    return ChoroplethGoogleMaps;\n}(_Choropleth2.Choropleth);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy92MTEvMV9CYWNrZ3JvdW5kTWFwcy9DaG9yb3BsZXRoR29vZ2xlTWFwcy5qcz9iMjk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENob3JvcGxldGggfSBmcm9tICcuLi8uLi9UeXBlcy9DaG9yb3BsZXRoJztcclxuXHJcbi8qKlxyXG4gKiBDaG9yb3BsZXRoIGltcGxlbWVudGF0aW9uIDA2LzAzIC0gMjMvMDNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDaG9yb3BsZXRoR29vZ2xlTWFwcyBleHRlbmRzIENob3JvcGxldGgge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDaG9yb3BsZXRoLlxyXG4gICAgICogQHBhcmFtIHtCR01hcFdyYXBwZXJ9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIEpTT04gb2JqZWN0IHdpdGggdGhlIGdlb21ldHJ5IHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9ucyAtIFVzZXIgb3B0aW9ucyB0byBiZSB1c2VkLlxyXG4gICAgICogQG1lbWJlck9mIENob3JvcGxldGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYmdtYXAsIGdlb21ldHJ5LCB1c2VyT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgdXNlck9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTTgpIFNldHVwIGFsbCBldmVudHMgdXNlZCBieSB0aGUgQVBJLiBSaWdodCBub3cgdGhlIEFQSSB1c2VzOiBkcmFnLCB6b29tIGFuZCBjbGljayBldmVudHMuXHJcbiAgICAgKiBQYW4gPSBkcmFnLCBab29tID0gem9vbV9jaGFuZ2VkLCBjbGljayA9IGNsaWNrXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFwcG9zIC0gVGhpcyBtYXAgaWQuIFxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHNldHVwRXZlbnRzKG1hcHBvcykge1xyXG4gICAgICAgIC8qaWYoIXRoaXMuZ2lzcGxheU9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5naXNwbGF5T3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb24gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuOyovXHJcbiAgICAgICAgdGhpcy5iR01hcC5hZGRFdmVudExpc3RlbmVyKCd6b29tX2NoYW5nZWQnLCAoKSA9PiB7IHRoaXMuZHJhdygpOyB9KTtcclxuICAgICAgICAvL3RoaXMuYkdNYXAuYWRkRXZlbnRMaXN0ZW5lcignY2VudGVyX2NoYW5nZWQnLCAoKSA9PiB7IHRoaXMuZHJhdygpOyB9KTtcclxuICAgICAgICB0aGlzLmJHTWFwLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCAoKSA9PiB7IHRoaXMuZHJhdygpOyB9KTtcclxuICAgICAgICB0aGlzLmJHTWFwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhdCA9IGUubGF0TG5nLmxhdCgpO1xyXG4gICAgICAgICAgICBjb25zdCBsb24gPSBlLmxhdExuZy5sbmcoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ0cmVlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFJUcmVlKGxvbiwgbGF0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMua2R0cmVlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaEtkVHJlZShsb24sIGxhdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy92MTEvMV9CYWNrZ3JvdW5kTWFwcy9DaG9yb3BsZXRoR29vZ2xlTWFwcy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFHQTs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 15 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************************************!*\
  !*** ./src/Gisplay/Maps/v11/1_BackgroundMaps/ChoroplethHereMaps.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChoroplethHereMaps = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth2 = __webpack_require__(/*! ../../Types/Choropleth */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03 - 23/03\r\n */\nvar ChoroplethHereMaps = exports.ChoroplethHereMaps = function (_Choropleth) {\n    _inherits(ChoroplethHereMaps, _Choropleth);\n\n    /**\r\n     * Creates an instance of Choropleth.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} userOptions - User options to be used.\r\n     * @memberOf Choropleth\r\n     */\n    function ChoroplethHereMaps(bgmap, geometry, userOptions) {\n        _classCallCheck(this, ChoroplethHereMaps);\n\n        return _possibleConstructorReturn(this, (ChoroplethHereMaps.__proto__ || Object.getPrototypeOf(ChoroplethHereMaps)).call(this, bgmap, geometry, userOptions));\n    }\n\n    /**\r\n     * M8) Setup all events used by the API. Right now the API uses: drag, zoom and click events.\r\n     * Pan = drag, Zoom = mapviewchange, click = tap\r\n     * @param {number} mappos - This map id. \r\n     * @return {void}\r\n     * @see https://developer.here.com/javascript-apis/documentation/v3/maps/topics/events.html\r\n     */\n\n\n    _createClass(ChoroplethHereMaps, [{\n        key: 'setupEvents',\n        value: function setupEvents(mappos) {\n            var _this2 = this;\n\n            this.bGMap.addEventListener('mapviewchange', function () {\n                _this2.draw();\n            });\n            this.bGMap.addEventListener('drag', function () {\n                _this2.draw();\n            });\n            this.bGMap.addEventListener('tap', function (e) {\n                var coords = _this2.bGMap.getBackgroundMapProviderObject().screenToGeo(e.currentPointer.viewportX, e.currentPointer.viewportY);\n                var lon = coords.lng;\n                var lat = coords.lat;\n\n                if (_this2.rtree !== undefined) _this2.searchRTree(lon, lat);\n                if (_this2.kdtree !== undefined) _this2.searchKdTree(lon, lat);\n            });\n        }\n    }]);\n\n    return ChoroplethHereMaps;\n}(_Choropleth2.Choropleth);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy92MTEvMV9CYWNrZ3JvdW5kTWFwcy9DaG9yb3BsZXRoSGVyZU1hcHMuanM/ZmQxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaG9yb3BsZXRoIH0gZnJvbSAnLi4vLi4vVHlwZXMvQ2hvcm9wbGV0aCc7XHJcblxyXG4vKipcclxuICogQ2hvcm9wbGV0aCBpbXBsZW1lbnRhdGlvbiAwNi8wMyAtIDIzLzAzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hvcm9wbGV0aEhlcmVNYXBzIGV4dGVuZHMgQ2hvcm9wbGV0aCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENob3JvcGxldGguXHJcbiAgICAgKiBAcGFyYW0ge0JHTWFwV3JhcHBlcn0gYmdtYXAgLSBCYWNrZ3JvdW5kIG1hcCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gSlNPTiBvYmplY3Qgd2l0aCB0aGUgZ2VvbWV0cnkgdGhhdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zIC0gVXNlciBvcHRpb25zIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgQ2hvcm9wbGV0aFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIHVzZXJPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoYmdtYXAsIGdlb21ldHJ5LCB1c2VyT3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNOCkgU2V0dXAgYWxsIGV2ZW50cyB1c2VkIGJ5IHRoZSBBUEkuIFJpZ2h0IG5vdyB0aGUgQVBJIHVzZXM6IGRyYWcsIHpvb20gYW5kIGNsaWNrIGV2ZW50cy5cclxuICAgICAqIFBhbiA9IGRyYWcsIFpvb20gPSBtYXB2aWV3Y2hhbmdlLCBjbGljayA9IHRhcFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcHBvcyAtIFRoaXMgbWFwIGlkLiBcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmhlcmUuY29tL2phdmFzY3JpcHQtYXBpcy9kb2N1bWVudGF0aW9uL3YzL21hcHMvdG9waWNzL2V2ZW50cy5odG1sXHJcbiAgICAgKi9cclxuICAgIHNldHVwRXZlbnRzKG1hcHBvcykge1xyXG4gICAgICAgIHRoaXMuYkdNYXAuYWRkRXZlbnRMaXN0ZW5lcignbWFwdmlld2NoYW5nZScsICgpID0+IHsgdGhpcy5kcmF3KCk7IH0pO1xyXG4gICAgICAgIHRoaXMuYkdNYXAuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsICgpID0+IHsgdGhpcy5kcmF3KCk7IH0pO1xyXG4gICAgICAgIHRoaXMuYkdNYXAuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSB0aGlzLmJHTWFwLmdldEJhY2tncm91bmRNYXBQcm92aWRlck9iamVjdCgpLnNjcmVlblRvR2VvKGUuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBlLmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvbiA9IGNvb3Jkcy5sbmc7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhdCA9IGNvb3Jkcy5sYXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5ydHJlZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hSVHJlZShsb24sIGxhdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmtkdHJlZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hLZFRyZWUobG9uLCBsYXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvdjExLzFfQmFja2dyb3VuZE1hcHMvQ2hvcm9wbGV0aEhlcmVNYXBzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUdBOzs7QUFFQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 16 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************************************!*\
  !*** ./src/Gisplay/Maps/v11/1_BackgroundMaps/DotMapGoogleMaps.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DotMapGoogleMaps = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DotMap2 = __webpack_require__(/*! ../../Types/DotMap */ 5);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * DotMap Google Maps\r\n */\nvar DotMapGoogleMaps = exports.DotMapGoogleMaps = function (_DotMap) {\n    _inherits(DotMapGoogleMaps, _DotMap);\n\n    /**\r\n     * Creates an instance of DotMapGoogleMaps.\r\n     * @param {BGMapWrapper} bgmap - Background map object.\r\n     * @param {JSON} geometry - JSON object with the geometry that was read from the file.\r\n     * @param {Object} userOptions - User options to be used.\r\n     * @memberOf Choropleth\r\n     */\n    function DotMapGoogleMaps(bgmap, geometry, userOptions) {\n        _classCallCheck(this, DotMapGoogleMaps);\n\n        return _possibleConstructorReturn(this, (DotMapGoogleMaps.__proto__ || Object.getPrototypeOf(DotMapGoogleMaps)).call(this, bgmap, geometry, userOptions));\n    }\n\n    /**\r\n     * M8) Setup all events used by the API. Right now the API uses: drag, zoom and click events.\r\n     * Pan = drag, Zoom = zoom_changed, click = click\r\n     * @param {number} mappos - This map id. \r\n     * @return {void}\r\n     * @see https://developers.google.com/maps/documentation/javascript/events\r\n     */\n\n\n    _createClass(DotMapGoogleMaps, [{\n        key: 'setupEvents',\n        value: function setupEvents(mappos) {\n            var _this2 = this;\n\n            /*if(!this.gisplayOptions.interactive && this.gisplayOptions.mapOnClickFunction === undefined)\r\n                return;*/\n            this.bGMap.addEventListener('zoom_changed', function () {\n                _this2.draw();\n            });\n            this.bGMap.addEventListener('center_changed', function () {\n                _this2.draw();\n            });\n            this.bGMap.addEventListener('drag', function () {\n                _this2.draw();\n            });\n            this.bGMap.addEventListener('click', function (e) {\n                var lat = e.latLng.lat();\n                var lon = e.latLng.lng();\n                if (_this2.rtree !== undefined) _this2.searchRTree(lon, lat);\n                if (_this2.kdtree !== undefined) _this2.searchKdTree(lon, lat);\n            });\n        }\n    }]);\n\n    return DotMapGoogleMaps;\n}(_DotMap2.DotMap);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy92MTEvMV9CYWNrZ3JvdW5kTWFwcy9Eb3RNYXBHb29nbGVNYXBzLmpzPzY5ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRG90TWFwIH0gZnJvbSAnLi4vLi4vVHlwZXMvRG90TWFwJztcclxuXHJcbi8qKlxyXG4gKiBEb3RNYXAgR29vZ2xlIE1hcHNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEb3RNYXBHb29nbGVNYXBzIGV4dGVuZHMgRG90TWFwIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRG90TWFwR29vZ2xlTWFwcy5cclxuICAgICAqIEBwYXJhbSB7QkdNYXBXcmFwcGVyfSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBKU09OIG9iamVjdCB3aXRoIHRoZSBnZW9tZXRyeSB0aGF0IHdhcyByZWFkIGZyb20gdGhlIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlck9wdGlvbnMgLSBVc2VyIG9wdGlvbnMgdG8gYmUgdXNlZC5cclxuICAgICAqIEBtZW1iZXJPZiBDaG9yb3BsZXRoXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgdXNlck9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihiZ21hcCwgZ2VvbWV0cnksIHVzZXJPcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE04KSBTZXR1cCBhbGwgZXZlbnRzIHVzZWQgYnkgdGhlIEFQSS4gUmlnaHQgbm93IHRoZSBBUEkgdXNlczogZHJhZywgem9vbSBhbmQgY2xpY2sgZXZlbnRzLlxyXG4gICAgICogUGFuID0gZHJhZywgWm9vbSA9IHpvb21fY2hhbmdlZCwgY2xpY2sgPSBjbGlja1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcHBvcyAtIFRoaXMgbWFwIGlkLiBcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2V2ZW50c1xyXG4gICAgICovXHJcbiAgICBzZXR1cEV2ZW50cyhtYXBwb3MpIHtcclxuICAgICAgICAvKmlmKCF0aGlzLmdpc3BsYXlPcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuZ2lzcGxheU9wdGlvbnMubWFwT25DbGlja0Z1bmN0aW9uID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybjsqL1xyXG4gICAgICAgIHRoaXMuYkdNYXAuYWRkRXZlbnRMaXN0ZW5lcignem9vbV9jaGFuZ2VkJywgKCkgPT4geyB0aGlzLmRyYXcoKTsgfSk7XHJcbiAgICAgICAgdGhpcy5iR01hcC5hZGRFdmVudExpc3RlbmVyKCdjZW50ZXJfY2hhbmdlZCcsICgpID0+IHsgdGhpcy5kcmF3KCk7IH0pO1xyXG4gICAgICAgIHRoaXMuYkdNYXAuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsICgpID0+IHsgdGhpcy5kcmF3KCk7IH0pO1xyXG4gICAgICAgIHRoaXMuYkdNYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGF0ID0gZS5sYXRMbmcubGF0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvbiA9IGUubGF0TG5nLmxuZygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ydHJlZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hSVHJlZShsb24sIGxhdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmtkdHJlZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hLZFRyZWUobG9uLCBsYXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvdjExLzFfQmFja2dyb3VuZE1hcHMvRG90TWFwR29vZ2xlTWFwcy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFHQTs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./src/gisplayv1.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Gisplay = __webpack_require__(/*! ./Gisplay/Gisplay */ 6);\n\nmodule.exports = {\n\n    /** ######################### CHOROPLETH MAPS ################################# */\n    //Choropleth\n    createBGMap: function createBGMap() {\n        console.log(\"Start gisplayv2. TESTE workflow 25/03.\");\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChoropleth: function startChoropleth() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            colorScheme: [\"white\", \"yellow\", \"orange\", \"red\"],\n            numberOfClasses: 4,\n            attr: 'f3',\n            legendTitle: 'Fatals'\n        };\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n\n            gisplay.makeChoropleth(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    createBGMapChorocromatic: function createBGMapChorocromatic() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChorocromatic: function startChorocromatic() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            attr: 'f2',\n            legendTitle: \"Most Frequent Crime\"\n        };\n\n        var time = Date.now();\n        console.log(\"starting Chorocromatic Map...\");\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n            gisplay.makeChorochromaticMap(window.map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** ######################### DOT MAPS ################################# */\n    //DOT MAP Example 1\n    createBGMapDotMap: function createBGMapDotMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startDotMap1: function startDotMap1() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 1...\");\n\n        var options = {\n            colorScheme: [\"red\", \"green\"],\n            attr: 'f1',\n            legendTitle: \"Alcohol\"\n        };\n\n        var time = Date.now();\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n\n            gisplay.makeDotMap(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    //DOT MAP Example 2\n    startDotMap2: function startDotMap2() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 2...\");\n\n        var options = {\n            colorScheme: [\"blue\", \"red\"],\n            maxPointSize: 100,\n            numberOfClasses: 2,\n            classBreaksMethod: \"k-means\",\n            minPointSize: 1,\n            attr: 'f2',\n            legendTitle: \"Fatals\"\n        };\n\n        var time = Date.now();\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n            gisplay.makeDotMap(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** ######################### CHANGE MAPS ################################# */\n    createBGMapChangeMap: function createBGMapChangeMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChangeMap: function startChangeMap() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Change Map 1...\");\n\n        var options = {\n            colorScheme: [\"green\", \"red\"],\n            minuend: 'f6',\n            subtrahend: 'f2',\n            alpha: 1,\n            legendTitle: \"Evoluo entre 2009 e 2013\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeChangeMap(window.map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** ######################## PROP. SYMBOLS MAPS ########################### */\n    createBGPSymbols: function createBGPSymbols() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startPSymbols: function startPSymbols() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Proportional Symbols...\");\n        var options = {\n            maxPointSize: 100,\n            minPointSize: 5,\n            attr: 'f1',\n            alpha: 1.0,\n            numberOfLegendItems: 3,\n            legendTitle: \"Accidents\"\n        };\n\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeProportionalSymbolsMap(window.map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    }\n\n}; /**\r\n    * This file is the entry point for the Gisplay API\r\n    *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2dpc3BsYXl2MS5qcz9kZjBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGZpbGUgaXMgdGhlIGVudHJ5IHBvaW50IGZvciB0aGUgR2lzcGxheSBBUElcclxuICovXHJcbmltcG9ydCB7IEdpc3BsYXkgfSBmcm9tICcuL0dpc3BsYXkvR2lzcGxheSc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAvKiogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBDSE9ST1BMRVRIIE1BUFMgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICAvL0Nob3JvcGxldGhcclxuICAgIGNyZWF0ZUJHTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydCBnaXNwbGF5djIuIFRFU1RFIHdvcmtmbG93IDI1LzAzLlwiKTtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LnN0cmVldHMnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0Q2hvcm9wbGV0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29sb3JTY2hlbWU6IFtcIndoaXRlXCIsIFwieWVsbG93XCIsIFwib3JhbmdlXCIsIFwicmVkXCJdLFxyXG4gICAgICAgICAgICBudW1iZXJPZkNsYXNzZXM6IDQsXHJcbiAgICAgICAgICAgIGF0dHI6ICdmMycsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiAnRmF0YWxzJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhcmVhZHRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gZGUgbGVpdHVyYSBkbyBmaWNoZWlybzogXCIgKyAoZGF0YXJlYWR0aW1lc3RhbXAgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuXHJcbiAgICAgICAgICAgIGdpc3BsYXkubWFrZUNob3JvcGxldGgod2luZG93Lm1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gZ2lzcGxheTogXCIgKyAoRGF0ZS5ub3coKSAtIGRhdGFyZWFkdGltZXN0YW1wKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyB0b3RhbDogXCIgKyAoRGF0ZS5ub3coKSAtIHRpbWUpIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlQkdNYXBDaG9yb2Nyb21hdGljOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5zdHJlZXRzJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydENob3JvY3JvbWF0aWM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGF0dHI6ICdmMicsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiBcIk1vc3QgRnJlcXVlbnQgQ3JpbWVcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIENob3JvY3JvbWF0aWMgTWFwLi4uXCIpO1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhcmVhZHRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gZGUgbGVpdHVyYSBkbyBmaWNoZWlybzogXCIgKyAoZGF0YXJlYWR0aW1lc3RhbXAgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlQ2hvcm9jaHJvbWF0aWNNYXAod2luZG93Lm1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIERPVCBNQVBTICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgLy9ET1QgTUFQIEV4YW1wbGUgMVxyXG4gICAgY3JlYXRlQkdNYXBEb3RNYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LmRhcmsnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0RG90TWFwMTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIERvdCBNYXAgMS4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJyZWRcIiwgXCJncmVlblwiXSxcclxuICAgICAgICAgICAgYXR0cjogJ2YxJyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiQWxjb2hvbFwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgdmFyIGRhdGFyZWFkdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyBkZSBsZWl0dXJhIGRvIGZpY2hlaXJvOiBcIiArIChkYXRhcmVhZHRpbWVzdGFtcCAtIHRpbWUpIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG5cclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlRG90TWFwKHdpbmRvdy5tYXAsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIGdpc3BsYXk6IFwiICsgKERhdGUubm93KCkgLSBkYXRhcmVhZHRpbWVzdGFtcCkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gdG90YWw6IFwiICsgKERhdGUubm93KCkgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vRE9UIE1BUCBFeGFtcGxlIDJcclxuICAgIHN0YXJ0RG90TWFwMjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIERvdCBNYXAgMi4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJibHVlXCIsIFwicmVkXCJdLFxyXG4gICAgICAgICAgICBtYXhQb2ludFNpemU6IDEwMCxcclxuICAgICAgICAgICAgbnVtYmVyT2ZDbGFzc2VzOiAyLFxyXG4gICAgICAgICAgICBjbGFzc0JyZWFrc01ldGhvZDogXCJrLW1lYW5zXCIsXHJcbiAgICAgICAgICAgIG1pblBvaW50U2l6ZTogMSxcclxuICAgICAgICAgICAgYXR0cjogJ2YyJyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiRmF0YWxzXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YXJlYWR0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIGRlIGxlaXR1cmEgZG8gZmljaGVpcm86IFwiICsgKGRhdGFyZWFkdGltZXN0YW1wIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgICAgIGdpc3BsYXkubWFrZURvdE1hcCh3aW5kb3cubWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyBnaXNwbGF5OiBcIiArIChEYXRlLm5vdygpIC0gZGF0YXJlYWR0aW1lc3RhbXApIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIHRvdGFsOiBcIiArIChEYXRlLm5vdygpIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGVcIikuZmlsZXNbMF0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBDSEFOR0UgTUFQUyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIGNyZWF0ZUJHTWFwQ2hhbmdlTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5kYXJrJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydENoYW5nZU1hcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIENoYW5nZSBNYXAgMS4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJncmVlblwiLCBcInJlZFwiXSxcclxuICAgICAgICAgICAgbWludWVuZDogJ2Y2JyxcclxuICAgICAgICAgICAgc3VidHJhaGVuZDogJ2YyJyxcclxuICAgICAgICAgICAgYWxwaGE6IDEsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiBcIkV2b2x1w6fDo28gZW50cmUgMjAwOSBlIDIwMTNcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlQ2hhbmdlTWFwKHdpbmRvdy5tYXAsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGVcIikuZmlsZXNbMF0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFBST1AuIFNZTUJPTFMgTUFQUyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIGNyZWF0ZUJHUFN5bWJvbHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LmRhcmsnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0UFN5bWJvbHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBQcm9wb3J0aW9uYWwgU3ltYm9scy4uLlwiKTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWF4UG9pbnRTaXplOiAxMDAsXHJcbiAgICAgICAgICAgIG1pblBvaW50U2l6ZTogNSxcclxuICAgICAgICAgICAgYXR0cjogJ2YxJyxcclxuICAgICAgICAgICAgYWxwaGE6IDEuMCxcclxuICAgICAgICAgICAgbnVtYmVyT2ZMZWdlbmRJdGVtczogMyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiQWNjaWRlbnRzXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlUHJvcG9ydGlvbmFsU3ltYm9sc01hcCh3aW5kb3cubWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgSEVBVCBNQVAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICovXHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2lzcGxheXYxLmpzIl0sIm1hcHBpbmdzIjoiOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExS0E7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);